/**
 * Client
 **/

import * as runtime from "./runtime/library.js";
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Role
 *
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>;
/**
 * Model UserRole
 *
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>;
/**
 * Model Product
 *
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>;
/**
 * Model ProductImage
 *
 */
export type ProductImage = $Result.DefaultSelection<Prisma.$ProductImagePayload>;
/**
 * Model ProductVariant
 *
 */
export type ProductVariant = $Result.DefaultSelection<Prisma.$ProductVariantPayload>;
/**
 * Model Inventory
 *
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>;
/**
 * Model Order
 *
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>;
/**
 * Model OrderItem
 *
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>;
/**
 * Model Coupon
 *
 */
export type Coupon = $Result.DefaultSelection<Prisma.$CouponPayload>;
/**
 * Model Review
 *
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>;
/**
 * Model Wishlist
 *
 */
export type Wishlist = $Result.DefaultSelection<Prisma.$WishlistPayload>;
/**
 * Model WishlistItem
 *
 */
export type WishlistItem = $Result.DefaultSelection<Prisma.$WishlistItemPayload>;
/**
 * Model Address
 *
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>;
/**
 * Model AuditLog
 *
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>;
/**
 * Model ReturnRequest
 *
 */
export type ReturnRequest = $Result.DefaultSelection<Prisma.$ReturnRequestPayload>;
/**
 * Model Refund
 *
 */
export type Refund = $Result.DefaultSelection<Prisma.$RefundPayload>;
/**
 * Model PaymentMeta
 *
 */
export type PaymentMeta = $Result.DefaultSelection<Prisma.$PaymentMetaPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const ProductStatus: {
    DRAFT: "DRAFT";
    PUBLISHED: "PUBLISHED";
    ARCHIVED: "ARCHIVED";
  };

  export type ProductStatus = (typeof ProductStatus)[keyof typeof ProductStatus];

  export const OrderStatus: {
    CREATED: "CREATED";
    PENDING_PAYMENT: "PENDING_PAYMENT";
    PAID: "PAID";
    FAILED_PAYMENT: "FAILED_PAYMENT";
    COD_PENDING: "COD_PENDING";
    COD_COMPLETED: "COD_COMPLETED";
    FULFILLED: "FULFILLED";
    CANCELLED: "CANCELLED";
    REFUNDED: "REFUNDED";
  };

  export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus];

  export const PaymentMethod: {
    VNPAY: "VNPAY";
    COD: "COD";
    WALLET: "WALLET";
    OTHER: "OTHER";
  };

  export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod];

  export const CouponType: {
    PERCENT: "PERCENT";
    FIXED: "FIXED";
    BOGO: "BOGO";
  };

  export type CouponType = (typeof CouponType)[keyof typeof CouponType];

  export const RefundStatus: {
    PENDING: "PENDING";
    COMPLETED: "COMPLETED";
    FAILED: "FAILED";
  };

  export type RefundStatus = (typeof RefundStatus)[keyof typeof RefundStatus];

  export const ReturnStatus: {
    PENDING: "PENDING";
    APPROVED: "APPROVED";
    REJECTED: "REJECTED";
    RECEIVED: "RECEIVED";
  };

  export type ReturnStatus = (typeof ReturnStatus)[keyof typeof ReturnStatus];
}

export type ProductStatus = $Enums.ProductStatus;

export const ProductStatus: typeof $Enums.ProductStatus;

export type OrderStatus = $Enums.OrderStatus;

export const OrderStatus: typeof $Enums.OrderStatus;

export type PaymentMethod = $Enums.PaymentMethod;

export const PaymentMethod: typeof $Enums.PaymentMethod;

export type CouponType = $Enums.CouponType;

export const CouponType: typeof $Enums.CouponType;

export type RefundStatus = $Enums.RefundStatus;

export const RefundStatus: typeof $Enums.RefundStatus;

export type ReturnStatus = $Enums.ReturnStatus;

export const ReturnStatus: typeof $Enums.ReturnStatus;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = "log" extends keyof ClientOptions
    ? ClientOptions["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions["log"]>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(
    eventType: V,
    callback: (event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent) => void
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    "extends",
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserRoles
   * const userRoles = await prisma.userRole.findMany()
   * ```
   */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Products
   * const products = await prisma.product.findMany()
   * ```
   */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productImage`: Exposes CRUD operations for the **ProductImage** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ProductImages
   * const productImages = await prisma.productImage.findMany()
   * ```
   */
  get productImage(): Prisma.ProductImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productVariant`: Exposes CRUD operations for the **ProductVariant** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ProductVariants
   * const productVariants = await prisma.productVariant.findMany()
   * ```
   */
  get productVariant(): Prisma.ProductVariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Inventories
   * const inventories = await prisma.inventory.findMany()
   * ```
   */
  get inventory(): Prisma.InventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Orders
   * const orders = await prisma.order.findMany()
   * ```
   */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more OrderItems
   * const orderItems = await prisma.orderItem.findMany()
   * ```
   */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Coupons
   * const coupons = await prisma.coupon.findMany()
   * ```
   */
  get coupon(): Prisma.CouponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Reviews
   * const reviews = await prisma.review.findMany()
   * ```
   */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wishlist`: Exposes CRUD operations for the **Wishlist** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Wishlists
   * const wishlists = await prisma.wishlist.findMany()
   * ```
   */
  get wishlist(): Prisma.WishlistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wishlistItem`: Exposes CRUD operations for the **WishlistItem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more WishlistItems
   * const wishlistItems = await prisma.wishlistItem.findMany()
   * ```
   */
  get wishlistItem(): Prisma.WishlistItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Addresses
   * const addresses = await prisma.address.findMany()
   * ```
   */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AuditLogs
   * const auditLogs = await prisma.auditLog.findMany()
   * ```
   */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.returnRequest`: Exposes CRUD operations for the **ReturnRequest** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ReturnRequests
   * const returnRequests = await prisma.returnRequest.findMany()
   * ```
   */
  get returnRequest(): Prisma.ReturnRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refund`: Exposes CRUD operations for the **Refund** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Refunds
   * const refunds = await prisma.refund.findMany()
   * ```
   */
  get refund(): Prisma.RefundDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMeta`: Exposes CRUD operations for the **PaymentMeta** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PaymentMetas
   * const paymentMetas = await prisma.paymentMeta.findMany()
   * ```
   */
  get paymentMeta(): Prisma.PaymentMetaDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.16.3
   * Query Engine version: bb420e667c1820a8c05a38023385f6cc7ef8e83a
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? "Please either choose `select` or `include`."
    : T extends SelectAndOmit
      ? "Please either choose `select` or `omit`."
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object ? (U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : U) : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
    ? _Either<O, K, strict>
    : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ? (K extends keyof O ? { [P in K]: O[P] } & O : O) | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<T, U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">> = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<Or<Extends<"OR", K>, Extends<"AND", K>>, Extends<"NOT", K>> extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>;

  export const ModelName: {
    User: "User";
    Role: "Role";
    UserRole: "UserRole";
    Product: "Product";
    ProductImage: "ProductImage";
    ProductVariant: "ProductVariant";
    Inventory: "Inventory";
    Order: "Order";
    OrderItem: "OrderItem";
    Coupon: "Coupon";
    Review: "Review";
    Wishlist: "Wishlist";
    WishlistItem: "WishlistItem";
    Address: "Address";
    AuditLog: "AuditLog";
    ReturnRequest: "ReturnRequest";
    Refund: "Refund";
    PaymentMeta: "PaymentMeta";
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<{ extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<
      this["params"]["extArgs"],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | "user"
        | "role"
        | "userRole"
        | "product"
        | "productImage"
        | "productVariant"
        | "inventory"
        | "order"
        | "orderItem"
        | "coupon"
        | "review"
        | "wishlist"
        | "wishlistItem"
        | "address"
        | "auditLog"
        | "returnRequest"
        | "refund"
        | "paymentMeta";
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>;
        fields: Prisma.RoleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[];
          };
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[];
          };
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[];
          };
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRole>;
          };
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RoleGroupByOutputType>[];
          };
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>;
            result: $Utils.Optional<RoleCountAggregateOutputType> | number;
          };
        };
      };
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>;
        fields: Prisma.UserRoleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>;
          };
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>;
          };
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[];
          };
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>;
          };
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[];
          };
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>;
          };
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>;
          };
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[];
          };
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>;
          };
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserRole>;
          };
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserRoleGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>;
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number;
          };
        };
      };
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>;
        fields: Prisma.ProductFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>;
          };
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>;
          };
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[];
          };
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>;
          };
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[];
          };
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>;
          };
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>;
          };
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[];
          };
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>;
          };
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateProduct>;
          };
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ProductGroupByOutputType>[];
          };
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>;
            result: $Utils.Optional<ProductCountAggregateOutputType> | number;
          };
        };
      };
      ProductImage: {
        payload: Prisma.$ProductImagePayload<ExtArgs>;
        fields: Prisma.ProductImageFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ProductImageFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ProductImageFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>;
          };
          findFirst: {
            args: Prisma.ProductImageFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ProductImageFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>;
          };
          findMany: {
            args: Prisma.ProductImageFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[];
          };
          create: {
            args: Prisma.ProductImageCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>;
          };
          createMany: {
            args: Prisma.ProductImageCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ProductImageCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[];
          };
          delete: {
            args: Prisma.ProductImageDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>;
          };
          update: {
            args: Prisma.ProductImageUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>;
          };
          deleteMany: {
            args: Prisma.ProductImageDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ProductImageUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ProductImageUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[];
          };
          upsert: {
            args: Prisma.ProductImageUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>;
          };
          aggregate: {
            args: Prisma.ProductImageAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateProductImage>;
          };
          groupBy: {
            args: Prisma.ProductImageGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ProductImageGroupByOutputType>[];
          };
          count: {
            args: Prisma.ProductImageCountArgs<ExtArgs>;
            result: $Utils.Optional<ProductImageCountAggregateOutputType> | number;
          };
        };
      };
      ProductVariant: {
        payload: Prisma.$ProductVariantPayload<ExtArgs>;
        fields: Prisma.ProductVariantFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ProductVariantFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ProductVariantFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>;
          };
          findFirst: {
            args: Prisma.ProductVariantFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ProductVariantFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>;
          };
          findMany: {
            args: Prisma.ProductVariantFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[];
          };
          create: {
            args: Prisma.ProductVariantCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>;
          };
          createMany: {
            args: Prisma.ProductVariantCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ProductVariantCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[];
          };
          delete: {
            args: Prisma.ProductVariantDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>;
          };
          update: {
            args: Prisma.ProductVariantUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>;
          };
          deleteMany: {
            args: Prisma.ProductVariantDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ProductVariantUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ProductVariantUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[];
          };
          upsert: {
            args: Prisma.ProductVariantUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>;
          };
          aggregate: {
            args: Prisma.ProductVariantAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateProductVariant>;
          };
          groupBy: {
            args: Prisma.ProductVariantGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ProductVariantGroupByOutputType>[];
          };
          count: {
            args: Prisma.ProductVariantCountArgs<ExtArgs>;
            result: $Utils.Optional<ProductVariantCountAggregateOutputType> | number;
          };
        };
      };
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>;
        fields: Prisma.InventoryFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>;
          };
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>;
          };
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[];
          };
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>;
          };
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.InventoryCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[];
          };
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>;
          };
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>;
          };
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.InventoryUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[];
          };
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>;
          };
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateInventory>;
          };
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>;
            result: $Utils.Optional<InventoryGroupByOutputType>[];
          };
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>;
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number;
          };
        };
      };
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>;
        fields: Prisma.OrderFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[];
          };
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[];
          };
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[];
          };
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrder>;
          };
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrderGroupByOutputType>[];
          };
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>;
            result: $Utils.Optional<OrderCountAggregateOutputType> | number;
          };
        };
      };
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>;
        fields: Prisma.OrderItemFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[];
          };
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[];
          };
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[];
          };
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrderItem>;
          };
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrderItemGroupByOutputType>[];
          };
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>;
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number;
          };
        };
      };
      Coupon: {
        payload: Prisma.$CouponPayload<ExtArgs>;
        fields: Prisma.CouponFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CouponFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CouponFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>;
          };
          findFirst: {
            args: Prisma.CouponFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CouponFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>;
          };
          findMany: {
            args: Prisma.CouponFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[];
          };
          create: {
            args: Prisma.CouponCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>;
          };
          createMany: {
            args: Prisma.CouponCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CouponCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[];
          };
          delete: {
            args: Prisma.CouponDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>;
          };
          update: {
            args: Prisma.CouponUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>;
          };
          deleteMany: {
            args: Prisma.CouponDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CouponUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.CouponUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[];
          };
          upsert: {
            args: Prisma.CouponUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>;
          };
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCoupon>;
          };
          groupBy: {
            args: Prisma.CouponGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CouponGroupByOutputType>[];
          };
          count: {
            args: Prisma.CouponCountArgs<ExtArgs>;
            result: $Utils.Optional<CouponCountAggregateOutputType> | number;
          };
        };
      };
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>;
        fields: Prisma.ReviewFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[];
          };
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[];
          };
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[];
          };
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateReview>;
          };
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ReviewGroupByOutputType>[];
          };
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>;
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number;
          };
        };
      };
      Wishlist: {
        payload: Prisma.$WishlistPayload<ExtArgs>;
        fields: Prisma.WishlistFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.WishlistFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.WishlistFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>;
          };
          findFirst: {
            args: Prisma.WishlistFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.WishlistFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>;
          };
          findMany: {
            args: Prisma.WishlistFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>[];
          };
          create: {
            args: Prisma.WishlistCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>;
          };
          createMany: {
            args: Prisma.WishlistCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.WishlistCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>[];
          };
          delete: {
            args: Prisma.WishlistDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>;
          };
          update: {
            args: Prisma.WishlistUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>;
          };
          deleteMany: {
            args: Prisma.WishlistDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.WishlistUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.WishlistUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>[];
          };
          upsert: {
            args: Prisma.WishlistUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>;
          };
          aggregate: {
            args: Prisma.WishlistAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateWishlist>;
          };
          groupBy: {
            args: Prisma.WishlistGroupByArgs<ExtArgs>;
            result: $Utils.Optional<WishlistGroupByOutputType>[];
          };
          count: {
            args: Prisma.WishlistCountArgs<ExtArgs>;
            result: $Utils.Optional<WishlistCountAggregateOutputType> | number;
          };
        };
      };
      WishlistItem: {
        payload: Prisma.$WishlistItemPayload<ExtArgs>;
        fields: Prisma.WishlistItemFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.WishlistItemFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.WishlistItemFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>;
          };
          findFirst: {
            args: Prisma.WishlistItemFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.WishlistItemFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>;
          };
          findMany: {
            args: Prisma.WishlistItemFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>[];
          };
          create: {
            args: Prisma.WishlistItemCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>;
          };
          createMany: {
            args: Prisma.WishlistItemCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.WishlistItemCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>[];
          };
          delete: {
            args: Prisma.WishlistItemDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>;
          };
          update: {
            args: Prisma.WishlistItemUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>;
          };
          deleteMany: {
            args: Prisma.WishlistItemDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.WishlistItemUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.WishlistItemUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>[];
          };
          upsert: {
            args: Prisma.WishlistItemUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>;
          };
          aggregate: {
            args: Prisma.WishlistItemAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateWishlistItem>;
          };
          groupBy: {
            args: Prisma.WishlistItemGroupByArgs<ExtArgs>;
            result: $Utils.Optional<WishlistItemGroupByOutputType>[];
          };
          count: {
            args: Prisma.WishlistItemCountArgs<ExtArgs>;
            result: $Utils.Optional<WishlistItemCountAggregateOutputType> | number;
          };
        };
      };
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>;
        fields: Prisma.AddressFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[];
          };
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[];
          };
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[];
          };
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAddress>;
          };
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AddressGroupByOutputType>[];
          };
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>;
            result: $Utils.Optional<AddressCountAggregateOutputType> | number;
          };
        };
      };
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>;
        fields: Prisma.AuditLogFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAuditLog>;
          };
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogGroupByOutputType>[];
          };
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number;
          };
        };
      };
      ReturnRequest: {
        payload: Prisma.$ReturnRequestPayload<ExtArgs>;
        fields: Prisma.ReturnRequestFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ReturnRequestFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ReturnRequestFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>;
          };
          findFirst: {
            args: Prisma.ReturnRequestFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ReturnRequestFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>;
          };
          findMany: {
            args: Prisma.ReturnRequestFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>[];
          };
          create: {
            args: Prisma.ReturnRequestCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>;
          };
          createMany: {
            args: Prisma.ReturnRequestCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ReturnRequestCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>[];
          };
          delete: {
            args: Prisma.ReturnRequestDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>;
          };
          update: {
            args: Prisma.ReturnRequestUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>;
          };
          deleteMany: {
            args: Prisma.ReturnRequestDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ReturnRequestUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ReturnRequestUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>[];
          };
          upsert: {
            args: Prisma.ReturnRequestUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>;
          };
          aggregate: {
            args: Prisma.ReturnRequestAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateReturnRequest>;
          };
          groupBy: {
            args: Prisma.ReturnRequestGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ReturnRequestGroupByOutputType>[];
          };
          count: {
            args: Prisma.ReturnRequestCountArgs<ExtArgs>;
            result: $Utils.Optional<ReturnRequestCountAggregateOutputType> | number;
          };
        };
      };
      Refund: {
        payload: Prisma.$RefundPayload<ExtArgs>;
        fields: Prisma.RefundFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RefundFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefundPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RefundFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>;
          };
          findFirst: {
            args: Prisma.RefundFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefundPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RefundFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>;
          };
          findMany: {
            args: Prisma.RefundFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[];
          };
          create: {
            args: Prisma.RefundCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>;
          };
          createMany: {
            args: Prisma.RefundCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.RefundCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[];
          };
          delete: {
            args: Prisma.RefundDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>;
          };
          update: {
            args: Prisma.RefundUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>;
          };
          deleteMany: {
            args: Prisma.RefundDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RefundUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.RefundUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[];
          };
          upsert: {
            args: Prisma.RefundUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>;
          };
          aggregate: {
            args: Prisma.RefundAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRefund>;
          };
          groupBy: {
            args: Prisma.RefundGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RefundGroupByOutputType>[];
          };
          count: {
            args: Prisma.RefundCountArgs<ExtArgs>;
            result: $Utils.Optional<RefundCountAggregateOutputType> | number;
          };
        };
      };
      PaymentMeta: {
        payload: Prisma.$PaymentMetaPayload<ExtArgs>;
        fields: Prisma.PaymentMetaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PaymentMetaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentMetaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PaymentMetaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentMetaPayload>;
          };
          findFirst: {
            args: Prisma.PaymentMetaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentMetaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PaymentMetaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentMetaPayload>;
          };
          findMany: {
            args: Prisma.PaymentMetaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentMetaPayload>[];
          };
          create: {
            args: Prisma.PaymentMetaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentMetaPayload>;
          };
          createMany: {
            args: Prisma.PaymentMetaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PaymentMetaCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentMetaPayload>[];
          };
          delete: {
            args: Prisma.PaymentMetaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentMetaPayload>;
          };
          update: {
            args: Prisma.PaymentMetaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentMetaPayload>;
          };
          deleteMany: {
            args: Prisma.PaymentMetaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PaymentMetaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.PaymentMetaUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentMetaPayload>[];
          };
          upsert: {
            args: Prisma.PaymentMetaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentMetaPayload>;
          };
          aggregate: {
            args: Prisma.PaymentMetaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePaymentMeta>;
          };
          groupBy: {
            args: Prisma.PaymentMetaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PaymentMetaGroupByOutputType>[];
          };
          count: {
            args: Prisma.PaymentMetaCountArgs<ExtArgs>;
            result: $Utils.Optional<PaymentMetaCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = "pretty" | "colorless" | "minimal";
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null;
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    user?: UserOmit;
    role?: RoleOmit;
    userRole?: UserRoleOmit;
    product?: ProductOmit;
    productImage?: ProductImageOmit;
    productVariant?: ProductVariantOmit;
    inventory?: InventoryOmit;
    order?: OrderOmit;
    orderItem?: OrderItemOmit;
    coupon?: CouponOmit;
    review?: ReviewOmit;
    wishlist?: WishlistOmit;
    wishlistItem?: WishlistItemOmit;
    address?: AddressOmit;
    auditLog?: AuditLogOmit;
    returnRequest?: ReturnRequestOmit;
    refund?: RefundOmit;
    paymentMeta?: PaymentMetaOmit;
  };

  /* Types for Logging */
  export type LogLevel = "info" | "query" | "warn" | "error";
  export type LogDefinition = {
    level: LogLevel;
    emit: "stdout" | "event";
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<T extends LogDefinition ? T["level"] : T>;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | "findUnique"
    | "findUniqueOrThrow"
    | "findMany"
    | "findFirst"
    | "findFirstOrThrow"
    | "create"
    | "createMany"
    | "createManyAndReturn"
    | "update"
    | "updateMany"
    | "updateManyAndReturn"
    | "upsert"
    | "delete"
    | "deleteMany"
    | "executeRaw"
    | "queryRaw"
    | "aggregate"
    | "count"
    | "runCommandRaw"
    | "findRaw"
    | "groupBy";

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    userRoles: number;
    addresses: number;
    reviews: number;
    orders: number;
    AuditLog: number;
  };

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | UserCountOutputTypeCountUserRolesArgs;
    addresses?: boolean | UserCountOutputTypeCountAddressesArgs;
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs;
    orders?: boolean | UserCountOutputTypeCountOrdersArgs;
    AuditLog?: boolean | UserCountOutputTypeCountAuditLogArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserRoleWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddressesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AddressWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: ReviewWhereInput;
    };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: AuditLogWhereInput;
    };

  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    userRoles: number;
  };

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | RoleCountOutputTypeCountUserRolesArgs;
  };

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserRoleWhereInput;
  };

  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    images: number;
    variants: number;
    reviews: number;
    OrderItem: number;
    WishlistItem: number;
  };

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | ProductCountOutputTypeCountImagesArgs;
    variants?: boolean | ProductCountOutputTypeCountVariantsArgs;
    reviews?: boolean | ProductCountOutputTypeCountReviewsArgs;
    OrderItem?: boolean | ProductCountOutputTypeCountOrderItemArgs;
    WishlistItem?: boolean | ProductCountOutputTypeCountWishlistItemArgs;
  };

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountImagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProductImageWhereInput;
  };

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountVariantsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProductVariantWhereInput;
  };

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountReviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ReviewWhereInput;
  };

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderItemWhereInput;
  };

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountWishlistItemArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WishlistItemWhereInput;
  };

  /**
   * Count Type ProductVariantCountOutputType
   */

  export type ProductVariantCountOutputType = {
    inventory: number;
    OrderItem: number;
  };

  export type ProductVariantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      inventory?: boolean | ProductVariantCountOutputTypeCountInventoryArgs;
      OrderItem?: boolean | ProductVariantCountOutputTypeCountOrderItemArgs;
    };

  // Custom InputTypes
  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductVariantCountOutputType
     */
    select?: ProductVariantCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountInventoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InventoryWhereInput;
  };

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountOrderItemArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderItemWhereInput;
  };

  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number;
    ReturnRequest: number;
    Refund: number;
  };

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs;
    ReturnRequest?: boolean | OrderCountOutputTypeCountReturnRequestArgs;
    Refund?: boolean | OrderCountOutputTypeCountRefundArgs;
  };

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput;
  };

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountReturnRequestArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ReturnRequestWhereInput;
  };

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountRefundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: RefundWhereInput;
    };

  /**
   * Count Type OrderItemCountOutputType
   */

  export type OrderItemCountOutputType = {
    ReturnRequest: number;
  };

  export type OrderItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ReturnRequest?: boolean | OrderItemCountOutputTypeCountReturnRequestArgs;
  };

  // Custom InputTypes
  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the OrderItemCountOutputType
       */
      select?: OrderItemCountOutputTypeSelect<ExtArgs> | null;
    };

  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeCountReturnRequestArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ReturnRequestWhereInput;
  };

  /**
   * Count Type CouponCountOutputType
   */

  export type CouponCountOutputType = {
    Order: number;
  };

  export type CouponCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Order?: boolean | CouponCountOutputTypeCountOrderArgs;
  };

  // Custom InputTypes
  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponCountOutputType
     */
    select?: CouponCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: OrderWhereInput;
    };

  /**
   * Count Type WishlistCountOutputType
   */

  export type WishlistCountOutputType = {
    items: number;
  };

  export type WishlistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | WishlistCountOutputTypeCountItemsArgs;
  };

  // Custom InputTypes
  /**
   * WishlistCountOutputType without action
   */
  export type WishlistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistCountOutputType
     */
    select?: WishlistCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * WishlistCountOutputType without action
   */
  export type WishlistCountOutputTypeCountItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WishlistItemWhereInput;
  };

  /**
   * Count Type AddressCountOutputType
   */

  export type AddressCountOutputType = {
    ordersShipping: number;
    ordersBilling: number;
  };

  export type AddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordersShipping?: boolean | AddressCountOutputTypeCountOrdersShippingArgs;
    ordersBilling?: boolean | AddressCountOutputTypeCountOrdersBillingArgs;
  };

  // Custom InputTypes
  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountOrdersShippingArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderWhereInput;
  };

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountOrdersBillingArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _avg: UserAvgAggregateOutputType | null;
    _sum: UserSumAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserAvgAggregateOutputType = {
    id: number | null;
  };

  export type UserSumAggregateOutputType = {
    id: number | null;
  };

  export type UserMinAggregateOutputType = {
    id: number | null;
    email: string | null;
    username: string | null;
    password: string | null;
    displayName: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    lastLogin: Date | null;
  };

  export type UserMaxAggregateOutputType = {
    id: number | null;
    email: string | null;
    username: string | null;
    password: string | null;
    displayName: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    lastLogin: Date | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    email: number;
    username: number;
    password: number;
    displayName: number;
    createdAt: number;
    updatedAt: number;
    lastLogin: number;
    _all: number;
  };

  export type UserAvgAggregateInputType = {
    id?: true;
  };

  export type UserSumAggregateInputType = {
    id?: true;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    email?: true;
    username?: true;
    password?: true;
    displayName?: true;
    createdAt?: true;
    updatedAt?: true;
    lastLogin?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    email?: true;
    username?: true;
    password?: true;
    displayName?: true;
    createdAt?: true;
    updatedAt?: true;
    lastLogin?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    email?: true;
    username?: true;
    password?: true;
    displayName?: true;
    createdAt?: true;
    updatedAt?: true;
    lastLogin?: true;
    _all?: true;
  };

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UserAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UserSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput;
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[];
    by: UserScalarFieldEnum[] | UserScalarFieldEnum;
    having?: UserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCountAggregateInputType | true;
    _avg?: UserAvgAggregateInputType;
    _sum?: UserSumAggregateInputType;
    _min?: UserMinAggregateInputType;
    _max?: UserMaxAggregateInputType;
  };

  export type UserGroupByOutputType = {
    id: number;
    email: string;
    username: string | null;
    password: string | null;
    displayName: string | null;
    createdAt: Date;
    updatedAt: Date;
    lastLogin: Date | null;
    _count: UserCountAggregateOutputType | null;
    _avg: UserAvgAggregateOutputType | null;
    _sum: UserSumAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      username?: boolean;
      password?: boolean;
      displayName?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      lastLogin?: boolean;
      userRoles?: boolean | User$userRolesArgs<ExtArgs>;
      addresses?: boolean | User$addressesArgs<ExtArgs>;
      wishlist?: boolean | User$wishlistArgs<ExtArgs>;
      reviews?: boolean | User$reviewsArgs<ExtArgs>;
      orders?: boolean | User$ordersArgs<ExtArgs>;
      AuditLog?: boolean | User$AuditLogArgs<ExtArgs>;
      _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        email?: boolean;
        username?: boolean;
        password?: boolean;
        displayName?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        lastLogin?: boolean;
      },
      ExtArgs["result"]["user"]
    >;

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        email?: boolean;
        username?: boolean;
        password?: boolean;
        displayName?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        lastLogin?: boolean;
      },
      ExtArgs["result"]["user"]
    >;

  export type UserSelectScalar = {
    id?: boolean;
    email?: boolean;
    username?: boolean;
    password?: boolean;
    displayName?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    lastLogin?: boolean;
  };

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    "id" | "email" | "username" | "password" | "displayName" | "createdAt" | "updatedAt" | "lastLogin",
    ExtArgs["result"]["user"]
  >;
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | User$userRolesArgs<ExtArgs>;
    addresses?: boolean | User$addressesArgs<ExtArgs>;
    wishlist?: boolean | User$wishlistArgs<ExtArgs>;
    reviews?: boolean | User$reviewsArgs<ExtArgs>;
    orders?: boolean | User$ordersArgs<ExtArgs>;
    AuditLog?: boolean | User$AuditLogArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {};
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {};

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User";
    objects: {
      userRoles: Prisma.$UserRolePayload<ExtArgs>[];
      addresses: Prisma.$AddressPayload<ExtArgs>[];
      wishlist: Prisma.$WishlistPayload<ExtArgs> | null;
      reviews: Prisma.$ReviewPayload<ExtArgs>[];
      orders: Prisma.$OrderPayload<ExtArgs>[];
      AuditLog: Prisma.$AuditLogPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        email: string;
        username: string | null;
        password: string | null;
        displayName: string | null;
        createdAt: Date;
        updatedAt: Date;
        lastLogin: Date | null;
      },
      ExtArgs["result"]["user"]
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<
    Prisma.$UserPayload,
    S
  >;

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    UserFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["User"]; meta: { name: "User" } };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs["orderBy"] }
        : { orderBy?: UserGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    userRoles<T extends User$userRolesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$userRolesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    addresses<T extends User$addressesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$addressesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    wishlist<T extends User$wishlistArgs<ExtArgs> = {}>(
      args?: Subset<T, User$wishlistArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$reviewsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    orders<T extends User$ordersArgs<ExtArgs> = {}>(
      args?: Subset<T, User$ordersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    AuditLog<T extends User$AuditLogArgs<ExtArgs> = {}>(
      args?: Subset<T, User$AuditLogArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", "Int">;
    readonly email: FieldRef<"User", "String">;
    readonly username: FieldRef<"User", "String">;
    readonly password: FieldRef<"User", "String">;
    readonly displayName: FieldRef<"User", "String">;
    readonly createdAt: FieldRef<"User", "DateTime">;
    readonly updatedAt: FieldRef<"User", "DateTime">;
    readonly lastLogin: FieldRef<"User", "DateTime">;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.userRoles
   */
  export type User$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    where?: UserRoleWhereInput;
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[];
    cursor?: UserRoleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[];
  };

  /**
   * User.addresses
   */
  export type User$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    where?: AddressWhereInput;
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[];
    cursor?: AddressWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[];
  };

  /**
   * User.wishlist
   */
  export type User$wishlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    where?: WishlistWhereInput;
  };

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    cursor?: ReviewWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    where?: OrderWhereInput;
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    cursor?: OrderWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * User.AuditLog
   */
  export type User$AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    where?: AuditLogWhereInput;
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    cursor?: AuditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
  };

  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null;
    _avg: RoleAvgAggregateOutputType | null;
    _sum: RoleSumAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  export type RoleAvgAggregateOutputType = {
    id: number | null;
  };

  export type RoleSumAggregateOutputType = {
    id: number | null;
  };

  export type RoleMinAggregateOutputType = {
    id: number | null;
    name: string | null;
  };

  export type RoleMaxAggregateOutputType = {
    id: number | null;
    name: string | null;
  };

  export type RoleCountAggregateOutputType = {
    id: number;
    name: number;
    _all: number;
  };

  export type RoleAvgAggregateInputType = {
    id?: true;
  };

  export type RoleSumAggregateInputType = {
    id?: true;
  };

  export type RoleMinAggregateInputType = {
    id?: true;
    name?: true;
  };

  export type RoleMaxAggregateInputType = {
    id?: true;
    name?: true;
  };

  export type RoleCountAggregateInputType = {
    id?: true;
    name?: true;
    _all?: true;
  };

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Roles
     **/
    _count?: true | RoleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: RoleAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: RoleSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RoleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RoleMaxAggregateInputType;
  };

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
    [P in keyof T & keyof AggregateRole]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>;
  };

  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput;
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[];
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum;
    having?: RoleScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RoleCountAggregateInputType | true;
    _avg?: RoleAvgAggregateInputType;
    _sum?: RoleSumAggregateInputType;
    _min?: RoleMinAggregateInputType;
    _max?: RoleMaxAggregateInputType;
  };

  export type RoleGroupByOutputType = {
    id: number;
    name: string;
    _count: RoleCountAggregateOutputType | null;
    _avg: RoleAvgAggregateOutputType | null;
    _sum: RoleSumAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof RoleGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
          : GetScalarType<T[P], RoleGroupByOutputType[P]>;
      }
    >
  >;

  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      userRoles?: boolean | Role$userRolesArgs<ExtArgs>;
      _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["role"]
  >;

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
      },
      ExtArgs["result"]["role"]
    >;

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
      },
      ExtArgs["result"]["role"]
    >;

  export type RoleSelectScalar = {
    id?: boolean;
    name?: boolean;
  };

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    "id" | "name",
    ExtArgs["result"]["role"]
  >;
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>;
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {};
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {};

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role";
    objects: {
      userRoles: Prisma.$UserRolePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        name: string;
      },
      ExtArgs["result"]["role"]
    >;
    composites: {};
  };

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<
    Prisma.$RolePayload,
    S
  >;

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    RoleFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: RoleCountAggregateInputType | true;
  };

  export interface RoleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["Role"]; meta: { name: "Role" } };
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(
      args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(
      args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     *
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     *
     */
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(
      args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     *
     */
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(
      args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
     **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], RoleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RoleAggregateArgs>(
      args: Subset<T, RoleAggregateArgs>
    ): Prisma.PrismaPromise<GetRoleAggregateType<T>>;

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs["orderBy"] }
        : { orderBy?: RoleGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Role model
     */
    readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    userRoles<T extends Role$userRolesArgs<ExtArgs> = {}>(
      args?: Subset<T, Role$userRolesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", "Int">;
    readonly name: FieldRef<"Role", "String">;
  }

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>;
  };

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>;
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>;
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput;
    /**
     * Limit how many Roles to update.
     */
    limit?: number;
  };

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>;
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput;
    /**
     * Limit how many Roles to update.
     */
    limit?: number;
  };

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput;
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>;
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>;
  };

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput;
    /**
     * Limit how many Roles to delete.
     */
    limit?: number;
  };

  /**
   * Role.userRoles
   */
  export type Role$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    where?: UserRoleWhereInput;
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[];
    cursor?: UserRoleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[];
  };

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
  };

  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null;
    _avg: UserRoleAvgAggregateOutputType | null;
    _sum: UserRoleSumAggregateOutputType | null;
    _min: UserRoleMinAggregateOutputType | null;
    _max: UserRoleMaxAggregateOutputType | null;
  };

  export type UserRoleAvgAggregateOutputType = {
    id: number | null;
    userId: number | null;
    roleId: number | null;
  };

  export type UserRoleSumAggregateOutputType = {
    id: number | null;
    userId: number | null;
    roleId: number | null;
  };

  export type UserRoleMinAggregateOutputType = {
    id: number | null;
    userId: number | null;
    roleId: number | null;
  };

  export type UserRoleMaxAggregateOutputType = {
    id: number | null;
    userId: number | null;
    roleId: number | null;
  };

  export type UserRoleCountAggregateOutputType = {
    id: number;
    userId: number;
    roleId: number;
    _all: number;
  };

  export type UserRoleAvgAggregateInputType = {
    id?: true;
    userId?: true;
    roleId?: true;
  };

  export type UserRoleSumAggregateInputType = {
    id?: true;
    userId?: true;
    roleId?: true;
  };

  export type UserRoleMinAggregateInputType = {
    id?: true;
    userId?: true;
    roleId?: true;
  };

  export type UserRoleMaxAggregateInputType = {
    id?: true;
    userId?: true;
    roleId?: true;
  };

  export type UserRoleCountAggregateInputType = {
    id?: true;
    userId?: true;
    roleId?: true;
    _all?: true;
  };

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserRoles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserRoles
     **/
    _count?: true | UserRoleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UserRoleAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UserRoleSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserRoleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserRoleMaxAggregateInputType;
  };

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
    [P in keyof T & keyof AggregateUserRole]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>;
  };

  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput;
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[];
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum;
    having?: UserRoleScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserRoleCountAggregateInputType | true;
    _avg?: UserRoleAvgAggregateInputType;
    _sum?: UserRoleSumAggregateInputType;
    _min?: UserRoleMinAggregateInputType;
    _max?: UserRoleMaxAggregateInputType;
  };

  export type UserRoleGroupByOutputType = {
    id: number;
    userId: number;
    roleId: number;
    _count: UserRoleCountAggregateOutputType | null;
    _avg: UserRoleAvgAggregateOutputType | null;
    _sum: UserRoleSumAggregateOutputType | null;
    _min: UserRoleMinAggregateOutputType | null;
    _max: UserRoleMaxAggregateOutputType | null;
  };

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof UserRoleGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
          : GetScalarType<T[P], UserRoleGroupByOutputType[P]>;
      }
    >
  >;

  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        roleId?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
        role?: boolean | RoleDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["userRole"]
    >;

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        roleId?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
        role?: boolean | RoleDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["userRole"]
    >;

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        roleId?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
        role?: boolean | RoleDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["userRole"]
    >;

  export type UserRoleSelectScalar = {
    id?: boolean;
    userId?: boolean;
    roleId?: boolean;
  };

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    "id" | "userId" | "roleId",
    ExtArgs["result"]["userRole"]
  >;
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    role?: boolean | RoleDefaultArgs<ExtArgs>;
  };
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    role?: boolean | RoleDefaultArgs<ExtArgs>;
  };
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    role?: boolean | RoleDefaultArgs<ExtArgs>;
  };

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      role: Prisma.$RolePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        userId: number;
        roleId: number;
      },
      ExtArgs["result"]["userRole"]
    >;
    composites: {};
  };

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<
    Prisma.$UserRolePayload,
    S
  >;

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    UserRoleFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: UserRoleCountAggregateInputType | true;
  };

  export interface UserRoleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["UserRole"];
      meta: { name: "UserRole" };
    };
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(
      args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>
    ): Prisma__UserRoleClient<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserRoleClient<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(
      args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>
    ): Prisma__UserRoleClient<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserRoleClient<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     *
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserRoleFindManyArgs>(
      args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     *
     */
    create<T extends UserRoleCreateArgs>(
      args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>
    ): Prisma__UserRoleClient<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserRoleCreateManyArgs>(
      args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     *
     */
    delete<T extends UserRoleDeleteArgs>(
      args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>
    ): Prisma__UserRoleClient<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserRoleUpdateArgs>(
      args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>
    ): Prisma__UserRoleClient<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(
      args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserRoleUpdateManyArgs>(
      args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(
      args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>
    ): Prisma__UserRoleClient<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
     **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserRoleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserRoleAggregateArgs>(
      args: Subset<T, UserRoleAggregateArgs>
    ): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>;

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs["orderBy"] }
        : { orderBy?: UserRoleGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserRole model
     */
    readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, RoleDefaultArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", "Int">;
    readonly userId: FieldRef<"UserRole", "Int">;
    readonly roleId: FieldRef<"UserRole", "Int">;
  }

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput;
  };

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput;
  };

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserRoles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[];
  };

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserRoles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[];
  };

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserRoles.
     */
    skip?: number;
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[];
  };

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>;
  };

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null;
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>;
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput;
  };

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>;
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput;
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number;
  };

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null;
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>;
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput;
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput;
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>;
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>;
  };

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput;
  };

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput;
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number;
  };

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
  };

  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null;
    _avg: ProductAvgAggregateOutputType | null;
    _sum: ProductSumAggregateOutputType | null;
    _min: ProductMinAggregateOutputType | null;
    _max: ProductMaxAggregateOutputType | null;
  };

  export type ProductAvgAggregateOutputType = {
    id: number | null;
  };

  export type ProductSumAggregateOutputType = {
    id: number | null;
  };

  export type ProductMinAggregateOutputType = {
    id: number | null;
    title: string | null;
    slug: string | null;
    shortDescription: string | null;
    description: string | null;
    status: $Enums.ProductStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ProductMaxAggregateOutputType = {
    id: number | null;
    title: string | null;
    slug: string | null;
    shortDescription: string | null;
    description: string | null;
    status: $Enums.ProductStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ProductCountAggregateOutputType = {
    id: number;
    title: number;
    slug: number;
    shortDescription: number;
    description: number;
    status: number;
    metadata: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ProductAvgAggregateInputType = {
    id?: true;
  };

  export type ProductSumAggregateInputType = {
    id?: true;
  };

  export type ProductMinAggregateInputType = {
    id?: true;
    title?: true;
    slug?: true;
    shortDescription?: true;
    description?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ProductMaxAggregateInputType = {
    id?: true;
    title?: true;
    slug?: true;
    shortDescription?: true;
    description?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ProductCountAggregateInputType = {
    id?: true;
    title?: true;
    slug?: true;
    shortDescription?: true;
    description?: true;
    status?: true;
    metadata?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Products from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Products.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Products
     **/
    _count?: true | ProductCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ProductAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ProductSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ProductMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ProductMaxAggregateInputType;
  };

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
    [P in keyof T & keyof AggregateProduct]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>;
  };

  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[];
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum;
    having?: ProductScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ProductCountAggregateInputType | true;
    _avg?: ProductAvgAggregateInputType;
    _sum?: ProductSumAggregateInputType;
    _min?: ProductMinAggregateInputType;
    _max?: ProductMaxAggregateInputType;
  };

  export type ProductGroupByOutputType = {
    id: number;
    title: string;
    slug: string;
    shortDescription: string | null;
    description: string | null;
    status: $Enums.ProductStatus;
    metadata: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    _count: ProductCountAggregateOutputType | null;
    _avg: ProductAvgAggregateOutputType | null;
    _sum: ProductSumAggregateOutputType | null;
    _min: ProductMinAggregateOutputType | null;
    _max: ProductMaxAggregateOutputType | null;
  };

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof ProductGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
          : GetScalarType<T[P], ProductGroupByOutputType[P]>;
      }
    >
  >;

  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      slug?: boolean;
      shortDescription?: boolean;
      description?: boolean;
      status?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      images?: boolean | Product$imagesArgs<ExtArgs>;
      variants?: boolean | Product$variantsArgs<ExtArgs>;
      reviews?: boolean | Product$reviewsArgs<ExtArgs>;
      OrderItem?: boolean | Product$OrderItemArgs<ExtArgs>;
      WishlistItem?: boolean | Product$WishlistItemArgs<ExtArgs>;
      _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["product"]
  >;

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        title?: boolean;
        slug?: boolean;
        shortDescription?: boolean;
        description?: boolean;
        status?: boolean;
        metadata?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
      },
      ExtArgs["result"]["product"]
    >;

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        title?: boolean;
        slug?: boolean;
        shortDescription?: boolean;
        description?: boolean;
        status?: boolean;
        metadata?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
      },
      ExtArgs["result"]["product"]
    >;

  export type ProductSelectScalar = {
    id?: boolean;
    title?: boolean;
    slug?: boolean;
    shortDescription?: boolean;
    description?: boolean;
    status?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    "id" | "title" | "slug" | "shortDescription" | "description" | "status" | "metadata" | "createdAt" | "updatedAt",
    ExtArgs["result"]["product"]
  >;
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | Product$imagesArgs<ExtArgs>;
    variants?: boolean | Product$variantsArgs<ExtArgs>;
    reviews?: boolean | Product$reviewsArgs<ExtArgs>;
    OrderItem?: boolean | Product$OrderItemArgs<ExtArgs>;
    WishlistItem?: boolean | Product$WishlistItemArgs<ExtArgs>;
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {};
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {};

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product";
    objects: {
      images: Prisma.$ProductImagePayload<ExtArgs>[];
      variants: Prisma.$ProductVariantPayload<ExtArgs>[];
      reviews: Prisma.$ReviewPayload<ExtArgs>[];
      OrderItem: Prisma.$OrderItemPayload<ExtArgs>[];
      WishlistItem: Prisma.$WishlistItemPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        title: string;
        slug: string;
        shortDescription: string | null;
        description: string | null;
        status: $Enums.ProductStatus;
        metadata: Prisma.JsonValue | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["product"]
    >;
    composites: {};
  };

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<
    Prisma.$ProductPayload,
    S
  >;

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ProductFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ProductCountAggregateInputType | true;
  };

  export interface ProductDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["Product"]; meta: { name: "Product" } };
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(
      args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(
      args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     *
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     *
     */
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     *
     */
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
     **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ProductCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ProductAggregateArgs>(
      args: Subset<T, ProductAggregateArgs>
    ): Prisma.PrismaPromise<GetProductAggregateType<T>>;

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs["orderBy"] }
        : { orderBy?: ProductGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Product model
     */
    readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    images<T extends Product$imagesArgs<ExtArgs> = {}>(
      args?: Subset<T, Product$imagesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    variants<T extends Product$variantsArgs<ExtArgs> = {}>(
      args?: Subset<T, Product$variantsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    reviews<T extends Product$reviewsArgs<ExtArgs> = {}>(
      args?: Subset<T, Product$reviewsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    OrderItem<T extends Product$OrderItemArgs<ExtArgs> = {}>(
      args?: Subset<T, Product$OrderItemArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    WishlistItem<T extends Product$WishlistItemArgs<ExtArgs> = {}>(
      args?: Subset<T, Product$WishlistItemArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", "Int">;
    readonly title: FieldRef<"Product", "String">;
    readonly slug: FieldRef<"Product", "String">;
    readonly shortDescription: FieldRef<"Product", "String">;
    readonly description: FieldRef<"Product", "String">;
    readonly status: FieldRef<"Product", "ProductStatus">;
    readonly metadata: FieldRef<"Product", "Json">;
    readonly createdAt: FieldRef<"Product", "DateTime">;
    readonly updatedAt: FieldRef<"Product", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput;
  };

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput;
  };

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Products from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Products.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[];
  };

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Products from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Products.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[];
  };

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Products from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Products.
     */
    skip?: number;
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[];
  };

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>;
  };

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null;
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>;
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput;
  };

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>;
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput;
    /**
     * Limit how many Products to update.
     */
    limit?: number;
  };

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null;
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>;
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput;
    /**
     * Limit how many Products to update.
     */
    limit?: number;
  };

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput;
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>;
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>;
  };

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput;
  };

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput;
    /**
     * Limit how many Products to delete.
     */
    limit?: number;
  };

  /**
   * Product.images
   */
  export type Product$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null;
    where?: ProductImageWhereInput;
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[];
    cursor?: ProductImageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[];
  };

  /**
   * Product.variants
   */
  export type Product$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null;
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[];
    cursor?: ProductVariantWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[];
  };

  /**
   * Product.reviews
   */
  export type Product$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    cursor?: ReviewWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Product.OrderItem
   */
  export type Product$OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[];
    cursor?: OrderItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[];
  };

  /**
   * Product.WishlistItem
   */
  export type Product$WishlistItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null;
    where?: WishlistItemWhereInput;
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[];
    cursor?: WishlistItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[];
  };

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
  };

  /**
   * Model ProductImage
   */

  export type AggregateProductImage = {
    _count: ProductImageCountAggregateOutputType | null;
    _avg: ProductImageAvgAggregateOutputType | null;
    _sum: ProductImageSumAggregateOutputType | null;
    _min: ProductImageMinAggregateOutputType | null;
    _max: ProductImageMaxAggregateOutputType | null;
  };

  export type ProductImageAvgAggregateOutputType = {
    id: number | null;
    productId: number | null;
  };

  export type ProductImageSumAggregateOutputType = {
    id: number | null;
    productId: number | null;
  };

  export type ProductImageMinAggregateOutputType = {
    id: number | null;
    url: string | null;
    alt: string | null;
    isPrimary: boolean | null;
    productId: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ProductImageMaxAggregateOutputType = {
    id: number | null;
    url: string | null;
    alt: string | null;
    isPrimary: boolean | null;
    productId: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ProductImageCountAggregateOutputType = {
    id: number;
    url: number;
    alt: number;
    isPrimary: number;
    productId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ProductImageAvgAggregateInputType = {
    id?: true;
    productId?: true;
  };

  export type ProductImageSumAggregateInputType = {
    id?: true;
    productId?: true;
  };

  export type ProductImageMinAggregateInputType = {
    id?: true;
    url?: true;
    alt?: true;
    isPrimary?: true;
    productId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ProductImageMaxAggregateInputType = {
    id?: true;
    url?: true;
    alt?: true;
    isPrimary?: true;
    productId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ProductImageCountAggregateInputType = {
    id?: true;
    url?: true;
    alt?: true;
    isPrimary?: true;
    productId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ProductImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImage to aggregate.
     */
    where?: ProductImageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ProductImageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductImages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ProductImages
     **/
    _count?: true | ProductImageCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ProductImageAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ProductImageSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ProductImageMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ProductImageMaxAggregateInputType;
  };

  export type GetProductImageAggregateType<T extends ProductImageAggregateArgs> = {
    [P in keyof T & keyof AggregateProductImage]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductImage[P]>
      : GetScalarType<T[P], AggregateProductImage[P]>;
  };

  export type ProductImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput;
    orderBy?: ProductImageOrderByWithAggregationInput | ProductImageOrderByWithAggregationInput[];
    by: ProductImageScalarFieldEnum[] | ProductImageScalarFieldEnum;
    having?: ProductImageScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ProductImageCountAggregateInputType | true;
    _avg?: ProductImageAvgAggregateInputType;
    _sum?: ProductImageSumAggregateInputType;
    _min?: ProductImageMinAggregateInputType;
    _max?: ProductImageMaxAggregateInputType;
  };

  export type ProductImageGroupByOutputType = {
    id: number;
    url: string;
    alt: string | null;
    isPrimary: boolean;
    productId: number;
    createdAt: Date;
    updatedAt: Date;
    _count: ProductImageCountAggregateOutputType | null;
    _avg: ProductImageAvgAggregateOutputType | null;
    _sum: ProductImageSumAggregateOutputType | null;
    _min: ProductImageMinAggregateOutputType | null;
    _max: ProductImageMaxAggregateOutputType | null;
  };

  type GetProductImageGroupByPayload<T extends ProductImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductImageGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof ProductImageGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
          : GetScalarType<T[P], ProductImageGroupByOutputType[P]>;
      }
    >
  >;

  export type ProductImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        url?: boolean;
        alt?: boolean;
        isPrimary?: boolean;
        productId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        product?: boolean | ProductDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["productImage"]
    >;

  export type ProductImageSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      url?: boolean;
      alt?: boolean;
      isPrimary?: boolean;
      productId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      product?: boolean | ProductDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["productImage"]
  >;

  export type ProductImageSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      url?: boolean;
      alt?: boolean;
      isPrimary?: boolean;
      productId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      product?: boolean | ProductDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["productImage"]
  >;

  export type ProductImageSelectScalar = {
    id?: boolean;
    url?: boolean;
    alt?: boolean;
    isPrimary?: boolean;
    productId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ProductImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      "id" | "url" | "alt" | "isPrimary" | "productId" | "createdAt" | "updatedAt",
      ExtArgs["result"]["productImage"]
    >;
  export type ProductImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>;
  };
  export type ProductImageIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    product?: boolean | ProductDefaultArgs<ExtArgs>;
  };
  export type ProductImageIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    product?: boolean | ProductDefaultArgs<ExtArgs>;
  };

  export type $ProductImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductImage";
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        url: string;
        alt: string | null;
        isPrimary: boolean;
        productId: number;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["productImage"]
    >;
    composites: {};
  };

  type ProductImageGetPayload<S extends boolean | null | undefined | ProductImageDefaultArgs> = $Result.GetResult<
    Prisma.$ProductImagePayload,
    S
  >;

  type ProductImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ProductImageFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ProductImageCountAggregateInputType | true;
  };

  export interface ProductImageDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["ProductImage"];
      meta: { name: "ProductImage" };
    };
    /**
     * Find zero or one ProductImage that matches the filter.
     * @param {ProductImageFindUniqueArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductImageFindUniqueArgs>(
      args: SelectSubset<T, ProductImageFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductImageClient<
      $Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ProductImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductImageFindUniqueOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductImageFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ProductImageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductImageClient<
      $Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ProductImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductImageFindFirstArgs>(
      args?: SelectSubset<T, ProductImageFindFirstArgs<ExtArgs>>
    ): Prisma__ProductImageClient<
      $Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ProductImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductImageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductImageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductImageClient<
      $Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductImages
     * const productImages = await prisma.productImage.findMany()
     *
     * // Get first 10 ProductImages
     * const productImages = await prisma.productImage.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const productImageWithIdOnly = await prisma.productImage.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ProductImageFindManyArgs>(
      args?: SelectSubset<T, ProductImageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a ProductImage.
     * @param {ProductImageCreateArgs} args - Arguments to create a ProductImage.
     * @example
     * // Create one ProductImage
     * const ProductImage = await prisma.productImage.create({
     *   data: {
     *     // ... data to create a ProductImage
     *   }
     * })
     *
     */
    create<T extends ProductImageCreateArgs>(
      args: SelectSubset<T, ProductImageCreateArgs<ExtArgs>>
    ): Prisma__ProductImageClient<
      $Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ProductImages.
     * @param {ProductImageCreateManyArgs} args - Arguments to create many ProductImages.
     * @example
     * // Create many ProductImages
     * const productImage = await prisma.productImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ProductImageCreateManyArgs>(
      args?: SelectSubset<T, ProductImageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ProductImages and returns the data saved in the database.
     * @param {ProductImageCreateManyAndReturnArgs} args - Arguments to create many ProductImages.
     * @example
     * // Create many ProductImages
     * const productImage = await prisma.productImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ProductImages and only return the `id`
     * const productImageWithIdOnly = await prisma.productImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ProductImageCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ProductImageCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a ProductImage.
     * @param {ProductImageDeleteArgs} args - Arguments to delete one ProductImage.
     * @example
     * // Delete one ProductImage
     * const ProductImage = await prisma.productImage.delete({
     *   where: {
     *     // ... filter to delete one ProductImage
     *   }
     * })
     *
     */
    delete<T extends ProductImageDeleteArgs>(
      args: SelectSubset<T, ProductImageDeleteArgs<ExtArgs>>
    ): Prisma__ProductImageClient<
      $Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ProductImage.
     * @param {ProductImageUpdateArgs} args - Arguments to update one ProductImage.
     * @example
     * // Update one ProductImage
     * const productImage = await prisma.productImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ProductImageUpdateArgs>(
      args: SelectSubset<T, ProductImageUpdateArgs<ExtArgs>>
    ): Prisma__ProductImageClient<
      $Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ProductImages.
     * @param {ProductImageDeleteManyArgs} args - Arguments to filter ProductImages to delete.
     * @example
     * // Delete a few ProductImages
     * const { count } = await prisma.productImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ProductImageDeleteManyArgs>(
      args?: SelectSubset<T, ProductImageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ProductImageUpdateManyArgs>(
      args: SelectSubset<T, ProductImageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ProductImages and returns the data updated in the database.
     * @param {ProductImageUpdateManyAndReturnArgs} args - Arguments to update many ProductImages.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ProductImages and only return the `id`
     * const productImageWithIdOnly = await prisma.productImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ProductImageUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ProductImageUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one ProductImage.
     * @param {ProductImageUpsertArgs} args - Arguments to update or create a ProductImage.
     * @example
     * // Update or create a ProductImage
     * const productImage = await prisma.productImage.upsert({
     *   create: {
     *     // ... data to create a ProductImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductImage we want to update
     *   }
     * })
     */
    upsert<T extends ProductImageUpsertArgs>(
      args: SelectSubset<T, ProductImageUpsertArgs<ExtArgs>>
    ): Prisma__ProductImageClient<
      $Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageCountArgs} args - Arguments to filter ProductImages to count.
     * @example
     * // Count the number of ProductImages
     * const count = await prisma.productImage.count({
     *   where: {
     *     // ... the filter for the ProductImages we want to count
     *   }
     * })
     **/
    count<T extends ProductImageCountArgs>(
      args?: Subset<T, ProductImageCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ProductImageCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ProductImageAggregateArgs>(
      args: Subset<T, ProductImageAggregateArgs>
    ): Prisma.PrismaPromise<GetProductImageAggregateType<T>>;

    /**
     * Group by ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ProductImageGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductImageGroupByArgs["orderBy"] }
        : { orderBy?: ProductImageGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ProductImageGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetProductImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ProductImage model
     */
    readonly fields: ProductImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductImageClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ProductDefaultArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ProductImage model
   */
  interface ProductImageFieldRefs {
    readonly id: FieldRef<"ProductImage", "Int">;
    readonly url: FieldRef<"ProductImage", "String">;
    readonly alt: FieldRef<"ProductImage", "String">;
    readonly isPrimary: FieldRef<"ProductImage", "Boolean">;
    readonly productId: FieldRef<"ProductImage", "Int">;
    readonly createdAt: FieldRef<"ProductImage", "DateTime">;
    readonly updatedAt: FieldRef<"ProductImage", "DateTime">;
  }

  // Custom InputTypes
  /**
   * ProductImage findUnique
   */
  export type ProductImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null;
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput;
  };

  /**
   * ProductImage findUniqueOrThrow
   */
  export type ProductImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null;
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput;
  };

  /**
   * ProductImage findFirst
   */
  export type ProductImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null;
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductImages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[];
  };

  /**
   * ProductImage findFirstOrThrow
   */
  export type ProductImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null;
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductImages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[];
  };

  /**
   * ProductImage findMany
   */
  export type ProductImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null;
    /**
     * Filter, which ProductImages to fetch.
     */
    where?: ProductImageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductImages.
     */
    skip?: number;
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[];
  };

  /**
   * ProductImage create
   */
  export type ProductImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null;
    /**
     * The data needed to create a ProductImage.
     */
    data: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>;
  };

  /**
   * ProductImage createMany
   */
  export type ProductImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductImages.
     */
    data: ProductImageCreateManyInput | ProductImageCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ProductImage createManyAndReturn
   */
  export type ProductImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the ProductImage
       */
      select?: ProductImageSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the ProductImage
       */
      omit?: ProductImageOmit<ExtArgs> | null;
      /**
       * The data used to create many ProductImages.
       */
      data: ProductImageCreateManyInput | ProductImageCreateManyInput[];
      skipDuplicates?: boolean;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProductImageIncludeCreateManyAndReturn<ExtArgs> | null;
    };

  /**
   * ProductImage update
   */
  export type ProductImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null;
    /**
     * The data needed to update a ProductImage.
     */
    data: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>;
    /**
     * Choose, which ProductImage to update.
     */
    where: ProductImageWhereUniqueInput;
  };

  /**
   * ProductImage updateMany
   */
  export type ProductImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>;
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImageWhereInput;
    /**
     * Limit how many ProductImages to update.
     */
    limit?: number;
  };

  /**
   * ProductImage updateManyAndReturn
   */
  export type ProductImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the ProductImage
       */
      select?: ProductImageSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the ProductImage
       */
      omit?: ProductImageOmit<ExtArgs> | null;
      /**
       * The data used to update ProductImages.
       */
      data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>;
      /**
       * Filter which ProductImages to update
       */
      where?: ProductImageWhereInput;
      /**
       * Limit how many ProductImages to update.
       */
      limit?: number;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProductImageIncludeUpdateManyAndReturn<ExtArgs> | null;
    };

  /**
   * ProductImage upsert
   */
  export type ProductImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null;
    /**
     * The filter to search for the ProductImage to update in case it exists.
     */
    where: ProductImageWhereUniqueInput;
    /**
     * In case the ProductImage found by the `where` argument doesn't exist, create a new ProductImage with this data.
     */
    create: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>;
    /**
     * In case the ProductImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>;
  };

  /**
   * ProductImage delete
   */
  export type ProductImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null;
    /**
     * Filter which ProductImage to delete.
     */
    where: ProductImageWhereUniqueInput;
  };

  /**
   * ProductImage deleteMany
   */
  export type ProductImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImages to delete
     */
    where?: ProductImageWhereInput;
    /**
     * Limit how many ProductImages to delete.
     */
    limit?: number;
  };

  /**
   * ProductImage without action
   */
  export type ProductImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null;
  };

  /**
   * Model ProductVariant
   */

  export type AggregateProductVariant = {
    _count: ProductVariantCountAggregateOutputType | null;
    _avg: ProductVariantAvgAggregateOutputType | null;
    _sum: ProductVariantSumAggregateOutputType | null;
    _min: ProductVariantMinAggregateOutputType | null;
    _max: ProductVariantMaxAggregateOutputType | null;
  };

  export type ProductVariantAvgAggregateOutputType = {
    id: number | null;
    productId: number | null;
    price: Decimal | null;
    compareAtPrice: Decimal | null;
  };

  export type ProductVariantSumAggregateOutputType = {
    id: number | null;
    productId: number | null;
    price: Decimal | null;
    compareAtPrice: Decimal | null;
  };

  export type ProductVariantMinAggregateOutputType = {
    id: number | null;
    productId: number | null;
    name: string | null;
    skuPrefix: string | null;
    price: Decimal | null;
    compareAtPrice: Decimal | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ProductVariantMaxAggregateOutputType = {
    id: number | null;
    productId: number | null;
    name: string | null;
    skuPrefix: string | null;
    price: Decimal | null;
    compareAtPrice: Decimal | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ProductVariantCountAggregateOutputType = {
    id: number;
    productId: number;
    name: number;
    skuPrefix: number;
    price: number;
    compareAtPrice: number;
    attributes: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ProductVariantAvgAggregateInputType = {
    id?: true;
    productId?: true;
    price?: true;
    compareAtPrice?: true;
  };

  export type ProductVariantSumAggregateInputType = {
    id?: true;
    productId?: true;
    price?: true;
    compareAtPrice?: true;
  };

  export type ProductVariantMinAggregateInputType = {
    id?: true;
    productId?: true;
    name?: true;
    skuPrefix?: true;
    price?: true;
    compareAtPrice?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ProductVariantMaxAggregateInputType = {
    id?: true;
    productId?: true;
    name?: true;
    skuPrefix?: true;
    price?: true;
    compareAtPrice?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ProductVariantCountAggregateInputType = {
    id?: true;
    productId?: true;
    name?: true;
    skuPrefix?: true;
    price?: true;
    compareAtPrice?: true;
    attributes?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ProductVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariant to aggregate.
     */
    where?: ProductVariantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ProductVariantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductVariants.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ProductVariants
     **/
    _count?: true | ProductVariantCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ProductVariantAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ProductVariantSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ProductVariantMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ProductVariantMaxAggregateInputType;
  };

  export type GetProductVariantAggregateType<T extends ProductVariantAggregateArgs> = {
    [P in keyof T & keyof AggregateProductVariant]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVariant[P]>
      : GetScalarType<T[P], AggregateProductVariant[P]>;
  };

  export type ProductVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByWithAggregationInput | ProductVariantOrderByWithAggregationInput[];
    by: ProductVariantScalarFieldEnum[] | ProductVariantScalarFieldEnum;
    having?: ProductVariantScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ProductVariantCountAggregateInputType | true;
    _avg?: ProductVariantAvgAggregateInputType;
    _sum?: ProductVariantSumAggregateInputType;
    _min?: ProductVariantMinAggregateInputType;
    _max?: ProductVariantMaxAggregateInputType;
  };

  export type ProductVariantGroupByOutputType = {
    id: number;
    productId: number;
    name: string;
    skuPrefix: string | null;
    price: Decimal;
    compareAtPrice: Decimal | null;
    attributes: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    _count: ProductVariantCountAggregateOutputType | null;
    _avg: ProductVariantAvgAggregateOutputType | null;
    _sum: ProductVariantSumAggregateOutputType | null;
    _min: ProductVariantMinAggregateOutputType | null;
    _max: ProductVariantMaxAggregateOutputType | null;
  };

  type GetProductVariantGroupByPayload<T extends ProductVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductVariantGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof ProductVariantGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
          : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>;
      }
    >
  >;

  export type ProductVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        productId?: boolean;
        name?: boolean;
        skuPrefix?: boolean;
        price?: boolean;
        compareAtPrice?: boolean;
        attributes?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        product?: boolean | ProductDefaultArgs<ExtArgs>;
        inventory?: boolean | ProductVariant$inventoryArgs<ExtArgs>;
        OrderItem?: boolean | ProductVariant$OrderItemArgs<ExtArgs>;
        _count?: boolean | ProductVariantCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["productVariant"]
    >;

  export type ProductVariantSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      productId?: boolean;
      name?: boolean;
      skuPrefix?: boolean;
      price?: boolean;
      compareAtPrice?: boolean;
      attributes?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      product?: boolean | ProductDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["productVariant"]
  >;

  export type ProductVariantSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      productId?: boolean;
      name?: boolean;
      skuPrefix?: boolean;
      price?: boolean;
      compareAtPrice?: boolean;
      attributes?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      product?: boolean | ProductDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["productVariant"]
  >;

  export type ProductVariantSelectScalar = {
    id?: boolean;
    productId?: boolean;
    name?: boolean;
    skuPrefix?: boolean;
    price?: boolean;
    compareAtPrice?: boolean;
    attributes?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ProductVariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      "id" | "productId" | "name" | "skuPrefix" | "price" | "compareAtPrice" | "attributes" | "createdAt" | "updatedAt",
      ExtArgs["result"]["productVariant"]
    >;
  export type ProductVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>;
    inventory?: boolean | ProductVariant$inventoryArgs<ExtArgs>;
    OrderItem?: boolean | ProductVariant$OrderItemArgs<ExtArgs>;
    _count?: boolean | ProductVariantCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ProductVariantIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    product?: boolean | ProductDefaultArgs<ExtArgs>;
  };
  export type ProductVariantIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    product?: boolean | ProductDefaultArgs<ExtArgs>;
  };

  export type $ProductVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductVariant";
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>;
      inventory: Prisma.$InventoryPayload<ExtArgs>[];
      OrderItem: Prisma.$OrderItemPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        productId: number;
        name: string;
        skuPrefix: string | null;
        price: Prisma.Decimal;
        compareAtPrice: Prisma.Decimal | null;
        attributes: Prisma.JsonValue | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["productVariant"]
    >;
    composites: {};
  };

  type ProductVariantGetPayload<S extends boolean | null | undefined | ProductVariantDefaultArgs> = $Result.GetResult<
    Prisma.$ProductVariantPayload,
    S
  >;

  type ProductVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ProductVariantFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ProductVariantCountAggregateInputType | true;
  };

  export interface ProductVariantDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["ProductVariant"];
      meta: { name: "ProductVariant" };
    };
    /**
     * Find zero or one ProductVariant that matches the filter.
     * @param {ProductVariantFindUniqueArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductVariantFindUniqueArgs>(
      args: SelectSubset<T, ProductVariantFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductVariantClient<
      $Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ProductVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductVariantFindUniqueOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductVariantFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ProductVariantFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductVariantClient<
      $Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ProductVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductVariantFindFirstArgs>(
      args?: SelectSubset<T, ProductVariantFindFirstArgs<ExtArgs>>
    ): Prisma__ProductVariantClient<
      $Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ProductVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductVariantFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductVariantFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductVariantClient<
      $Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ProductVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVariants
     * const productVariants = await prisma.productVariant.findMany()
     *
     * // Get first 10 ProductVariants
     * const productVariants = await prisma.productVariant.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ProductVariantFindManyArgs>(
      args?: SelectSubset<T, ProductVariantFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a ProductVariant.
     * @param {ProductVariantCreateArgs} args - Arguments to create a ProductVariant.
     * @example
     * // Create one ProductVariant
     * const ProductVariant = await prisma.productVariant.create({
     *   data: {
     *     // ... data to create a ProductVariant
     *   }
     * })
     *
     */
    create<T extends ProductVariantCreateArgs>(
      args: SelectSubset<T, ProductVariantCreateArgs<ExtArgs>>
    ): Prisma__ProductVariantClient<
      $Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ProductVariants.
     * @param {ProductVariantCreateManyArgs} args - Arguments to create many ProductVariants.
     * @example
     * // Create many ProductVariants
     * const productVariant = await prisma.productVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ProductVariantCreateManyArgs>(
      args?: SelectSubset<T, ProductVariantCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ProductVariants and returns the data saved in the database.
     * @param {ProductVariantCreateManyAndReturnArgs} args - Arguments to create many ProductVariants.
     * @example
     * // Create many ProductVariants
     * const productVariant = await prisma.productVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ProductVariants and only return the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ProductVariantCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ProductVariantCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a ProductVariant.
     * @param {ProductVariantDeleteArgs} args - Arguments to delete one ProductVariant.
     * @example
     * // Delete one ProductVariant
     * const ProductVariant = await prisma.productVariant.delete({
     *   where: {
     *     // ... filter to delete one ProductVariant
     *   }
     * })
     *
     */
    delete<T extends ProductVariantDeleteArgs>(
      args: SelectSubset<T, ProductVariantDeleteArgs<ExtArgs>>
    ): Prisma__ProductVariantClient<
      $Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ProductVariant.
     * @param {ProductVariantUpdateArgs} args - Arguments to update one ProductVariant.
     * @example
     * // Update one ProductVariant
     * const productVariant = await prisma.productVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ProductVariantUpdateArgs>(
      args: SelectSubset<T, ProductVariantUpdateArgs<ExtArgs>>
    ): Prisma__ProductVariantClient<
      $Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ProductVariants.
     * @param {ProductVariantDeleteManyArgs} args - Arguments to filter ProductVariants to delete.
     * @example
     * // Delete a few ProductVariants
     * const { count } = await prisma.productVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ProductVariantDeleteManyArgs>(
      args?: SelectSubset<T, ProductVariantDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVariants
     * const productVariant = await prisma.productVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ProductVariantUpdateManyArgs>(
      args: SelectSubset<T, ProductVariantUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ProductVariants and returns the data updated in the database.
     * @param {ProductVariantUpdateManyAndReturnArgs} args - Arguments to update many ProductVariants.
     * @example
     * // Update many ProductVariants
     * const productVariant = await prisma.productVariant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ProductVariants and only return the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ProductVariantUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ProductVariantUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one ProductVariant.
     * @param {ProductVariantUpsertArgs} args - Arguments to update or create a ProductVariant.
     * @example
     * // Update or create a ProductVariant
     * const productVariant = await prisma.productVariant.upsert({
     *   create: {
     *     // ... data to create a ProductVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVariant we want to update
     *   }
     * })
     */
    upsert<T extends ProductVariantUpsertArgs>(
      args: SelectSubset<T, ProductVariantUpsertArgs<ExtArgs>>
    ): Prisma__ProductVariantClient<
      $Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantCountArgs} args - Arguments to filter ProductVariants to count.
     * @example
     * // Count the number of ProductVariants
     * const count = await prisma.productVariant.count({
     *   where: {
     *     // ... the filter for the ProductVariants we want to count
     *   }
     * })
     **/
    count<T extends ProductVariantCountArgs>(
      args?: Subset<T, ProductVariantCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ProductVariantCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ProductVariantAggregateArgs>(
      args: Subset<T, ProductVariantAggregateArgs>
    ): Prisma.PrismaPromise<GetProductVariantAggregateType<T>>;

    /**
     * Group by ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ProductVariantGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVariantGroupByArgs["orderBy"] }
        : { orderBy?: ProductVariantGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ProductVariantGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetProductVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ProductVariant model
     */
    readonly fields: ProductVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductVariantClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ProductDefaultArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    inventory<T extends ProductVariant$inventoryArgs<ExtArgs> = {}>(
      args?: Subset<T, ProductVariant$inventoryArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    OrderItem<T extends ProductVariant$OrderItemArgs<ExtArgs> = {}>(
      args?: Subset<T, ProductVariant$OrderItemArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ProductVariant model
   */
  interface ProductVariantFieldRefs {
    readonly id: FieldRef<"ProductVariant", "Int">;
    readonly productId: FieldRef<"ProductVariant", "Int">;
    readonly name: FieldRef<"ProductVariant", "String">;
    readonly skuPrefix: FieldRef<"ProductVariant", "String">;
    readonly price: FieldRef<"ProductVariant", "Decimal">;
    readonly compareAtPrice: FieldRef<"ProductVariant", "Decimal">;
    readonly attributes: FieldRef<"ProductVariant", "Json">;
    readonly createdAt: FieldRef<"ProductVariant", "DateTime">;
    readonly updatedAt: FieldRef<"ProductVariant", "DateTime">;
  }

  // Custom InputTypes
  /**
   * ProductVariant findUnique
   */
  export type ProductVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null;
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput;
  };

  /**
   * ProductVariant findUniqueOrThrow
   */
  export type ProductVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the ProductVariant
       */
      select?: ProductVariantSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the ProductVariant
       */
      omit?: ProductVariantOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProductVariantInclude<ExtArgs> | null;
      /**
       * Filter, which ProductVariant to fetch.
       */
      where: ProductVariantWhereUniqueInput;
    };

  /**
   * ProductVariant findFirst
   */
  export type ProductVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null;
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductVariants.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[];
  };

  /**
   * ProductVariant findFirstOrThrow
   */
  export type ProductVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null;
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductVariants.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[];
  };

  /**
   * ProductVariant findMany
   */
  export type ProductVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null;
    /**
     * Filter, which ProductVariants to fetch.
     */
    where?: ProductVariantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductVariants.
     */
    skip?: number;
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[];
  };

  /**
   * ProductVariant create
   */
  export type ProductVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null;
    /**
     * The data needed to create a ProductVariant.
     */
    data: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>;
  };

  /**
   * ProductVariant createMany
   */
  export type ProductVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductVariants.
     */
    data: ProductVariantCreateManyInput | ProductVariantCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ProductVariant createManyAndReturn
   */
  export type ProductVariantCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null;
    /**
     * The data used to create many ProductVariants.
     */
    data: ProductVariantCreateManyInput | ProductVariantCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ProductVariant update
   */
  export type ProductVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null;
    /**
     * The data needed to update a ProductVariant.
     */
    data: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>;
    /**
     * Choose, which ProductVariant to update.
     */
    where: ProductVariantWhereUniqueInput;
  };

  /**
   * ProductVariant updateMany
   */
  export type ProductVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductVariants.
     */
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyInput>;
    /**
     * Filter which ProductVariants to update
     */
    where?: ProductVariantWhereInput;
    /**
     * Limit how many ProductVariants to update.
     */
    limit?: number;
  };

  /**
   * ProductVariant updateManyAndReturn
   */
  export type ProductVariantUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null;
    /**
     * The data used to update ProductVariants.
     */
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyInput>;
    /**
     * Filter which ProductVariants to update
     */
    where?: ProductVariantWhereInput;
    /**
     * Limit how many ProductVariants to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ProductVariant upsert
   */
  export type ProductVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null;
    /**
     * The filter to search for the ProductVariant to update in case it exists.
     */
    where: ProductVariantWhereUniqueInput;
    /**
     * In case the ProductVariant found by the `where` argument doesn't exist, create a new ProductVariant with this data.
     */
    create: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>;
    /**
     * In case the ProductVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>;
  };

  /**
   * ProductVariant delete
   */
  export type ProductVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null;
    /**
     * Filter which ProductVariant to delete.
     */
    where: ProductVariantWhereUniqueInput;
  };

  /**
   * ProductVariant deleteMany
   */
  export type ProductVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariants to delete
     */
    where?: ProductVariantWhereInput;
    /**
     * Limit how many ProductVariants to delete.
     */
    limit?: number;
  };

  /**
   * ProductVariant.inventory
   */
  export type ProductVariant$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null;
    where?: InventoryWhereInput;
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[];
    cursor?: InventoryWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[];
  };

  /**
   * ProductVariant.OrderItem
   */
  export type ProductVariant$OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[];
    cursor?: OrderItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[];
  };

  /**
   * ProductVariant without action
   */
  export type ProductVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null;
  };

  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null;
    _avg: InventoryAvgAggregateOutputType | null;
    _sum: InventorySumAggregateOutputType | null;
    _min: InventoryMinAggregateOutputType | null;
    _max: InventoryMaxAggregateOutputType | null;
  };

  export type InventoryAvgAggregateOutputType = {
    id: number | null;
    variantId: number | null;
    quantity: number | null;
    reserved: number | null;
  };

  export type InventorySumAggregateOutputType = {
    id: number | null;
    variantId: number | null;
    quantity: number | null;
    reserved: number | null;
  };

  export type InventoryMinAggregateOutputType = {
    id: number | null;
    sku: string | null;
    variantId: number | null;
    quantity: number | null;
    reserved: number | null;
    location: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type InventoryMaxAggregateOutputType = {
    id: number | null;
    sku: string | null;
    variantId: number | null;
    quantity: number | null;
    reserved: number | null;
    location: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type InventoryCountAggregateOutputType = {
    id: number;
    sku: number;
    variantId: number;
    quantity: number;
    reserved: number;
    location: number;
    metadata: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type InventoryAvgAggregateInputType = {
    id?: true;
    variantId?: true;
    quantity?: true;
    reserved?: true;
  };

  export type InventorySumAggregateInputType = {
    id?: true;
    variantId?: true;
    quantity?: true;
    reserved?: true;
  };

  export type InventoryMinAggregateInputType = {
    id?: true;
    sku?: true;
    variantId?: true;
    quantity?: true;
    reserved?: true;
    location?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type InventoryMaxAggregateInputType = {
    id?: true;
    sku?: true;
    variantId?: true;
    quantity?: true;
    reserved?: true;
    location?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type InventoryCountAggregateInputType = {
    id?: true;
    sku?: true;
    variantId?: true;
    quantity?: true;
    reserved?: true;
    location?: true;
    metadata?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Inventories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Inventories
     **/
    _count?: true | InventoryCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: InventoryAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: InventorySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: InventoryMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: InventoryMaxAggregateInputType;
  };

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
    [P in keyof T & keyof AggregateInventory]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>;
  };

  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput;
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[];
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum;
    having?: InventoryScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: InventoryCountAggregateInputType | true;
    _avg?: InventoryAvgAggregateInputType;
    _sum?: InventorySumAggregateInputType;
    _min?: InventoryMinAggregateInputType;
    _max?: InventoryMaxAggregateInputType;
  };

  export type InventoryGroupByOutputType = {
    id: number;
    sku: string;
    variantId: number;
    quantity: number;
    reserved: number;
    location: string | null;
    metadata: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    _count: InventoryCountAggregateOutputType | null;
    _avg: InventoryAvgAggregateOutputType | null;
    _sum: InventorySumAggregateOutputType | null;
    _min: InventoryMinAggregateOutputType | null;
    _max: InventoryMaxAggregateOutputType | null;
  };

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof InventoryGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
          : GetScalarType<T[P], InventoryGroupByOutputType[P]>;
      }
    >
  >;

  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        sku?: boolean;
        variantId?: boolean;
        quantity?: boolean;
        reserved?: boolean;
        location?: boolean;
        metadata?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        variant?: boolean | ProductVariantDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["inventory"]
    >;

  export type InventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        sku?: boolean;
        variantId?: boolean;
        quantity?: boolean;
        reserved?: boolean;
        location?: boolean;
        metadata?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        variant?: boolean | ProductVariantDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["inventory"]
    >;

  export type InventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        sku?: boolean;
        variantId?: boolean;
        quantity?: boolean;
        reserved?: boolean;
        location?: boolean;
        metadata?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        variant?: boolean | ProductVariantDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["inventory"]
    >;

  export type InventorySelectScalar = {
    id?: boolean;
    sku?: boolean;
    variantId?: boolean;
    quantity?: boolean;
    reserved?: boolean;
    location?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type InventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    "id" | "sku" | "variantId" | "quantity" | "reserved" | "location" | "metadata" | "createdAt" | "updatedAt",
    ExtArgs["result"]["inventory"]
  >;
  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>;
  };
  export type InventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      variant?: boolean | ProductVariantDefaultArgs<ExtArgs>;
    };
  export type InventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      variant?: boolean | ProductVariantDefaultArgs<ExtArgs>;
    };

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory";
    objects: {
      variant: Prisma.$ProductVariantPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        sku: string;
        variantId: number;
        quantity: number;
        reserved: number;
        location: string | null;
        metadata: Prisma.JsonValue | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["inventory"]
    >;
    composites: {};
  };

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<
    Prisma.$InventoryPayload,
    S
  >;

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    InventoryFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: InventoryCountAggregateInputType | true;
  };

  export interface InventoryDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Inventory"];
      meta: { name: "Inventory" };
    };
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(
      args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>
    ): Prisma__InventoryClient<
      $Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(
      args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryClient<
      $Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(
      args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>
    ): Prisma__InventoryClient<
      $Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryClient<
      $Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     *
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     *
     */
    findMany<T extends InventoryFindManyArgs>(
      args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     *
     */
    create<T extends InventoryCreateArgs>(
      args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>
    ): Prisma__InventoryClient<
      $Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends InventoryCreateManyArgs>(
      args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Inventories and returns the data saved in the database.
     * @param {InventoryCreateManyAndReturnArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends InventoryCreateManyAndReturnArgs>(
      args?: SelectSubset<T, InventoryCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     *
     */
    delete<T extends InventoryDeleteArgs>(
      args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>
    ): Prisma__InventoryClient<
      $Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends InventoryUpdateArgs>(
      args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>
    ): Prisma__InventoryClient<
      $Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends InventoryDeleteManyArgs>(
      args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends InventoryUpdateManyArgs>(
      args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Inventories and returns the data updated in the database.
     * @param {InventoryUpdateManyAndReturnArgs} args - Arguments to update many Inventories.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends InventoryUpdateManyAndReturnArgs>(
      args: SelectSubset<T, InventoryUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(
      args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>
    ): Prisma__InventoryClient<
      $Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
     **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], InventoryCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends InventoryAggregateArgs>(
      args: Subset<T, InventoryAggregateArgs>
    ): Prisma.PrismaPromise<GetInventoryAggregateType<T>>;

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs["orderBy"] }
        : { orderBy?: InventoryGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Inventory model
     */
    readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    variant<T extends ProductVariantDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ProductVariantDefaultArgs<ExtArgs>>
    ): Prisma__ProductVariantClient<
      $Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Inventory model
   */
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", "Int">;
    readonly sku: FieldRef<"Inventory", "String">;
    readonly variantId: FieldRef<"Inventory", "Int">;
    readonly quantity: FieldRef<"Inventory", "Int">;
    readonly reserved: FieldRef<"Inventory", "Int">;
    readonly location: FieldRef<"Inventory", "String">;
    readonly metadata: FieldRef<"Inventory", "Json">;
    readonly createdAt: FieldRef<"Inventory", "DateTime">;
    readonly updatedAt: FieldRef<"Inventory", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null;
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput;
  };

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null;
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput;
  };

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null;
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Inventories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[];
  };

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null;
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Inventories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[];
  };

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null;
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Inventories.
     */
    skip?: number;
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[];
  };

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null;
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>;
  };

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Inventory createManyAndReturn
   */
  export type InventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null;
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null;
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>;
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput;
  };

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>;
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput;
    /**
     * Limit how many Inventories to update.
     */
    limit?: number;
  };

  /**
   * Inventory updateManyAndReturn
   */
  export type InventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null;
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>;
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput;
    /**
     * Limit how many Inventories to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null;
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput;
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>;
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>;
  };

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null;
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput;
  };

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput;
    /**
     * Limit how many Inventories to delete.
     */
    limit?: number;
  };

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null;
  };

  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null;
    _avg: OrderAvgAggregateOutputType | null;
    _sum: OrderSumAggregateOutputType | null;
    _min: OrderMinAggregateOutputType | null;
    _max: OrderMaxAggregateOutputType | null;
  };

  export type OrderAvgAggregateOutputType = {
    id: number | null;
    userId: number | null;
    subtotal: Decimal | null;
    shipping: Decimal | null;
    tax: Decimal | null;
    total: Decimal | null;
    shippingAddressId: number | null;
    billingAddressId: number | null;
    couponId: number | null;
  };

  export type OrderSumAggregateOutputType = {
    id: number | null;
    userId: number | null;
    subtotal: Decimal | null;
    shipping: Decimal | null;
    tax: Decimal | null;
    total: Decimal | null;
    shippingAddressId: number | null;
    billingAddressId: number | null;
    couponId: number | null;
  };

  export type OrderMinAggregateOutputType = {
    id: number | null;
    orderNumber: string | null;
    userId: number | null;
    status: $Enums.OrderStatus | null;
    subtotal: Decimal | null;
    shipping: Decimal | null;
    tax: Decimal | null;
    total: Decimal | null;
    paymentMethod: $Enums.PaymentMethod | null;
    shippingAddressId: number | null;
    billingAddressId: number | null;
    couponId: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type OrderMaxAggregateOutputType = {
    id: number | null;
    orderNumber: string | null;
    userId: number | null;
    status: $Enums.OrderStatus | null;
    subtotal: Decimal | null;
    shipping: Decimal | null;
    tax: Decimal | null;
    total: Decimal | null;
    paymentMethod: $Enums.PaymentMethod | null;
    shippingAddressId: number | null;
    billingAddressId: number | null;
    couponId: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type OrderCountAggregateOutputType = {
    id: number;
    orderNumber: number;
    userId: number;
    status: number;
    subtotal: number;
    shipping: number;
    tax: number;
    total: number;
    paymentMethod: number;
    shippingAddressId: number;
    billingAddressId: number;
    couponId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type OrderAvgAggregateInputType = {
    id?: true;
    userId?: true;
    subtotal?: true;
    shipping?: true;
    tax?: true;
    total?: true;
    shippingAddressId?: true;
    billingAddressId?: true;
    couponId?: true;
  };

  export type OrderSumAggregateInputType = {
    id?: true;
    userId?: true;
    subtotal?: true;
    shipping?: true;
    tax?: true;
    total?: true;
    shippingAddressId?: true;
    billingAddressId?: true;
    couponId?: true;
  };

  export type OrderMinAggregateInputType = {
    id?: true;
    orderNumber?: true;
    userId?: true;
    status?: true;
    subtotal?: true;
    shipping?: true;
    tax?: true;
    total?: true;
    paymentMethod?: true;
    shippingAddressId?: true;
    billingAddressId?: true;
    couponId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type OrderMaxAggregateInputType = {
    id?: true;
    orderNumber?: true;
    userId?: true;
    status?: true;
    subtotal?: true;
    shipping?: true;
    tax?: true;
    total?: true;
    paymentMethod?: true;
    shippingAddressId?: true;
    billingAddressId?: true;
    couponId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type OrderCountAggregateInputType = {
    id?: true;
    orderNumber?: true;
    userId?: true;
    status?: true;
    subtotal?: true;
    shipping?: true;
    tax?: true;
    total?: true;
    paymentMethod?: true;
    shippingAddressId?: true;
    billingAddressId?: true;
    couponId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Orders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Orders
     **/
    _count?: true | OrderCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: OrderAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: OrderSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrderMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrderMaxAggregateInputType;
  };

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
    [P in keyof T & keyof AggregateOrder]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>;
  };

  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[];
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum;
    having?: OrderScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OrderCountAggregateInputType | true;
    _avg?: OrderAvgAggregateInputType;
    _sum?: OrderSumAggregateInputType;
    _min?: OrderMinAggregateInputType;
    _max?: OrderMaxAggregateInputType;
  };

  export type OrderGroupByOutputType = {
    id: number;
    orderNumber: string;
    userId: number | null;
    status: $Enums.OrderStatus;
    subtotal: Decimal;
    shipping: Decimal;
    tax: Decimal;
    total: Decimal;
    paymentMethod: $Enums.PaymentMethod;
    shippingAddressId: number | null;
    billingAddressId: number | null;
    couponId: number | null;
    createdAt: Date;
    updatedAt: Date;
    _count: OrderCountAggregateOutputType | null;
    _avg: OrderAvgAggregateOutputType | null;
    _sum: OrderSumAggregateOutputType | null;
    _min: OrderMinAggregateOutputType | null;
    _max: OrderMaxAggregateOutputType | null;
  };

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof OrderGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
          : GetScalarType<T[P], OrderGroupByOutputType[P]>;
      }
    >
  >;

  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
    {
      id?: boolean;
      orderNumber?: boolean;
      userId?: boolean;
      status?: boolean;
      subtotal?: boolean;
      shipping?: boolean;
      tax?: boolean;
      total?: boolean;
      paymentMethod?: boolean;
      shippingAddressId?: boolean;
      billingAddressId?: boolean;
      couponId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | Order$userArgs<ExtArgs>;
      paymentMeta?: boolean | Order$paymentMetaArgs<ExtArgs>;
      items?: boolean | Order$itemsArgs<ExtArgs>;
      shippingAddress?: boolean | Order$shippingAddressArgs<ExtArgs>;
      billingAddress?: boolean | Order$billingAddressArgs<ExtArgs>;
      coupon?: boolean | Order$couponArgs<ExtArgs>;
      ReturnRequest?: boolean | Order$ReturnRequestArgs<ExtArgs>;
      Refund?: boolean | Order$RefundArgs<ExtArgs>;
      _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["order"]
  >;

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        orderNumber?: boolean;
        userId?: boolean;
        status?: boolean;
        subtotal?: boolean;
        shipping?: boolean;
        tax?: boolean;
        total?: boolean;
        paymentMethod?: boolean;
        shippingAddressId?: boolean;
        billingAddressId?: boolean;
        couponId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        user?: boolean | Order$userArgs<ExtArgs>;
        shippingAddress?: boolean | Order$shippingAddressArgs<ExtArgs>;
        billingAddress?: boolean | Order$billingAddressArgs<ExtArgs>;
        coupon?: boolean | Order$couponArgs<ExtArgs>;
      },
      ExtArgs["result"]["order"]
    >;

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        orderNumber?: boolean;
        userId?: boolean;
        status?: boolean;
        subtotal?: boolean;
        shipping?: boolean;
        tax?: boolean;
        total?: boolean;
        paymentMethod?: boolean;
        shippingAddressId?: boolean;
        billingAddressId?: boolean;
        couponId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        user?: boolean | Order$userArgs<ExtArgs>;
        shippingAddress?: boolean | Order$shippingAddressArgs<ExtArgs>;
        billingAddress?: boolean | Order$billingAddressArgs<ExtArgs>;
        coupon?: boolean | Order$couponArgs<ExtArgs>;
      },
      ExtArgs["result"]["order"]
    >;

  export type OrderSelectScalar = {
    id?: boolean;
    orderNumber?: boolean;
    userId?: boolean;
    status?: boolean;
    subtotal?: boolean;
    shipping?: boolean;
    tax?: boolean;
    total?: boolean;
    paymentMethod?: boolean;
    shippingAddressId?: boolean;
    billingAddressId?: boolean;
    couponId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    | "id"
    | "orderNumber"
    | "userId"
    | "status"
    | "subtotal"
    | "shipping"
    | "tax"
    | "total"
    | "paymentMethod"
    | "shippingAddressId"
    | "billingAddressId"
    | "couponId"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["order"]
  >;
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Order$userArgs<ExtArgs>;
    paymentMeta?: boolean | Order$paymentMetaArgs<ExtArgs>;
    items?: boolean | Order$itemsArgs<ExtArgs>;
    shippingAddress?: boolean | Order$shippingAddressArgs<ExtArgs>;
    billingAddress?: boolean | Order$billingAddressArgs<ExtArgs>;
    coupon?: boolean | Order$couponArgs<ExtArgs>;
    ReturnRequest?: boolean | Order$ReturnRequestArgs<ExtArgs>;
    Refund?: boolean | Order$RefundArgs<ExtArgs>;
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Order$userArgs<ExtArgs>;
    shippingAddress?: boolean | Order$shippingAddressArgs<ExtArgs>;
    billingAddress?: boolean | Order$billingAddressArgs<ExtArgs>;
    coupon?: boolean | Order$couponArgs<ExtArgs>;
  };
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Order$userArgs<ExtArgs>;
    shippingAddress?: boolean | Order$shippingAddressArgs<ExtArgs>;
    billingAddress?: boolean | Order$billingAddressArgs<ExtArgs>;
    coupon?: boolean | Order$couponArgs<ExtArgs>;
  };

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order";
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null;
      paymentMeta: Prisma.$PaymentMetaPayload<ExtArgs> | null;
      items: Prisma.$OrderItemPayload<ExtArgs>[];
      shippingAddress: Prisma.$AddressPayload<ExtArgs> | null;
      billingAddress: Prisma.$AddressPayload<ExtArgs> | null;
      coupon: Prisma.$CouponPayload<ExtArgs> | null;
      ReturnRequest: Prisma.$ReturnRequestPayload<ExtArgs>[];
      Refund: Prisma.$RefundPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        orderNumber: string;
        userId: number | null;
        status: $Enums.OrderStatus;
        subtotal: Prisma.Decimal;
        shipping: Prisma.Decimal;
        tax: Prisma.Decimal;
        total: Prisma.Decimal;
        paymentMethod: $Enums.PaymentMethod;
        shippingAddressId: number | null;
        billingAddressId: number | null;
        couponId: number | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["order"]
    >;
    composites: {};
  };

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<
    Prisma.$OrderPayload,
    S
  >;

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    OrderFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: OrderCountAggregateInputType | true;
  };

  export interface OrderDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["Order"]; meta: { name: "Order" } };
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(
      args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(
      args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     *
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrderFindManyArgs>(
      args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     *
     */
    create<T extends OrderCreateArgs>(
      args: SelectSubset<T, OrderCreateArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrderCreateManyArgs>(
      args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(
      args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     *
     */
    delete<T extends OrderDeleteArgs>(
      args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrderUpdateArgs>(
      args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrderDeleteManyArgs>(
      args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrderUpdateManyArgs>(
      args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(
      args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(
      args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
     **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], OrderCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrderAggregateArgs>(
      args: Subset<T, OrderAggregateArgs>
    ): Prisma.PrismaPromise<GetOrderAggregateType<T>>;

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs["orderBy"] }
        : { orderBy?: OrderGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Order model
     */
    readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends Order$userArgs<ExtArgs> = {}>(
      args?: Subset<T, Order$userArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    paymentMeta<T extends Order$paymentMetaArgs<ExtArgs> = {}>(
      args?: Subset<T, Order$paymentMetaArgs<ExtArgs>>
    ): Prisma__PaymentMetaClient<
      $Result.GetResult<Prisma.$PaymentMetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    items<T extends Order$itemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Order$itemsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    shippingAddress<T extends Order$shippingAddressArgs<ExtArgs> = {}>(
      args?: Subset<T, Order$shippingAddressArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    billingAddress<T extends Order$billingAddressArgs<ExtArgs> = {}>(
      args?: Subset<T, Order$billingAddressArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    coupon<T extends Order$couponArgs<ExtArgs> = {}>(
      args?: Subset<T, Order$couponArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    ReturnRequest<T extends Order$ReturnRequestArgs<ExtArgs> = {}>(
      args?: Subset<T, Order$ReturnRequestArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    Refund<T extends Order$RefundArgs<ExtArgs> = {}>(
      args?: Subset<T, Order$RefundArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", "Int">;
    readonly orderNumber: FieldRef<"Order", "String">;
    readonly userId: FieldRef<"Order", "Int">;
    readonly status: FieldRef<"Order", "OrderStatus">;
    readonly subtotal: FieldRef<"Order", "Decimal">;
    readonly shipping: FieldRef<"Order", "Decimal">;
    readonly tax: FieldRef<"Order", "Decimal">;
    readonly total: FieldRef<"Order", "Decimal">;
    readonly paymentMethod: FieldRef<"Order", "PaymentMethod">;
    readonly shippingAddressId: FieldRef<"Order", "Int">;
    readonly billingAddressId: FieldRef<"Order", "Int">;
    readonly couponId: FieldRef<"Order", "Int">;
    readonly createdAt: FieldRef<"Order", "DateTime">;
    readonly updatedAt: FieldRef<"Order", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput;
  };

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput;
  };

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Orders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Orders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Orders.
     */
    skip?: number;
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>;
  };

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>;
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput;
  };

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>;
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput;
    /**
     * Limit how many Orders to update.
     */
    limit?: number;
  };

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>;
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput;
    /**
     * Limit how many Orders to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput;
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>;
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>;
  };

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput;
  };

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput;
    /**
     * Limit how many Orders to delete.
     */
    limit?: number;
  };

  /**
   * Order.user
   */
  export type Order$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Order.paymentMeta
   */
  export type Order$paymentMetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMeta
     */
    select?: PaymentMetaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentMeta
     */
    omit?: PaymentMetaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMetaInclude<ExtArgs> | null;
    where?: PaymentMetaWhereInput;
  };

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[];
    cursor?: OrderItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[];
  };

  /**
   * Order.shippingAddress
   */
  export type Order$shippingAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    where?: AddressWhereInput;
  };

  /**
   * Order.billingAddress
   */
  export type Order$billingAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    where?: AddressWhereInput;
  };

  /**
   * Order.coupon
   */
  export type Order$couponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    where?: CouponWhereInput;
  };

  /**
   * Order.ReturnRequest
   */
  export type Order$ReturnRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null;
    where?: ReturnRequestWhereInput;
    orderBy?: ReturnRequestOrderByWithRelationInput | ReturnRequestOrderByWithRelationInput[];
    cursor?: ReturnRequestWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReturnRequestScalarFieldEnum | ReturnRequestScalarFieldEnum[];
  };

  /**
   * Order.Refund
   */
  export type Order$RefundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null;
    where?: RefundWhereInput;
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[];
    cursor?: RefundWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[];
  };

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
  };

  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null;
    _avg: OrderItemAvgAggregateOutputType | null;
    _sum: OrderItemSumAggregateOutputType | null;
    _min: OrderItemMinAggregateOutputType | null;
    _max: OrderItemMaxAggregateOutputType | null;
  };

  export type OrderItemAvgAggregateOutputType = {
    id: number | null;
    orderId: number | null;
    productId: number | null;
    variantId: number | null;
    price: Decimal | null;
    quantity: number | null;
    total: Decimal | null;
  };

  export type OrderItemSumAggregateOutputType = {
    id: number | null;
    orderId: number | null;
    productId: number | null;
    variantId: number | null;
    price: Decimal | null;
    quantity: number | null;
    total: Decimal | null;
  };

  export type OrderItemMinAggregateOutputType = {
    id: number | null;
    orderId: number | null;
    productId: number | null;
    variantId: number | null;
    sku: string | null;
    name: string | null;
    price: Decimal | null;
    quantity: number | null;
    total: Decimal | null;
    returned: boolean | null;
    createdAt: Date | null;
  };

  export type OrderItemMaxAggregateOutputType = {
    id: number | null;
    orderId: number | null;
    productId: number | null;
    variantId: number | null;
    sku: string | null;
    name: string | null;
    price: Decimal | null;
    quantity: number | null;
    total: Decimal | null;
    returned: boolean | null;
    createdAt: Date | null;
  };

  export type OrderItemCountAggregateOutputType = {
    id: number;
    orderId: number;
    productId: number;
    variantId: number;
    sku: number;
    name: number;
    price: number;
    quantity: number;
    total: number;
    returned: number;
    createdAt: number;
    _all: number;
  };

  export type OrderItemAvgAggregateInputType = {
    id?: true;
    orderId?: true;
    productId?: true;
    variantId?: true;
    price?: true;
    quantity?: true;
    total?: true;
  };

  export type OrderItemSumAggregateInputType = {
    id?: true;
    orderId?: true;
    productId?: true;
    variantId?: true;
    price?: true;
    quantity?: true;
    total?: true;
  };

  export type OrderItemMinAggregateInputType = {
    id?: true;
    orderId?: true;
    productId?: true;
    variantId?: true;
    sku?: true;
    name?: true;
    price?: true;
    quantity?: true;
    total?: true;
    returned?: true;
    createdAt?: true;
  };

  export type OrderItemMaxAggregateInputType = {
    id?: true;
    orderId?: true;
    productId?: true;
    variantId?: true;
    sku?: true;
    name?: true;
    price?: true;
    quantity?: true;
    total?: true;
    returned?: true;
    createdAt?: true;
  };

  export type OrderItemCountAggregateInputType = {
    id?: true;
    orderId?: true;
    productId?: true;
    variantId?: true;
    sku?: true;
    name?: true;
    price?: true;
    quantity?: true;
    total?: true;
    returned?: true;
    createdAt?: true;
    _all?: true;
  };

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrderItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned OrderItems
     **/
    _count?: true | OrderItemCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: OrderItemAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: OrderItemSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrderItemMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrderItemMaxAggregateInputType;
  };

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
    [P in keyof T & keyof AggregateOrderItem]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>;
  };

  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[];
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum;
    having?: OrderItemScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OrderItemCountAggregateInputType | true;
    _avg?: OrderItemAvgAggregateInputType;
    _sum?: OrderItemSumAggregateInputType;
    _min?: OrderItemMinAggregateInputType;
    _max?: OrderItemMaxAggregateInputType;
  };

  export type OrderItemGroupByOutputType = {
    id: number;
    orderId: number;
    productId: number | null;
    variantId: number | null;
    sku: string | null;
    name: string;
    price: Decimal;
    quantity: number;
    total: Decimal;
    returned: boolean;
    createdAt: Date;
    _count: OrderItemCountAggregateOutputType | null;
    _avg: OrderItemAvgAggregateOutputType | null;
    _sum: OrderItemSumAggregateOutputType | null;
    _min: OrderItemMinAggregateOutputType | null;
    _max: OrderItemMaxAggregateOutputType | null;
  };

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof OrderItemGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
          : GetScalarType<T[P], OrderItemGroupByOutputType[P]>;
      }
    >
  >;

  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        orderId?: boolean;
        productId?: boolean;
        variantId?: boolean;
        sku?: boolean;
        name?: boolean;
        price?: boolean;
        quantity?: boolean;
        total?: boolean;
        returned?: boolean;
        createdAt?: boolean;
        order?: boolean | OrderDefaultArgs<ExtArgs>;
        product?: boolean | OrderItem$productArgs<ExtArgs>;
        variant?: boolean | OrderItem$variantArgs<ExtArgs>;
        ReturnRequest?: boolean | OrderItem$ReturnRequestArgs<ExtArgs>;
        _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["orderItem"]
    >;

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        orderId?: boolean;
        productId?: boolean;
        variantId?: boolean;
        sku?: boolean;
        name?: boolean;
        price?: boolean;
        quantity?: boolean;
        total?: boolean;
        returned?: boolean;
        createdAt?: boolean;
        order?: boolean | OrderDefaultArgs<ExtArgs>;
        product?: boolean | OrderItem$productArgs<ExtArgs>;
        variant?: boolean | OrderItem$variantArgs<ExtArgs>;
      },
      ExtArgs["result"]["orderItem"]
    >;

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        orderId?: boolean;
        productId?: boolean;
        variantId?: boolean;
        sku?: boolean;
        name?: boolean;
        price?: boolean;
        quantity?: boolean;
        total?: boolean;
        returned?: boolean;
        createdAt?: boolean;
        order?: boolean | OrderDefaultArgs<ExtArgs>;
        product?: boolean | OrderItem$productArgs<ExtArgs>;
        variant?: boolean | OrderItem$variantArgs<ExtArgs>;
      },
      ExtArgs["result"]["orderItem"]
    >;

  export type OrderItemSelectScalar = {
    id?: boolean;
    orderId?: boolean;
    productId?: boolean;
    variantId?: boolean;
    sku?: boolean;
    name?: boolean;
    price?: boolean;
    quantity?: boolean;
    total?: boolean;
    returned?: boolean;
    createdAt?: boolean;
  };

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    | "id"
    | "orderId"
    | "productId"
    | "variantId"
    | "sku"
    | "name"
    | "price"
    | "quantity"
    | "total"
    | "returned"
    | "createdAt",
    ExtArgs["result"]["orderItem"]
  >;
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>;
    product?: boolean | OrderItem$productArgs<ExtArgs>;
    variant?: boolean | OrderItem$variantArgs<ExtArgs>;
    ReturnRequest?: boolean | OrderItem$ReturnRequestArgs<ExtArgs>;
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      order?: boolean | OrderDefaultArgs<ExtArgs>;
      product?: boolean | OrderItem$productArgs<ExtArgs>;
      variant?: boolean | OrderItem$variantArgs<ExtArgs>;
    };
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      order?: boolean | OrderDefaultArgs<ExtArgs>;
      product?: boolean | OrderItem$productArgs<ExtArgs>;
      variant?: boolean | OrderItem$variantArgs<ExtArgs>;
    };

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem";
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>;
      product: Prisma.$ProductPayload<ExtArgs> | null;
      variant: Prisma.$ProductVariantPayload<ExtArgs> | null;
      ReturnRequest: Prisma.$ReturnRequestPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        orderId: number;
        productId: number | null;
        variantId: number | null;
        sku: string | null;
        name: string;
        price: Prisma.Decimal;
        quantity: number;
        total: Prisma.Decimal;
        returned: boolean;
        createdAt: Date;
      },
      ExtArgs["result"]["orderItem"]
    >;
    composites: {};
  };

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<
    Prisma.$OrderItemPayload,
    S
  >;

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    OrderItemFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: OrderItemCountAggregateInputType | true;
  };

  export interface OrderItemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["OrderItem"];
      meta: { name: "OrderItem" };
    };
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(
      args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(
      args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     *
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrderItemFindManyArgs>(
      args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     *
     */
    create<T extends OrderItemCreateArgs>(
      args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrderItemCreateManyArgs>(
      args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(
      args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     *
     */
    delete<T extends OrderItemDeleteArgs>(
      args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrderItemUpdateArgs>(
      args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(
      args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrderItemUpdateManyArgs>(
      args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(
      args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(
      args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
     **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], OrderItemCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrderItemAggregateArgs>(
      args: Subset<T, OrderItemAggregateArgs>
    ): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>;

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs["orderBy"] }
        : { orderBy?: OrderItemGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the OrderItem model
     */
    readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrderDefaultArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    product<T extends OrderItem$productArgs<ExtArgs> = {}>(
      args?: Subset<T, OrderItem$productArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    variant<T extends OrderItem$variantArgs<ExtArgs> = {}>(
      args?: Subset<T, OrderItem$variantArgs<ExtArgs>>
    ): Prisma__ProductVariantClient<
      $Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    ReturnRequest<T extends OrderItem$ReturnRequestArgs<ExtArgs> = {}>(
      args?: Subset<T, OrderItem$ReturnRequestArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", "Int">;
    readonly orderId: FieldRef<"OrderItem", "Int">;
    readonly productId: FieldRef<"OrderItem", "Int">;
    readonly variantId: FieldRef<"OrderItem", "Int">;
    readonly sku: FieldRef<"OrderItem", "String">;
    readonly name: FieldRef<"OrderItem", "String">;
    readonly price: FieldRef<"OrderItem", "Decimal">;
    readonly quantity: FieldRef<"OrderItem", "Int">;
    readonly total: FieldRef<"OrderItem", "Decimal">;
    readonly returned: FieldRef<"OrderItem", "Boolean">;
    readonly createdAt: FieldRef<"OrderItem", "DateTime">;
  }

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput;
  };

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput;
  };

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrderItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[];
  };

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrderItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[];
  };

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrderItems.
     */
    skip?: number;
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[];
  };

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>;
  };

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>;
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput;
  };

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>;
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput;
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number;
  };

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>;
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput;
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput;
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>;
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>;
  };

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput;
  };

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput;
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number;
  };

  /**
   * OrderItem.product
   */
  export type OrderItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    where?: ProductWhereInput;
  };

  /**
   * OrderItem.variant
   */
  export type OrderItem$variantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null;
    where?: ProductVariantWhereInput;
  };

  /**
   * OrderItem.ReturnRequest
   */
  export type OrderItem$ReturnRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null;
    where?: ReturnRequestWhereInput;
    orderBy?: ReturnRequestOrderByWithRelationInput | ReturnRequestOrderByWithRelationInput[];
    cursor?: ReturnRequestWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReturnRequestScalarFieldEnum | ReturnRequestScalarFieldEnum[];
  };

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
  };

  /**
   * Model Coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null;
    _avg: CouponAvgAggregateOutputType | null;
    _sum: CouponSumAggregateOutputType | null;
    _min: CouponMinAggregateOutputType | null;
    _max: CouponMaxAggregateOutputType | null;
  };

  export type CouponAvgAggregateOutputType = {
    id: number | null;
    amount: Decimal | null;
    percent: number | null;
    usageLimit: number | null;
    usagePerUser: number | null;
    timesUsed: number | null;
  };

  export type CouponSumAggregateOutputType = {
    id: number | null;
    amount: Decimal | null;
    percent: number | null;
    usageLimit: number | null;
    usagePerUser: number | null;
    timesUsed: number | null;
  };

  export type CouponMinAggregateOutputType = {
    id: number | null;
    code: string | null;
    type: $Enums.CouponType | null;
    amount: Decimal | null;
    percent: number | null;
    description: string | null;
    startsAt: Date | null;
    expiresAt: Date | null;
    usageLimit: number | null;
    usagePerUser: number | null;
    timesUsed: number | null;
    active: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type CouponMaxAggregateOutputType = {
    id: number | null;
    code: string | null;
    type: $Enums.CouponType | null;
    amount: Decimal | null;
    percent: number | null;
    description: string | null;
    startsAt: Date | null;
    expiresAt: Date | null;
    usageLimit: number | null;
    usagePerUser: number | null;
    timesUsed: number | null;
    active: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type CouponCountAggregateOutputType = {
    id: number;
    code: number;
    type: number;
    amount: number;
    percent: number;
    description: number;
    startsAt: number;
    expiresAt: number;
    usageLimit: number;
    usagePerUser: number;
    timesUsed: number;
    active: number;
    metadata: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type CouponAvgAggregateInputType = {
    id?: true;
    amount?: true;
    percent?: true;
    usageLimit?: true;
    usagePerUser?: true;
    timesUsed?: true;
  };

  export type CouponSumAggregateInputType = {
    id?: true;
    amount?: true;
    percent?: true;
    usageLimit?: true;
    usagePerUser?: true;
    timesUsed?: true;
  };

  export type CouponMinAggregateInputType = {
    id?: true;
    code?: true;
    type?: true;
    amount?: true;
    percent?: true;
    description?: true;
    startsAt?: true;
    expiresAt?: true;
    usageLimit?: true;
    usagePerUser?: true;
    timesUsed?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type CouponMaxAggregateInputType = {
    id?: true;
    code?: true;
    type?: true;
    amount?: true;
    percent?: true;
    description?: true;
    startsAt?: true;
    expiresAt?: true;
    usageLimit?: true;
    usagePerUser?: true;
    timesUsed?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type CouponCountAggregateInputType = {
    id?: true;
    code?: true;
    type?: true;
    amount?: true;
    percent?: true;
    description?: true;
    startsAt?: true;
    expiresAt?: true;
    usageLimit?: true;
    usagePerUser?: true;
    timesUsed?: true;
    active?: true;
    metadata?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type CouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupon to aggregate.
     */
    where?: CouponWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CouponWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Coupons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Coupons
     **/
    _count?: true | CouponCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CouponAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CouponSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CouponMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CouponMaxAggregateInputType;
  };

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
    [P in keyof T & keyof AggregateCoupon]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>;
  };

  export type CouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput;
    orderBy?: CouponOrderByWithAggregationInput | CouponOrderByWithAggregationInput[];
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum;
    having?: CouponScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CouponCountAggregateInputType | true;
    _avg?: CouponAvgAggregateInputType;
    _sum?: CouponSumAggregateInputType;
    _min?: CouponMinAggregateInputType;
    _max?: CouponMaxAggregateInputType;
  };

  export type CouponGroupByOutputType = {
    id: number;
    code: string;
    type: $Enums.CouponType;
    amount: Decimal | null;
    percent: number | null;
    description: string | null;
    startsAt: Date | null;
    expiresAt: Date | null;
    usageLimit: number | null;
    usagePerUser: number | null;
    timesUsed: number;
    active: boolean;
    metadata: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    _count: CouponCountAggregateOutputType | null;
    _avg: CouponAvgAggregateOutputType | null;
    _sum: CouponSumAggregateOutputType | null;
    _min: CouponMinAggregateOutputType | null;
    _max: CouponMaxAggregateOutputType | null;
  };

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof CouponGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
          : GetScalarType<T[P], CouponGroupByOutputType[P]>;
      }
    >
  >;

  export type CouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
    {
      id?: boolean;
      code?: boolean;
      type?: boolean;
      amount?: boolean;
      percent?: boolean;
      description?: boolean;
      startsAt?: boolean;
      expiresAt?: boolean;
      usageLimit?: boolean;
      usagePerUser?: boolean;
      timesUsed?: boolean;
      active?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      Order?: boolean | Coupon$OrderArgs<ExtArgs>;
      _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["coupon"]
  >;

  export type CouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        code?: boolean;
        type?: boolean;
        amount?: boolean;
        percent?: boolean;
        description?: boolean;
        startsAt?: boolean;
        expiresAt?: boolean;
        usageLimit?: boolean;
        usagePerUser?: boolean;
        timesUsed?: boolean;
        active?: boolean;
        metadata?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
      },
      ExtArgs["result"]["coupon"]
    >;

  export type CouponSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        code?: boolean;
        type?: boolean;
        amount?: boolean;
        percent?: boolean;
        description?: boolean;
        startsAt?: boolean;
        expiresAt?: boolean;
        usageLimit?: boolean;
        usagePerUser?: boolean;
        timesUsed?: boolean;
        active?: boolean;
        metadata?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
      },
      ExtArgs["result"]["coupon"]
    >;

  export type CouponSelectScalar = {
    id?: boolean;
    code?: boolean;
    type?: boolean;
    amount?: boolean;
    percent?: boolean;
    description?: boolean;
    startsAt?: boolean;
    expiresAt?: boolean;
    usageLimit?: boolean;
    usagePerUser?: boolean;
    timesUsed?: boolean;
    active?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type CouponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    | "id"
    | "code"
    | "type"
    | "amount"
    | "percent"
    | "description"
    | "startsAt"
    | "expiresAt"
    | "usageLimit"
    | "usagePerUser"
    | "timesUsed"
    | "active"
    | "metadata"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["coupon"]
  >;
  export type CouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Order?: boolean | Coupon$OrderArgs<ExtArgs>;
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type CouponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {};
  export type CouponIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {};

  export type $CouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coupon";
    objects: {
      Order: Prisma.$OrderPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        code: string;
        type: $Enums.CouponType;
        amount: Prisma.Decimal | null;
        percent: number | null;
        description: string | null;
        startsAt: Date | null;
        expiresAt: Date | null;
        usageLimit: number | null;
        usagePerUser: number | null;
        timesUsed: number;
        active: boolean;
        metadata: Prisma.JsonValue | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["coupon"]
    >;
    composites: {};
  };

  type CouponGetPayload<S extends boolean | null | undefined | CouponDefaultArgs> = $Result.GetResult<
    Prisma.$CouponPayload,
    S
  >;

  type CouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    CouponFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: CouponCountAggregateInputType | true;
  };

  export interface CouponDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["Coupon"]; meta: { name: "Coupon" } };
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponFindUniqueArgs>(
      args: SelectSubset<T, CouponFindUniqueArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CouponFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponFindFirstArgs>(
      args?: SelectSubset<T, CouponFindFirstArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CouponFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     *
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CouponFindManyArgs>(
      args?: SelectSubset<T, CouponFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     *
     */
    create<T extends CouponCreateArgs>(
      args: SelectSubset<T, CouponCreateArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Coupons.
     * @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CouponCreateManyArgs>(
      args?: SelectSubset<T, CouponCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Coupons and returns the data saved in the database.
     * @param {CouponCreateManyAndReturnArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CouponCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CouponCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     *
     */
    delete<T extends CouponDeleteArgs>(
      args: SelectSubset<T, CouponDeleteArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CouponUpdateArgs>(
      args: SelectSubset<T, CouponUpdateArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CouponDeleteManyArgs>(
      args?: SelectSubset<T, CouponDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CouponUpdateManyArgs>(
      args: SelectSubset<T, CouponUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Coupons and returns the data updated in the database.
     * @param {CouponUpdateManyAndReturnArgs} args - Arguments to update many Coupons.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CouponUpdateManyAndReturnArgs>(
      args: SelectSubset<T, CouponUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends CouponUpsertArgs>(
      args: SelectSubset<T, CouponUpsertArgs<ExtArgs>>
    ): Prisma__CouponClient<
      $Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
     **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], CouponCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CouponAggregateArgs>(
      args: Subset<T, CouponAggregateArgs>
    ): Prisma.PrismaPromise<GetCouponAggregateType<T>>;

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs["orderBy"] }
        : { orderBy?: CouponGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Coupon model
     */
    readonly fields: CouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    Order<T extends Coupon$OrderArgs<ExtArgs> = {}>(
      args?: Subset<T, Coupon$OrderArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Coupon model
   */
  interface CouponFieldRefs {
    readonly id: FieldRef<"Coupon", "Int">;
    readonly code: FieldRef<"Coupon", "String">;
    readonly type: FieldRef<"Coupon", "CouponType">;
    readonly amount: FieldRef<"Coupon", "Decimal">;
    readonly percent: FieldRef<"Coupon", "Int">;
    readonly description: FieldRef<"Coupon", "String">;
    readonly startsAt: FieldRef<"Coupon", "DateTime">;
    readonly expiresAt: FieldRef<"Coupon", "DateTime">;
    readonly usageLimit: FieldRef<"Coupon", "Int">;
    readonly usagePerUser: FieldRef<"Coupon", "Int">;
    readonly timesUsed: FieldRef<"Coupon", "Int">;
    readonly active: FieldRef<"Coupon", "Boolean">;
    readonly metadata: FieldRef<"Coupon", "Json">;
    readonly createdAt: FieldRef<"Coupon", "DateTime">;
    readonly updatedAt: FieldRef<"Coupon", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Coupon findUnique
   */
  export type CouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput;
  };

  /**
   * Coupon findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput;
  };

  /**
   * Coupon findFirst
   */
  export type CouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Coupons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[];
  };

  /**
   * Coupon findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Coupons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[];
  };

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Coupons.
     */
    cursor?: CouponWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Coupons.
     */
    skip?: number;
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[];
  };

  /**
   * Coupon create
   */
  export type CouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * The data needed to create a Coupon.
     */
    data: XOR<CouponCreateInput, CouponUncheckedCreateInput>;
  };

  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Coupon createManyAndReturn
   */
  export type CouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Coupon update
   */
  export type CouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * The data needed to update a Coupon.
     */
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>;
    /**
     * Choose, which Coupon to update.
     */
    where: CouponWhereUniqueInput;
  };

  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>;
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput;
    /**
     * Limit how many Coupons to update.
     */
    limit?: number;
  };

  /**
   * Coupon updateManyAndReturn
   */
  export type CouponUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>;
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput;
    /**
     * Limit how many Coupons to update.
     */
    limit?: number;
  };

  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * The filter to search for the Coupon to update in case it exists.
     */
    where: CouponWhereUniqueInput;
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     */
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>;
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>;
  };

  /**
   * Coupon delete
   */
  export type CouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
    /**
     * Filter which Coupon to delete.
     */
    where: CouponWhereUniqueInput;
  };

  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupons to delete
     */
    where?: CouponWhereInput;
    /**
     * Limit how many Coupons to delete.
     */
    limit?: number;
  };

  /**
   * Coupon.Order
   */
  export type Coupon$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    where?: OrderWhereInput;
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    cursor?: OrderWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Coupon without action
   */
  export type CouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null;
  };

  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null;
    _avg: ReviewAvgAggregateOutputType | null;
    _sum: ReviewSumAggregateOutputType | null;
    _min: ReviewMinAggregateOutputType | null;
    _max: ReviewMaxAggregateOutputType | null;
  };

  export type ReviewAvgAggregateOutputType = {
    id: number | null;
    userId: number | null;
    productId: number | null;
    rating: number | null;
  };

  export type ReviewSumAggregateOutputType = {
    id: number | null;
    userId: number | null;
    productId: number | null;
    rating: number | null;
  };

  export type ReviewMinAggregateOutputType = {
    id: number | null;
    userId: number | null;
    productId: number | null;
    rating: number | null;
    title: string | null;
    body: string | null;
    approved: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ReviewMaxAggregateOutputType = {
    id: number | null;
    userId: number | null;
    productId: number | null;
    rating: number | null;
    title: string | null;
    body: string | null;
    approved: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ReviewCountAggregateOutputType = {
    id: number;
    userId: number;
    productId: number;
    rating: number;
    title: number;
    body: number;
    approved: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ReviewAvgAggregateInputType = {
    id?: true;
    userId?: true;
    productId?: true;
    rating?: true;
  };

  export type ReviewSumAggregateInputType = {
    id?: true;
    userId?: true;
    productId?: true;
    rating?: true;
  };

  export type ReviewMinAggregateInputType = {
    id?: true;
    userId?: true;
    productId?: true;
    rating?: true;
    title?: true;
    body?: true;
    approved?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ReviewMaxAggregateInputType = {
    id?: true;
    userId?: true;
    productId?: true;
    rating?: true;
    title?: true;
    body?: true;
    approved?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ReviewCountAggregateInputType = {
    id?: true;
    userId?: true;
    productId?: true;
    rating?: true;
    title?: true;
    body?: true;
    approved?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Reviews
     **/
    _count?: true | ReviewCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ReviewAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ReviewSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ReviewMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ReviewMaxAggregateInputType;
  };

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
    [P in keyof T & keyof AggregateReview]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>;
  };

  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[];
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum;
    having?: ReviewScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ReviewCountAggregateInputType | true;
    _avg?: ReviewAvgAggregateInputType;
    _sum?: ReviewSumAggregateInputType;
    _min?: ReviewMinAggregateInputType;
    _max?: ReviewMaxAggregateInputType;
  };

  export type ReviewGroupByOutputType = {
    id: number;
    userId: number | null;
    productId: number;
    rating: number;
    title: string | null;
    body: string | null;
    approved: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: ReviewCountAggregateOutputType | null;
    _avg: ReviewAvgAggregateOutputType | null;
    _sum: ReviewSumAggregateOutputType | null;
    _min: ReviewMinAggregateOutputType | null;
    _max: ReviewMaxAggregateOutputType | null;
  };

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof ReviewGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
          : GetScalarType<T[P], ReviewGroupByOutputType[P]>;
      }
    >
  >;

  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      productId?: boolean;
      rating?: boolean;
      title?: boolean;
      body?: boolean;
      approved?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | Review$userArgs<ExtArgs>;
      product?: boolean | ProductDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["review"]
  >;

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        productId?: boolean;
        rating?: boolean;
        title?: boolean;
        body?: boolean;
        approved?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        user?: boolean | Review$userArgs<ExtArgs>;
        product?: boolean | ProductDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["review"]
    >;

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        productId?: boolean;
        rating?: boolean;
        title?: boolean;
        body?: boolean;
        approved?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        user?: boolean | Review$userArgs<ExtArgs>;
        product?: boolean | ProductDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["review"]
    >;

  export type ReviewSelectScalar = {
    id?: boolean;
    userId?: boolean;
    productId?: boolean;
    rating?: boolean;
    title?: boolean;
    body?: boolean;
    approved?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    "id" | "userId" | "productId" | "rating" | "title" | "body" | "approved" | "createdAt" | "updatedAt",
    ExtArgs["result"]["review"]
  >;
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Review$userArgs<ExtArgs>;
    product?: boolean | ProductDefaultArgs<ExtArgs>;
  };
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Review$userArgs<ExtArgs>;
    product?: boolean | ProductDefaultArgs<ExtArgs>;
  };
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Review$userArgs<ExtArgs>;
    product?: boolean | ProductDefaultArgs<ExtArgs>;
  };

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review";
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null;
      product: Prisma.$ProductPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        userId: number | null;
        productId: number;
        rating: number;
        title: string | null;
        body: string | null;
        approved: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["review"]
    >;
    composites: {};
  };

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<
    Prisma.$ReviewPayload,
    S
  >;

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ReviewFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ReviewCountAggregateInputType | true;
  };

  export interface ReviewDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["Review"]; meta: { name: "Review" } };
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(
      args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(
      args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     *
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ReviewFindManyArgs>(
      args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     *
     */
    create<T extends ReviewCreateArgs>(
      args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ReviewCreateManyArgs>(
      args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     *
     */
    delete<T extends ReviewDeleteArgs>(
      args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ReviewUpdateArgs>(
      args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ReviewDeleteManyArgs>(
      args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ReviewUpdateManyArgs>(
      args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(
      args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
     **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ReviewCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ReviewAggregateArgs>(
      args: Subset<T, ReviewAggregateArgs>
    ): Prisma.PrismaPromise<GetReviewAggregateType<T>>;

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs["orderBy"] }
        : { orderBy?: ReviewGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Review model
     */
    readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends Review$userArgs<ExtArgs> = {}>(
      args?: Subset<T, Review$userArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ProductDefaultArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", "Int">;
    readonly userId: FieldRef<"Review", "Int">;
    readonly productId: FieldRef<"Review", "Int">;
    readonly rating: FieldRef<"Review", "Int">;
    readonly title: FieldRef<"Review", "String">;
    readonly body: FieldRef<"Review", "String">;
    readonly approved: FieldRef<"Review", "Boolean">;
    readonly createdAt: FieldRef<"Review", "DateTime">;
    readonly updatedAt: FieldRef<"Review", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput;
  };

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput;
  };

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>;
  };

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>;
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput;
  };

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>;
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput;
    /**
     * Limit how many Reviews to update.
     */
    limit?: number;
  };

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>;
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput;
    /**
     * Limit how many Reviews to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput;
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>;
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>;
  };

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput;
  };

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput;
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number;
  };

  /**
   * Review.user
   */
  export type Review$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
  };

  /**
   * Model Wishlist
   */

  export type AggregateWishlist = {
    _count: WishlistCountAggregateOutputType | null;
    _avg: WishlistAvgAggregateOutputType | null;
    _sum: WishlistSumAggregateOutputType | null;
    _min: WishlistMinAggregateOutputType | null;
    _max: WishlistMaxAggregateOutputType | null;
  };

  export type WishlistAvgAggregateOutputType = {
    id: number | null;
    userId: number | null;
  };

  export type WishlistSumAggregateOutputType = {
    id: number | null;
    userId: number | null;
  };

  export type WishlistMinAggregateOutputType = {
    id: number | null;
    userId: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type WishlistMaxAggregateOutputType = {
    id: number | null;
    userId: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type WishlistCountAggregateOutputType = {
    id: number;
    userId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type WishlistAvgAggregateInputType = {
    id?: true;
    userId?: true;
  };

  export type WishlistSumAggregateInputType = {
    id?: true;
    userId?: true;
  };

  export type WishlistMinAggregateInputType = {
    id?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type WishlistMaxAggregateInputType = {
    id?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type WishlistCountAggregateInputType = {
    id?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type WishlistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wishlist to aggregate.
     */
    where?: WishlistWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: WishlistWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Wishlists.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Wishlists
     **/
    _count?: true | WishlistCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: WishlistAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: WishlistSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: WishlistMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: WishlistMaxAggregateInputType;
  };

  export type GetWishlistAggregateType<T extends WishlistAggregateArgs> = {
    [P in keyof T & keyof AggregateWishlist]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlist[P]>
      : GetScalarType<T[P], AggregateWishlist[P]>;
  };

  export type WishlistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistWhereInput;
    orderBy?: WishlistOrderByWithAggregationInput | WishlistOrderByWithAggregationInput[];
    by: WishlistScalarFieldEnum[] | WishlistScalarFieldEnum;
    having?: WishlistScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: WishlistCountAggregateInputType | true;
    _avg?: WishlistAvgAggregateInputType;
    _sum?: WishlistSumAggregateInputType;
    _min?: WishlistMinAggregateInputType;
    _max?: WishlistMaxAggregateInputType;
  };

  export type WishlistGroupByOutputType = {
    id: number;
    userId: number;
    createdAt: Date;
    updatedAt: Date;
    _count: WishlistCountAggregateOutputType | null;
    _avg: WishlistAvgAggregateOutputType | null;
    _sum: WishlistSumAggregateOutputType | null;
    _min: WishlistMinAggregateOutputType | null;
    _max: WishlistMaxAggregateOutputType | null;
  };

  type GetWishlistGroupByPayload<T extends WishlistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WishlistGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof WishlistGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], WishlistGroupByOutputType[P]>
          : GetScalarType<T[P], WishlistGroupByOutputType[P]>;
      }
    >
  >;

  export type WishlistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
        items?: boolean | Wishlist$itemsArgs<ExtArgs>;
        _count?: boolean | WishlistCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["wishlist"]
    >;

  export type WishlistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["wishlist"]
    >;

  export type WishlistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["wishlist"]
    >;

  export type WishlistSelectScalar = {
    id?: boolean;
    userId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type WishlistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    "id" | "userId" | "createdAt" | "updatedAt",
    ExtArgs["result"]["wishlist"]
  >;
  export type WishlistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    items?: boolean | Wishlist$itemsArgs<ExtArgs>;
    _count?: boolean | WishlistCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type WishlistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type WishlistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $WishlistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wishlist";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      items: Prisma.$WishlistItemPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        userId: number;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["wishlist"]
    >;
    composites: {};
  };

  type WishlistGetPayload<S extends boolean | null | undefined | WishlistDefaultArgs> = $Result.GetResult<
    Prisma.$WishlistPayload,
    S
  >;

  type WishlistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    WishlistFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: WishlistCountAggregateInputType | true;
  };

  export interface WishlistDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Wishlist"];
      meta: { name: "Wishlist" };
    };
    /**
     * Find zero or one Wishlist that matches the filter.
     * @param {WishlistFindUniqueArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WishlistFindUniqueArgs>(
      args: SelectSubset<T, WishlistFindUniqueArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Wishlist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WishlistFindUniqueOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WishlistFindUniqueOrThrowArgs>(
      args: SelectSubset<T, WishlistFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Wishlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindFirstArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WishlistFindFirstArgs>(
      args?: SelectSubset<T, WishlistFindFirstArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Wishlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindFirstOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WishlistFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WishlistFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Wishlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wishlists
     * const wishlists = await prisma.wishlist.findMany()
     *
     * // Get first 10 Wishlists
     * const wishlists = await prisma.wishlist.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const wishlistWithIdOnly = await prisma.wishlist.findMany({ select: { id: true } })
     *
     */
    findMany<T extends WishlistFindManyArgs>(
      args?: SelectSubset<T, WishlistFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Wishlist.
     * @param {WishlistCreateArgs} args - Arguments to create a Wishlist.
     * @example
     * // Create one Wishlist
     * const Wishlist = await prisma.wishlist.create({
     *   data: {
     *     // ... data to create a Wishlist
     *   }
     * })
     *
     */
    create<T extends WishlistCreateArgs>(
      args: SelectSubset<T, WishlistCreateArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Wishlists.
     * @param {WishlistCreateManyArgs} args - Arguments to create many Wishlists.
     * @example
     * // Create many Wishlists
     * const wishlist = await prisma.wishlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends WishlistCreateManyArgs>(
      args?: SelectSubset<T, WishlistCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Wishlists and returns the data saved in the database.
     * @param {WishlistCreateManyAndReturnArgs} args - Arguments to create many Wishlists.
     * @example
     * // Create many Wishlists
     * const wishlist = await prisma.wishlist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Wishlists and only return the `id`
     * const wishlistWithIdOnly = await prisma.wishlist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends WishlistCreateManyAndReturnArgs>(
      args?: SelectSubset<T, WishlistCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Wishlist.
     * @param {WishlistDeleteArgs} args - Arguments to delete one Wishlist.
     * @example
     * // Delete one Wishlist
     * const Wishlist = await prisma.wishlist.delete({
     *   where: {
     *     // ... filter to delete one Wishlist
     *   }
     * })
     *
     */
    delete<T extends WishlistDeleteArgs>(
      args: SelectSubset<T, WishlistDeleteArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Wishlist.
     * @param {WishlistUpdateArgs} args - Arguments to update one Wishlist.
     * @example
     * // Update one Wishlist
     * const wishlist = await prisma.wishlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends WishlistUpdateArgs>(
      args: SelectSubset<T, WishlistUpdateArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Wishlists.
     * @param {WishlistDeleteManyArgs} args - Arguments to filter Wishlists to delete.
     * @example
     * // Delete a few Wishlists
     * const { count } = await prisma.wishlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends WishlistDeleteManyArgs>(
      args?: SelectSubset<T, WishlistDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wishlists
     * const wishlist = await prisma.wishlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends WishlistUpdateManyArgs>(
      args: SelectSubset<T, WishlistUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Wishlists and returns the data updated in the database.
     * @param {WishlistUpdateManyAndReturnArgs} args - Arguments to update many Wishlists.
     * @example
     * // Update many Wishlists
     * const wishlist = await prisma.wishlist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Wishlists and only return the `id`
     * const wishlistWithIdOnly = await prisma.wishlist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends WishlistUpdateManyAndReturnArgs>(
      args: SelectSubset<T, WishlistUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Wishlist.
     * @param {WishlistUpsertArgs} args - Arguments to update or create a Wishlist.
     * @example
     * // Update or create a Wishlist
     * const wishlist = await prisma.wishlist.upsert({
     *   create: {
     *     // ... data to create a Wishlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wishlist we want to update
     *   }
     * })
     */
    upsert<T extends WishlistUpsertArgs>(
      args: SelectSubset<T, WishlistUpsertArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistCountArgs} args - Arguments to filter Wishlists to count.
     * @example
     * // Count the number of Wishlists
     * const count = await prisma.wishlist.count({
     *   where: {
     *     // ... the filter for the Wishlists we want to count
     *   }
     * })
     **/
    count<T extends WishlistCountArgs>(
      args?: Subset<T, WishlistCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], WishlistCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends WishlistAggregateArgs>(
      args: Subset<T, WishlistAggregateArgs>
    ): Prisma.PrismaPromise<GetWishlistAggregateType<T>>;

    /**
     * Group by Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends WishlistGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistGroupByArgs["orderBy"] }
        : { orderBy?: WishlistGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, WishlistGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetWishlistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Wishlist model
     */
    readonly fields: WishlistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wishlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WishlistClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    items<T extends Wishlist$itemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Wishlist$itemsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Wishlist model
   */
  interface WishlistFieldRefs {
    readonly id: FieldRef<"Wishlist", "Int">;
    readonly userId: FieldRef<"Wishlist", "Int">;
    readonly createdAt: FieldRef<"Wishlist", "DateTime">;
    readonly updatedAt: FieldRef<"Wishlist", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Wishlist findUnique
   */
  export type WishlistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * Filter, which Wishlist to fetch.
     */
    where: WishlistWhereUniqueInput;
  };

  /**
   * Wishlist findUniqueOrThrow
   */
  export type WishlistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * Filter, which Wishlist to fetch.
     */
    where: WishlistWhereUniqueInput;
  };

  /**
   * Wishlist findFirst
   */
  export type WishlistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * Filter, which Wishlist to fetch.
     */
    where?: WishlistWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Wishlists.
     */
    cursor?: WishlistWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Wishlists.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Wishlists.
     */
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[];
  };

  /**
   * Wishlist findFirstOrThrow
   */
  export type WishlistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * Filter, which Wishlist to fetch.
     */
    where?: WishlistWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Wishlists.
     */
    cursor?: WishlistWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Wishlists.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Wishlists.
     */
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[];
  };

  /**
   * Wishlist findMany
   */
  export type WishlistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * Filter, which Wishlists to fetch.
     */
    where?: WishlistWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Wishlists.
     */
    cursor?: WishlistWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Wishlists.
     */
    skip?: number;
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[];
  };

  /**
   * Wishlist create
   */
  export type WishlistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * The data needed to create a Wishlist.
     */
    data: XOR<WishlistCreateInput, WishlistUncheckedCreateInput>;
  };

  /**
   * Wishlist createMany
   */
  export type WishlistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wishlists.
     */
    data: WishlistCreateManyInput | WishlistCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Wishlist createManyAndReturn
   */
  export type WishlistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * The data used to create many Wishlists.
     */
    data: WishlistCreateManyInput | WishlistCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Wishlist update
   */
  export type WishlistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * The data needed to update a Wishlist.
     */
    data: XOR<WishlistUpdateInput, WishlistUncheckedUpdateInput>;
    /**
     * Choose, which Wishlist to update.
     */
    where: WishlistWhereUniqueInput;
  };

  /**
   * Wishlist updateMany
   */
  export type WishlistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wishlists.
     */
    data: XOR<WishlistUpdateManyMutationInput, WishlistUncheckedUpdateManyInput>;
    /**
     * Filter which Wishlists to update
     */
    where?: WishlistWhereInput;
    /**
     * Limit how many Wishlists to update.
     */
    limit?: number;
  };

  /**
   * Wishlist updateManyAndReturn
   */
  export type WishlistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * The data used to update Wishlists.
     */
    data: XOR<WishlistUpdateManyMutationInput, WishlistUncheckedUpdateManyInput>;
    /**
     * Filter which Wishlists to update
     */
    where?: WishlistWhereInput;
    /**
     * Limit how many Wishlists to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Wishlist upsert
   */
  export type WishlistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * The filter to search for the Wishlist to update in case it exists.
     */
    where: WishlistWhereUniqueInput;
    /**
     * In case the Wishlist found by the `where` argument doesn't exist, create a new Wishlist with this data.
     */
    create: XOR<WishlistCreateInput, WishlistUncheckedCreateInput>;
    /**
     * In case the Wishlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WishlistUpdateInput, WishlistUncheckedUpdateInput>;
  };

  /**
   * Wishlist delete
   */
  export type WishlistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
    /**
     * Filter which Wishlist to delete.
     */
    where: WishlistWhereUniqueInput;
  };

  /**
   * Wishlist deleteMany
   */
  export type WishlistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wishlists to delete
     */
    where?: WishlistWhereInput;
    /**
     * Limit how many Wishlists to delete.
     */
    limit?: number;
  };

  /**
   * Wishlist.items
   */
  export type Wishlist$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null;
    where?: WishlistItemWhereInput;
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[];
    cursor?: WishlistItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[];
  };

  /**
   * Wishlist without action
   */
  export type WishlistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null;
  };

  /**
   * Model WishlistItem
   */

  export type AggregateWishlistItem = {
    _count: WishlistItemCountAggregateOutputType | null;
    _avg: WishlistItemAvgAggregateOutputType | null;
    _sum: WishlistItemSumAggregateOutputType | null;
    _min: WishlistItemMinAggregateOutputType | null;
    _max: WishlistItemMaxAggregateOutputType | null;
  };

  export type WishlistItemAvgAggregateOutputType = {
    id: number | null;
    wishlistId: number | null;
    productId: number | null;
    variantId: number | null;
  };

  export type WishlistItemSumAggregateOutputType = {
    id: number | null;
    wishlistId: number | null;
    productId: number | null;
    variantId: number | null;
  };

  export type WishlistItemMinAggregateOutputType = {
    id: number | null;
    wishlistId: number | null;
    productId: number | null;
    variantId: number | null;
    createdAt: Date | null;
  };

  export type WishlistItemMaxAggregateOutputType = {
    id: number | null;
    wishlistId: number | null;
    productId: number | null;
    variantId: number | null;
    createdAt: Date | null;
  };

  export type WishlistItemCountAggregateOutputType = {
    id: number;
    wishlistId: number;
    productId: number;
    variantId: number;
    createdAt: number;
    _all: number;
  };

  export type WishlistItemAvgAggregateInputType = {
    id?: true;
    wishlistId?: true;
    productId?: true;
    variantId?: true;
  };

  export type WishlistItemSumAggregateInputType = {
    id?: true;
    wishlistId?: true;
    productId?: true;
    variantId?: true;
  };

  export type WishlistItemMinAggregateInputType = {
    id?: true;
    wishlistId?: true;
    productId?: true;
    variantId?: true;
    createdAt?: true;
  };

  export type WishlistItemMaxAggregateInputType = {
    id?: true;
    wishlistId?: true;
    productId?: true;
    variantId?: true;
    createdAt?: true;
  };

  export type WishlistItemCountAggregateInputType = {
    id?: true;
    wishlistId?: true;
    productId?: true;
    variantId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type WishlistItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishlistItem to aggregate.
     */
    where?: WishlistItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: WishlistItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WishlistItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned WishlistItems
     **/
    _count?: true | WishlistItemCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: WishlistItemAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: WishlistItemSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: WishlistItemMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: WishlistItemMaxAggregateInputType;
  };

  export type GetWishlistItemAggregateType<T extends WishlistItemAggregateArgs> = {
    [P in keyof T & keyof AggregateWishlistItem]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlistItem[P]>
      : GetScalarType<T[P], AggregateWishlistItem[P]>;
  };

  export type WishlistItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput;
    orderBy?: WishlistItemOrderByWithAggregationInput | WishlistItemOrderByWithAggregationInput[];
    by: WishlistItemScalarFieldEnum[] | WishlistItemScalarFieldEnum;
    having?: WishlistItemScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: WishlistItemCountAggregateInputType | true;
    _avg?: WishlistItemAvgAggregateInputType;
    _sum?: WishlistItemSumAggregateInputType;
    _min?: WishlistItemMinAggregateInputType;
    _max?: WishlistItemMaxAggregateInputType;
  };

  export type WishlistItemGroupByOutputType = {
    id: number;
    wishlistId: number;
    productId: number;
    variantId: number | null;
    createdAt: Date;
    _count: WishlistItemCountAggregateOutputType | null;
    _avg: WishlistItemAvgAggregateOutputType | null;
    _sum: WishlistItemSumAggregateOutputType | null;
    _min: WishlistItemMinAggregateOutputType | null;
    _max: WishlistItemMaxAggregateOutputType | null;
  };

  type GetWishlistItemGroupByPayload<T extends WishlistItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WishlistItemGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof WishlistItemGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], WishlistItemGroupByOutputType[P]>
          : GetScalarType<T[P], WishlistItemGroupByOutputType[P]>;
      }
    >
  >;

  export type WishlistItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        wishlistId?: boolean;
        productId?: boolean;
        variantId?: boolean;
        createdAt?: boolean;
        wishlist?: boolean | WishlistDefaultArgs<ExtArgs>;
        product?: boolean | ProductDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["wishlistItem"]
    >;

  export type WishlistItemSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      wishlistId?: boolean;
      productId?: boolean;
      variantId?: boolean;
      createdAt?: boolean;
      wishlist?: boolean | WishlistDefaultArgs<ExtArgs>;
      product?: boolean | ProductDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["wishlistItem"]
  >;

  export type WishlistItemSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      wishlistId?: boolean;
      productId?: boolean;
      variantId?: boolean;
      createdAt?: boolean;
      wishlist?: boolean | WishlistDefaultArgs<ExtArgs>;
      product?: boolean | ProductDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["wishlistItem"]
  >;

  export type WishlistItemSelectScalar = {
    id?: boolean;
    wishlistId?: boolean;
    productId?: boolean;
    variantId?: boolean;
    createdAt?: boolean;
  };

  export type WishlistItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      "id" | "wishlistId" | "productId" | "variantId" | "createdAt",
      ExtArgs["result"]["wishlistItem"]
    >;
  export type WishlistItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wishlist?: boolean | WishlistDefaultArgs<ExtArgs>;
    product?: boolean | ProductDefaultArgs<ExtArgs>;
  };
  export type WishlistItemIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    wishlist?: boolean | WishlistDefaultArgs<ExtArgs>;
    product?: boolean | ProductDefaultArgs<ExtArgs>;
  };
  export type WishlistItemIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    wishlist?: boolean | WishlistDefaultArgs<ExtArgs>;
    product?: boolean | ProductDefaultArgs<ExtArgs>;
  };

  export type $WishlistItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WishlistItem";
    objects: {
      wishlist: Prisma.$WishlistPayload<ExtArgs>;
      product: Prisma.$ProductPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        wishlistId: number;
        productId: number;
        variantId: number | null;
        createdAt: Date;
      },
      ExtArgs["result"]["wishlistItem"]
    >;
    composites: {};
  };

  type WishlistItemGetPayload<S extends boolean | null | undefined | WishlistItemDefaultArgs> = $Result.GetResult<
    Prisma.$WishlistItemPayload,
    S
  >;

  type WishlistItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    WishlistItemFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: WishlistItemCountAggregateInputType | true;
  };

  export interface WishlistItemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["WishlistItem"];
      meta: { name: "WishlistItem" };
    };
    /**
     * Find zero or one WishlistItem that matches the filter.
     * @param {WishlistItemFindUniqueArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WishlistItemFindUniqueArgs>(
      args: SelectSubset<T, WishlistItemFindUniqueArgs<ExtArgs>>
    ): Prisma__WishlistItemClient<
      $Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one WishlistItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WishlistItemFindUniqueOrThrowArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WishlistItemFindUniqueOrThrowArgs>(
      args: SelectSubset<T, WishlistItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WishlistItemClient<
      $Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first WishlistItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindFirstArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WishlistItemFindFirstArgs>(
      args?: SelectSubset<T, WishlistItemFindFirstArgs<ExtArgs>>
    ): Prisma__WishlistItemClient<
      $Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first WishlistItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindFirstOrThrowArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WishlistItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WishlistItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WishlistItemClient<
      $Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more WishlistItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WishlistItems
     * const wishlistItems = await prisma.wishlistItem.findMany()
     *
     * // Get first 10 WishlistItems
     * const wishlistItems = await prisma.wishlistItem.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const wishlistItemWithIdOnly = await prisma.wishlistItem.findMany({ select: { id: true } })
     *
     */
    findMany<T extends WishlistItemFindManyArgs>(
      args?: SelectSubset<T, WishlistItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a WishlistItem.
     * @param {WishlistItemCreateArgs} args - Arguments to create a WishlistItem.
     * @example
     * // Create one WishlistItem
     * const WishlistItem = await prisma.wishlistItem.create({
     *   data: {
     *     // ... data to create a WishlistItem
     *   }
     * })
     *
     */
    create<T extends WishlistItemCreateArgs>(
      args: SelectSubset<T, WishlistItemCreateArgs<ExtArgs>>
    ): Prisma__WishlistItemClient<
      $Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many WishlistItems.
     * @param {WishlistItemCreateManyArgs} args - Arguments to create many WishlistItems.
     * @example
     * // Create many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends WishlistItemCreateManyArgs>(
      args?: SelectSubset<T, WishlistItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many WishlistItems and returns the data saved in the database.
     * @param {WishlistItemCreateManyAndReturnArgs} args - Arguments to create many WishlistItems.
     * @example
     * // Create many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many WishlistItems and only return the `id`
     * const wishlistItemWithIdOnly = await prisma.wishlistItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends WishlistItemCreateManyAndReturnArgs>(
      args?: SelectSubset<T, WishlistItemCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a WishlistItem.
     * @param {WishlistItemDeleteArgs} args - Arguments to delete one WishlistItem.
     * @example
     * // Delete one WishlistItem
     * const WishlistItem = await prisma.wishlistItem.delete({
     *   where: {
     *     // ... filter to delete one WishlistItem
     *   }
     * })
     *
     */
    delete<T extends WishlistItemDeleteArgs>(
      args: SelectSubset<T, WishlistItemDeleteArgs<ExtArgs>>
    ): Prisma__WishlistItemClient<
      $Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one WishlistItem.
     * @param {WishlistItemUpdateArgs} args - Arguments to update one WishlistItem.
     * @example
     * // Update one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends WishlistItemUpdateArgs>(
      args: SelectSubset<T, WishlistItemUpdateArgs<ExtArgs>>
    ): Prisma__WishlistItemClient<
      $Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more WishlistItems.
     * @param {WishlistItemDeleteManyArgs} args - Arguments to filter WishlistItems to delete.
     * @example
     * // Delete a few WishlistItems
     * const { count } = await prisma.wishlistItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends WishlistItemDeleteManyArgs>(
      args?: SelectSubset<T, WishlistItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more WishlistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends WishlistItemUpdateManyArgs>(
      args: SelectSubset<T, WishlistItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more WishlistItems and returns the data updated in the database.
     * @param {WishlistItemUpdateManyAndReturnArgs} args - Arguments to update many WishlistItems.
     * @example
     * // Update many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more WishlistItems and only return the `id`
     * const wishlistItemWithIdOnly = await prisma.wishlistItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends WishlistItemUpdateManyAndReturnArgs>(
      args: SelectSubset<T, WishlistItemUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one WishlistItem.
     * @param {WishlistItemUpsertArgs} args - Arguments to update or create a WishlistItem.
     * @example
     * // Update or create a WishlistItem
     * const wishlistItem = await prisma.wishlistItem.upsert({
     *   create: {
     *     // ... data to create a WishlistItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WishlistItem we want to update
     *   }
     * })
     */
    upsert<T extends WishlistItemUpsertArgs>(
      args: SelectSubset<T, WishlistItemUpsertArgs<ExtArgs>>
    ): Prisma__WishlistItemClient<
      $Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of WishlistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemCountArgs} args - Arguments to filter WishlistItems to count.
     * @example
     * // Count the number of WishlistItems
     * const count = await prisma.wishlistItem.count({
     *   where: {
     *     // ... the filter for the WishlistItems we want to count
     *   }
     * })
     **/
    count<T extends WishlistItemCountArgs>(
      args?: Subset<T, WishlistItemCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], WishlistItemCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a WishlistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends WishlistItemAggregateArgs>(
      args: Subset<T, WishlistItemAggregateArgs>
    ): Prisma.PrismaPromise<GetWishlistItemAggregateType<T>>;

    /**
     * Group by WishlistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends WishlistItemGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistItemGroupByArgs["orderBy"] }
        : { orderBy?: WishlistItemGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, WishlistItemGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetWishlistItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the WishlistItem model
     */
    readonly fields: WishlistItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WishlistItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WishlistItemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    wishlist<T extends WishlistDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, WishlistDefaultArgs<ExtArgs>>
    ): Prisma__WishlistClient<
      $Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ProductDefaultArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the WishlistItem model
   */
  interface WishlistItemFieldRefs {
    readonly id: FieldRef<"WishlistItem", "Int">;
    readonly wishlistId: FieldRef<"WishlistItem", "Int">;
    readonly productId: FieldRef<"WishlistItem", "Int">;
    readonly variantId: FieldRef<"WishlistItem", "Int">;
    readonly createdAt: FieldRef<"WishlistItem", "DateTime">;
  }

  // Custom InputTypes
  /**
   * WishlistItem findUnique
   */
  export type WishlistItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null;
    /**
     * Filter, which WishlistItem to fetch.
     */
    where: WishlistItemWhereUniqueInput;
  };

  /**
   * WishlistItem findUniqueOrThrow
   */
  export type WishlistItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null;
    /**
     * Filter, which WishlistItem to fetch.
     */
    where: WishlistItemWhereUniqueInput;
  };

  /**
   * WishlistItem findFirst
   */
  export type WishlistItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null;
    /**
     * Filter, which WishlistItem to fetch.
     */
    where?: WishlistItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WishlistItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of WishlistItems.
     */
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[];
  };

  /**
   * WishlistItem findFirstOrThrow
   */
  export type WishlistItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null;
    /**
     * Filter, which WishlistItem to fetch.
     */
    where?: WishlistItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WishlistItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of WishlistItems.
     */
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[];
  };

  /**
   * WishlistItem findMany
   */
  export type WishlistItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null;
    /**
     * Filter, which WishlistItems to fetch.
     */
    where?: WishlistItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WishlistItems.
     */
    skip?: number;
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[];
  };

  /**
   * WishlistItem create
   */
  export type WishlistItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null;
    /**
     * The data needed to create a WishlistItem.
     */
    data: XOR<WishlistItemCreateInput, WishlistItemUncheckedCreateInput>;
  };

  /**
   * WishlistItem createMany
   */
  export type WishlistItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WishlistItems.
     */
    data: WishlistItemCreateManyInput | WishlistItemCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * WishlistItem createManyAndReturn
   */
  export type WishlistItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the WishlistItem
       */
      select?: WishlistItemSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the WishlistItem
       */
      omit?: WishlistItemOmit<ExtArgs> | null;
      /**
       * The data used to create many WishlistItems.
       */
      data: WishlistItemCreateManyInput | WishlistItemCreateManyInput[];
      skipDuplicates?: boolean;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: WishlistItemIncludeCreateManyAndReturn<ExtArgs> | null;
    };

  /**
   * WishlistItem update
   */
  export type WishlistItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null;
    /**
     * The data needed to update a WishlistItem.
     */
    data: XOR<WishlistItemUpdateInput, WishlistItemUncheckedUpdateInput>;
    /**
     * Choose, which WishlistItem to update.
     */
    where: WishlistItemWhereUniqueInput;
  };

  /**
   * WishlistItem updateMany
   */
  export type WishlistItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WishlistItems.
     */
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyInput>;
    /**
     * Filter which WishlistItems to update
     */
    where?: WishlistItemWhereInput;
    /**
     * Limit how many WishlistItems to update.
     */
    limit?: number;
  };

  /**
   * WishlistItem updateManyAndReturn
   */
  export type WishlistItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the WishlistItem
       */
      select?: WishlistItemSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the WishlistItem
       */
      omit?: WishlistItemOmit<ExtArgs> | null;
      /**
       * The data used to update WishlistItems.
       */
      data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyInput>;
      /**
       * Filter which WishlistItems to update
       */
      where?: WishlistItemWhereInput;
      /**
       * Limit how many WishlistItems to update.
       */
      limit?: number;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: WishlistItemIncludeUpdateManyAndReturn<ExtArgs> | null;
    };

  /**
   * WishlistItem upsert
   */
  export type WishlistItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null;
    /**
     * The filter to search for the WishlistItem to update in case it exists.
     */
    where: WishlistItemWhereUniqueInput;
    /**
     * In case the WishlistItem found by the `where` argument doesn't exist, create a new WishlistItem with this data.
     */
    create: XOR<WishlistItemCreateInput, WishlistItemUncheckedCreateInput>;
    /**
     * In case the WishlistItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WishlistItemUpdateInput, WishlistItemUncheckedUpdateInput>;
  };

  /**
   * WishlistItem delete
   */
  export type WishlistItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null;
    /**
     * Filter which WishlistItem to delete.
     */
    where: WishlistItemWhereUniqueInput;
  };

  /**
   * WishlistItem deleteMany
   */
  export type WishlistItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishlistItems to delete
     */
    where?: WishlistItemWhereInput;
    /**
     * Limit how many WishlistItems to delete.
     */
    limit?: number;
  };

  /**
   * WishlistItem without action
   */
  export type WishlistItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null;
  };

  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null;
    _avg: AddressAvgAggregateOutputType | null;
    _sum: AddressSumAggregateOutputType | null;
    _min: AddressMinAggregateOutputType | null;
    _max: AddressMaxAggregateOutputType | null;
  };

  export type AddressAvgAggregateOutputType = {
    id: number | null;
    userId: number | null;
  };

  export type AddressSumAggregateOutputType = {
    id: number | null;
    userId: number | null;
  };

  export type AddressMinAggregateOutputType = {
    id: number | null;
    userId: number | null;
    fullName: string | null;
    line1: string | null;
    line2: string | null;
    city: string | null;
    province: string | null;
    postalCode: string | null;
    country: string | null;
    phone: string | null;
    isDefaultShipping: boolean | null;
    isDefaultBilling: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AddressMaxAggregateOutputType = {
    id: number | null;
    userId: number | null;
    fullName: string | null;
    line1: string | null;
    line2: string | null;
    city: string | null;
    province: string | null;
    postalCode: string | null;
    country: string | null;
    phone: string | null;
    isDefaultShipping: boolean | null;
    isDefaultBilling: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AddressCountAggregateOutputType = {
    id: number;
    userId: number;
    fullName: number;
    line1: number;
    line2: number;
    city: number;
    province: number;
    postalCode: number;
    country: number;
    phone: number;
    metadata: number;
    isDefaultShipping: number;
    isDefaultBilling: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type AddressAvgAggregateInputType = {
    id?: true;
    userId?: true;
  };

  export type AddressSumAggregateInputType = {
    id?: true;
    userId?: true;
  };

  export type AddressMinAggregateInputType = {
    id?: true;
    userId?: true;
    fullName?: true;
    line1?: true;
    line2?: true;
    city?: true;
    province?: true;
    postalCode?: true;
    country?: true;
    phone?: true;
    isDefaultShipping?: true;
    isDefaultBilling?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AddressMaxAggregateInputType = {
    id?: true;
    userId?: true;
    fullName?: true;
    line1?: true;
    line2?: true;
    city?: true;
    province?: true;
    postalCode?: true;
    country?: true;
    phone?: true;
    isDefaultShipping?: true;
    isDefaultBilling?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AddressCountAggregateInputType = {
    id?: true;
    userId?: true;
    fullName?: true;
    line1?: true;
    line2?: true;
    city?: true;
    province?: true;
    postalCode?: true;
    country?: true;
    phone?: true;
    metadata?: true;
    isDefaultShipping?: true;
    isDefaultBilling?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Addresses
     **/
    _count?: true | AddressCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AddressAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AddressSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AddressMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AddressMaxAggregateInputType;
  };

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
    [P in keyof T & keyof AggregateAddress]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>;
  };

  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[];
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum;
    having?: AddressScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AddressCountAggregateInputType | true;
    _avg?: AddressAvgAggregateInputType;
    _sum?: AddressSumAggregateInputType;
    _min?: AddressMinAggregateInputType;
    _max?: AddressMaxAggregateInputType;
  };

  export type AddressGroupByOutputType = {
    id: number;
    userId: number | null;
    fullName: string;
    line1: string;
    line2: string | null;
    city: string;
    province: string | null;
    postalCode: string | null;
    country: string;
    phone: string | null;
    metadata: JsonValue | null;
    isDefaultShipping: boolean;
    isDefaultBilling: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: AddressCountAggregateOutputType | null;
    _avg: AddressAvgAggregateOutputType | null;
    _sum: AddressSumAggregateOutputType | null;
    _min: AddressMinAggregateOutputType | null;
    _max: AddressMaxAggregateOutputType | null;
  };

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof AddressGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
          : GetScalarType<T[P], AddressGroupByOutputType[P]>;
      }
    >
  >;

  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      fullName?: boolean;
      line1?: boolean;
      line2?: boolean;
      city?: boolean;
      province?: boolean;
      postalCode?: boolean;
      country?: boolean;
      phone?: boolean;
      metadata?: boolean;
      isDefaultShipping?: boolean;
      isDefaultBilling?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | Address$userArgs<ExtArgs>;
      ordersShipping?: boolean | Address$ordersShippingArgs<ExtArgs>;
      ordersBilling?: boolean | Address$ordersBillingArgs<ExtArgs>;
      _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["address"]
  >;

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        fullName?: boolean;
        line1?: boolean;
        line2?: boolean;
        city?: boolean;
        province?: boolean;
        postalCode?: boolean;
        country?: boolean;
        phone?: boolean;
        metadata?: boolean;
        isDefaultShipping?: boolean;
        isDefaultBilling?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        user?: boolean | Address$userArgs<ExtArgs>;
      },
      ExtArgs["result"]["address"]
    >;

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        fullName?: boolean;
        line1?: boolean;
        line2?: boolean;
        city?: boolean;
        province?: boolean;
        postalCode?: boolean;
        country?: boolean;
        phone?: boolean;
        metadata?: boolean;
        isDefaultShipping?: boolean;
        isDefaultBilling?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        user?: boolean | Address$userArgs<ExtArgs>;
      },
      ExtArgs["result"]["address"]
    >;

  export type AddressSelectScalar = {
    id?: boolean;
    userId?: boolean;
    fullName?: boolean;
    line1?: boolean;
    line2?: boolean;
    city?: boolean;
    province?: boolean;
    postalCode?: boolean;
    country?: boolean;
    phone?: boolean;
    metadata?: boolean;
    isDefaultShipping?: boolean;
    isDefaultBilling?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    | "id"
    | "userId"
    | "fullName"
    | "line1"
    | "line2"
    | "city"
    | "province"
    | "postalCode"
    | "country"
    | "phone"
    | "metadata"
    | "isDefaultShipping"
    | "isDefaultBilling"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["address"]
  >;
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Address$userArgs<ExtArgs>;
    ordersShipping?: boolean | Address$ordersShippingArgs<ExtArgs>;
    ordersBilling?: boolean | Address$ordersBillingArgs<ExtArgs>;
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Address$userArgs<ExtArgs>;
  };
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Address$userArgs<ExtArgs>;
  };

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address";
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null;
      ordersShipping: Prisma.$OrderPayload<ExtArgs>[];
      ordersBilling: Prisma.$OrderPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        userId: number | null;
        fullName: string;
        line1: string;
        line2: string | null;
        city: string;
        province: string | null;
        postalCode: string | null;
        country: string;
        phone: string | null;
        metadata: Prisma.JsonValue | null;
        isDefaultShipping: boolean;
        isDefaultBilling: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["address"]
    >;
    composites: {};
  };

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<
    Prisma.$AddressPayload,
    S
  >;

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    AddressFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: AddressCountAggregateInputType | true;
  };

  export interface AddressDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["Address"]; meta: { name: "Address" } };
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(
      args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(
      args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     *
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AddressFindManyArgs>(
      args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     *
     */
    create<T extends AddressCreateArgs>(
      args: SelectSubset<T, AddressCreateArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AddressCreateManyArgs>(
      args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     *
     */
    delete<T extends AddressDeleteArgs>(
      args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AddressUpdateArgs>(
      args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AddressDeleteManyArgs>(
      args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AddressUpdateManyArgs>(
      args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(
      args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
     **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AddressCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AddressAggregateArgs>(
      args: Subset<T, AddressAggregateArgs>
    ): Prisma.PrismaPromise<GetAddressAggregateType<T>>;

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs["orderBy"] }
        : { orderBy?: AddressGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Address model
     */
    readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends Address$userArgs<ExtArgs> = {}>(
      args?: Subset<T, Address$userArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    ordersShipping<T extends Address$ordersShippingArgs<ExtArgs> = {}>(
      args?: Subset<T, Address$ordersShippingArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    ordersBilling<T extends Address$ordersBillingArgs<ExtArgs> = {}>(
      args?: Subset<T, Address$ordersBillingArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", "Int">;
    readonly userId: FieldRef<"Address", "Int">;
    readonly fullName: FieldRef<"Address", "String">;
    readonly line1: FieldRef<"Address", "String">;
    readonly line2: FieldRef<"Address", "String">;
    readonly city: FieldRef<"Address", "String">;
    readonly province: FieldRef<"Address", "String">;
    readonly postalCode: FieldRef<"Address", "String">;
    readonly country: FieldRef<"Address", "String">;
    readonly phone: FieldRef<"Address", "String">;
    readonly metadata: FieldRef<"Address", "Json">;
    readonly isDefaultShipping: FieldRef<"Address", "Boolean">;
    readonly isDefaultBilling: FieldRef<"Address", "Boolean">;
    readonly createdAt: FieldRef<"Address", "DateTime">;
    readonly updatedAt: FieldRef<"Address", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput;
  };

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput;
  };

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[];
  };

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[];
  };

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     */
    skip?: number;
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[];
  };

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>;
  };

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null;
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>;
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput;
  };

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>;
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput;
    /**
     * Limit how many Addresses to update.
     */
    limit?: number;
  };

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null;
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>;
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput;
    /**
     * Limit how many Addresses to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput;
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>;
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>;
  };

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput;
  };

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput;
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number;
  };

  /**
   * Address.user
   */
  export type Address$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Address.ordersShipping
   */
  export type Address$ordersShippingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    where?: OrderWhereInput;
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    cursor?: OrderWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Address.ordersBilling
   */
  export type Address$ordersBillingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    where?: OrderWhereInput;
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    cursor?: OrderWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
  };

  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null;
    _avg: AuditLogAvgAggregateOutputType | null;
    _sum: AuditLogSumAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  export type AuditLogAvgAggregateOutputType = {
    id: number | null;
    actorId: number | null;
  };

  export type AuditLogSumAggregateOutputType = {
    id: number | null;
    actorId: number | null;
  };

  export type AuditLogMinAggregateOutputType = {
    id: number | null;
    actorId: number | null;
    action: string | null;
    entity: string | null;
    entityId: string | null;
    ip: string | null;
    userAgent: string | null;
    createdAt: Date | null;
  };

  export type AuditLogMaxAggregateOutputType = {
    id: number | null;
    actorId: number | null;
    action: string | null;
    entity: string | null;
    entityId: string | null;
    ip: string | null;
    userAgent: string | null;
    createdAt: Date | null;
  };

  export type AuditLogCountAggregateOutputType = {
    id: number;
    actorId: number;
    action: number;
    entity: number;
    entityId: number;
    changes: number;
    ip: number;
    userAgent: number;
    createdAt: number;
    _all: number;
  };

  export type AuditLogAvgAggregateInputType = {
    id?: true;
    actorId?: true;
  };

  export type AuditLogSumAggregateInputType = {
    id?: true;
    actorId?: true;
  };

  export type AuditLogMinAggregateInputType = {
    id?: true;
    actorId?: true;
    action?: true;
    entity?: true;
    entityId?: true;
    ip?: true;
    userAgent?: true;
    createdAt?: true;
  };

  export type AuditLogMaxAggregateInputType = {
    id?: true;
    actorId?: true;
    action?: true;
    entity?: true;
    entityId?: true;
    ip?: true;
    userAgent?: true;
    createdAt?: true;
  };

  export type AuditLogCountAggregateInputType = {
    id?: true;
    actorId?: true;
    action?: true;
    entity?: true;
    entityId?: true;
    changes?: true;
    ip?: true;
    userAgent?: true;
    createdAt?: true;
    _all?: true;
  };

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AuditLogs
     **/
    _count?: true | AuditLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AuditLogAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AuditLogSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AuditLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AuditLogMaxAggregateInputType;
  };

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
    [P in keyof T & keyof AggregateAuditLog]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>;
  };

  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput;
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[];
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum;
    having?: AuditLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AuditLogCountAggregateInputType | true;
    _avg?: AuditLogAvgAggregateInputType;
    _sum?: AuditLogSumAggregateInputType;
    _min?: AuditLogMinAggregateInputType;
    _max?: AuditLogMaxAggregateInputType;
  };

  export type AuditLogGroupByOutputType = {
    id: number;
    actorId: number | null;
    action: string;
    entity: string;
    entityId: string | null;
    changes: JsonValue | null;
    ip: string | null;
    userAgent: string | null;
    createdAt: Date;
    _count: AuditLogCountAggregateOutputType | null;
    _avg: AuditLogAvgAggregateOutputType | null;
    _sum: AuditLogSumAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof AuditLogGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
          : GetScalarType<T[P], AuditLogGroupByOutputType[P]>;
      }
    >
  >;

  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        actorId?: boolean;
        action?: boolean;
        entity?: boolean;
        entityId?: boolean;
        changes?: boolean;
        ip?: boolean;
        userAgent?: boolean;
        createdAt?: boolean;
        actor?: boolean | AuditLog$actorArgs<ExtArgs>;
      },
      ExtArgs["result"]["auditLog"]
    >;

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        actorId?: boolean;
        action?: boolean;
        entity?: boolean;
        entityId?: boolean;
        changes?: boolean;
        ip?: boolean;
        userAgent?: boolean;
        createdAt?: boolean;
        actor?: boolean | AuditLog$actorArgs<ExtArgs>;
      },
      ExtArgs["result"]["auditLog"]
    >;

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        actorId?: boolean;
        action?: boolean;
        entity?: boolean;
        entityId?: boolean;
        changes?: boolean;
        ip?: boolean;
        userAgent?: boolean;
        createdAt?: boolean;
        actor?: boolean | AuditLog$actorArgs<ExtArgs>;
      },
      ExtArgs["result"]["auditLog"]
    >;

  export type AuditLogSelectScalar = {
    id?: boolean;
    actorId?: boolean;
    action?: boolean;
    entity?: boolean;
    entityId?: boolean;
    changes?: boolean;
    ip?: boolean;
    userAgent?: boolean;
    createdAt?: boolean;
  };

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    "id" | "actorId" | "action" | "entity" | "entityId" | "changes" | "ip" | "userAgent" | "createdAt",
    ExtArgs["result"]["auditLog"]
  >;
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>;
  };
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>;
  };
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>;
  };

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog";
    objects: {
      actor: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        actorId: number | null;
        action: string;
        entity: string;
        entityId: string | null;
        changes: Prisma.JsonValue | null;
        ip: string | null;
        userAgent: string | null;
        createdAt: Date;
      },
      ExtArgs["result"]["auditLog"]
    >;
    composites: {};
  };

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<
    Prisma.$AuditLogPayload,
    S
  >;

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    AuditLogFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: AuditLogCountAggregateInputType | true;
  };

  export interface AuditLogDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["AuditLog"];
      meta: { name: "AuditLog" };
    };
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(
      args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(
      args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     *
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AuditLogFindManyArgs>(
      args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     *
     */
    create<T extends AuditLogCreateArgs>(
      args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AuditLogCreateManyArgs>(
      args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     *
     */
    delete<T extends AuditLogDeleteArgs>(
      args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AuditLogUpdateArgs>(
      args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(
      args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AuditLogUpdateManyArgs>(
      args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(
      args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
     **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AuditLogCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AuditLogAggregateArgs>(
      args: Subset<T, AuditLogAggregateArgs>
    ): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>;

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs["orderBy"] }
        : { orderBy?: AuditLogGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AuditLog model
     */
    readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    actor<T extends AuditLog$actorArgs<ExtArgs> = {}>(
      args?: Subset<T, AuditLog$actorArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", "Int">;
    readonly actorId: FieldRef<"AuditLog", "Int">;
    readonly action: FieldRef<"AuditLog", "String">;
    readonly entity: FieldRef<"AuditLog", "String">;
    readonly entityId: FieldRef<"AuditLog", "String">;
    readonly changes: FieldRef<"AuditLog", "Json">;
    readonly ip: FieldRef<"AuditLog", "String">;
    readonly userAgent: FieldRef<"AuditLog", "String">;
    readonly createdAt: FieldRef<"AuditLog", "DateTime">;
  }

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
  };

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>;
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number;
  };

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>;
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput;
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
  };

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number;
  };

  /**
   * AuditLog.actor
   */
  export type AuditLog$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
  };

  /**
   * Model ReturnRequest
   */

  export type AggregateReturnRequest = {
    _count: ReturnRequestCountAggregateOutputType | null;
    _avg: ReturnRequestAvgAggregateOutputType | null;
    _sum: ReturnRequestSumAggregateOutputType | null;
    _min: ReturnRequestMinAggregateOutputType | null;
    _max: ReturnRequestMaxAggregateOutputType | null;
  };

  export type ReturnRequestAvgAggregateOutputType = {
    id: number | null;
    orderId: number | null;
    orderItemId: number | null;
  };

  export type ReturnRequestSumAggregateOutputType = {
    id: number | null;
    orderId: number | null;
    orderItemId: number | null;
  };

  export type ReturnRequestMinAggregateOutputType = {
    id: number | null;
    orderId: number | null;
    orderItemId: number | null;
    reason: string | null;
    status: $Enums.ReturnStatus | null;
    requestedAt: Date | null;
    processedAt: Date | null;
  };

  export type ReturnRequestMaxAggregateOutputType = {
    id: number | null;
    orderId: number | null;
    orderItemId: number | null;
    reason: string | null;
    status: $Enums.ReturnStatus | null;
    requestedAt: Date | null;
    processedAt: Date | null;
  };

  export type ReturnRequestCountAggregateOutputType = {
    id: number;
    orderId: number;
    orderItemId: number;
    reason: number;
    status: number;
    evidence: number;
    requestedAt: number;
    processedAt: number;
    metadata: number;
    _all: number;
  };

  export type ReturnRequestAvgAggregateInputType = {
    id?: true;
    orderId?: true;
    orderItemId?: true;
  };

  export type ReturnRequestSumAggregateInputType = {
    id?: true;
    orderId?: true;
    orderItemId?: true;
  };

  export type ReturnRequestMinAggregateInputType = {
    id?: true;
    orderId?: true;
    orderItemId?: true;
    reason?: true;
    status?: true;
    requestedAt?: true;
    processedAt?: true;
  };

  export type ReturnRequestMaxAggregateInputType = {
    id?: true;
    orderId?: true;
    orderItemId?: true;
    reason?: true;
    status?: true;
    requestedAt?: true;
    processedAt?: true;
  };

  export type ReturnRequestCountAggregateInputType = {
    id?: true;
    orderId?: true;
    orderItemId?: true;
    reason?: true;
    status?: true;
    evidence?: true;
    requestedAt?: true;
    processedAt?: true;
    metadata?: true;
    _all?: true;
  };

  export type ReturnRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnRequest to aggregate.
     */
    where?: ReturnRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ReturnRequests to fetch.
     */
    orderBy?: ReturnRequestOrderByWithRelationInput | ReturnRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ReturnRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ReturnRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ReturnRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ReturnRequests
     **/
    _count?: true | ReturnRequestCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ReturnRequestAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ReturnRequestSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ReturnRequestMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ReturnRequestMaxAggregateInputType;
  };

  export type GetReturnRequestAggregateType<T extends ReturnRequestAggregateArgs> = {
    [P in keyof T & keyof AggregateReturnRequest]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturnRequest[P]>
      : GetScalarType<T[P], AggregateReturnRequest[P]>;
  };

  export type ReturnRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnRequestWhereInput;
    orderBy?: ReturnRequestOrderByWithAggregationInput | ReturnRequestOrderByWithAggregationInput[];
    by: ReturnRequestScalarFieldEnum[] | ReturnRequestScalarFieldEnum;
    having?: ReturnRequestScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ReturnRequestCountAggregateInputType | true;
    _avg?: ReturnRequestAvgAggregateInputType;
    _sum?: ReturnRequestSumAggregateInputType;
    _min?: ReturnRequestMinAggregateInputType;
    _max?: ReturnRequestMaxAggregateInputType;
  };

  export type ReturnRequestGroupByOutputType = {
    id: number;
    orderId: number;
    orderItemId: number;
    reason: string;
    status: $Enums.ReturnStatus;
    evidence: JsonValue | null;
    requestedAt: Date;
    processedAt: Date | null;
    metadata: JsonValue | null;
    _count: ReturnRequestCountAggregateOutputType | null;
    _avg: ReturnRequestAvgAggregateOutputType | null;
    _sum: ReturnRequestSumAggregateOutputType | null;
    _min: ReturnRequestMinAggregateOutputType | null;
    _max: ReturnRequestMaxAggregateOutputType | null;
  };

  type GetReturnRequestGroupByPayload<T extends ReturnRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReturnRequestGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof ReturnRequestGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ReturnRequestGroupByOutputType[P]>
          : GetScalarType<T[P], ReturnRequestGroupByOutputType[P]>;
      }
    >
  >;

  export type ReturnRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        orderId?: boolean;
        orderItemId?: boolean;
        reason?: boolean;
        status?: boolean;
        evidence?: boolean;
        requestedAt?: boolean;
        processedAt?: boolean;
        metadata?: boolean;
        order?: boolean | OrderDefaultArgs<ExtArgs>;
        orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>;
        refund?: boolean | ReturnRequest$refundArgs<ExtArgs>;
      },
      ExtArgs["result"]["returnRequest"]
    >;

  export type ReturnRequestSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      orderId?: boolean;
      orderItemId?: boolean;
      reason?: boolean;
      status?: boolean;
      evidence?: boolean;
      requestedAt?: boolean;
      processedAt?: boolean;
      metadata?: boolean;
      order?: boolean | OrderDefaultArgs<ExtArgs>;
      orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["returnRequest"]
  >;

  export type ReturnRequestSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      orderId?: boolean;
      orderItemId?: boolean;
      reason?: boolean;
      status?: boolean;
      evidence?: boolean;
      requestedAt?: boolean;
      processedAt?: boolean;
      metadata?: boolean;
      order?: boolean | OrderDefaultArgs<ExtArgs>;
      orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["returnRequest"]
  >;

  export type ReturnRequestSelectScalar = {
    id?: boolean;
    orderId?: boolean;
    orderItemId?: boolean;
    reason?: boolean;
    status?: boolean;
    evidence?: boolean;
    requestedAt?: boolean;
    processedAt?: boolean;
    metadata?: boolean;
  };

  export type ReturnRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      "id" | "orderId" | "orderItemId" | "reason" | "status" | "evidence" | "requestedAt" | "processedAt" | "metadata",
      ExtArgs["result"]["returnRequest"]
    >;
  export type ReturnRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>;
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>;
    refund?: boolean | ReturnRequest$refundArgs<ExtArgs>;
  };
  export type ReturnRequestIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    order?: boolean | OrderDefaultArgs<ExtArgs>;
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>;
  };
  export type ReturnRequestIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    order?: boolean | OrderDefaultArgs<ExtArgs>;
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>;
  };

  export type $ReturnRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReturnRequest";
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>;
      orderItem: Prisma.$OrderItemPayload<ExtArgs>;
      refund: Prisma.$RefundPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        orderId: number;
        orderItemId: number;
        reason: string;
        status: $Enums.ReturnStatus;
        evidence: Prisma.JsonValue | null;
        requestedAt: Date;
        processedAt: Date | null;
        metadata: Prisma.JsonValue | null;
      },
      ExtArgs["result"]["returnRequest"]
    >;
    composites: {};
  };

  type ReturnRequestGetPayload<S extends boolean | null | undefined | ReturnRequestDefaultArgs> = $Result.GetResult<
    Prisma.$ReturnRequestPayload,
    S
  >;

  type ReturnRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ReturnRequestFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ReturnRequestCountAggregateInputType | true;
  };

  export interface ReturnRequestDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["ReturnRequest"];
      meta: { name: "ReturnRequest" };
    };
    /**
     * Find zero or one ReturnRequest that matches the filter.
     * @param {ReturnRequestFindUniqueArgs} args - Arguments to find a ReturnRequest
     * @example
     * // Get one ReturnRequest
     * const returnRequest = await prisma.returnRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReturnRequestFindUniqueArgs>(
      args: SelectSubset<T, ReturnRequestFindUniqueArgs<ExtArgs>>
    ): Prisma__ReturnRequestClient<
      $Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ReturnRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReturnRequestFindUniqueOrThrowArgs} args - Arguments to find a ReturnRequest
     * @example
     * // Get one ReturnRequest
     * const returnRequest = await prisma.returnRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReturnRequestFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ReturnRequestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReturnRequestClient<
      $Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ReturnRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestFindFirstArgs} args - Arguments to find a ReturnRequest
     * @example
     * // Get one ReturnRequest
     * const returnRequest = await prisma.returnRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReturnRequestFindFirstArgs>(
      args?: SelectSubset<T, ReturnRequestFindFirstArgs<ExtArgs>>
    ): Prisma__ReturnRequestClient<
      $Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ReturnRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestFindFirstOrThrowArgs} args - Arguments to find a ReturnRequest
     * @example
     * // Get one ReturnRequest
     * const returnRequest = await prisma.returnRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReturnRequestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReturnRequestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReturnRequestClient<
      $Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ReturnRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReturnRequests
     * const returnRequests = await prisma.returnRequest.findMany()
     *
     * // Get first 10 ReturnRequests
     * const returnRequests = await prisma.returnRequest.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const returnRequestWithIdOnly = await prisma.returnRequest.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ReturnRequestFindManyArgs>(
      args?: SelectSubset<T, ReturnRequestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a ReturnRequest.
     * @param {ReturnRequestCreateArgs} args - Arguments to create a ReturnRequest.
     * @example
     * // Create one ReturnRequest
     * const ReturnRequest = await prisma.returnRequest.create({
     *   data: {
     *     // ... data to create a ReturnRequest
     *   }
     * })
     *
     */
    create<T extends ReturnRequestCreateArgs>(
      args: SelectSubset<T, ReturnRequestCreateArgs<ExtArgs>>
    ): Prisma__ReturnRequestClient<
      $Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ReturnRequests.
     * @param {ReturnRequestCreateManyArgs} args - Arguments to create many ReturnRequests.
     * @example
     * // Create many ReturnRequests
     * const returnRequest = await prisma.returnRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ReturnRequestCreateManyArgs>(
      args?: SelectSubset<T, ReturnRequestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ReturnRequests and returns the data saved in the database.
     * @param {ReturnRequestCreateManyAndReturnArgs} args - Arguments to create many ReturnRequests.
     * @example
     * // Create many ReturnRequests
     * const returnRequest = await prisma.returnRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ReturnRequests and only return the `id`
     * const returnRequestWithIdOnly = await prisma.returnRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ReturnRequestCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ReturnRequestCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a ReturnRequest.
     * @param {ReturnRequestDeleteArgs} args - Arguments to delete one ReturnRequest.
     * @example
     * // Delete one ReturnRequest
     * const ReturnRequest = await prisma.returnRequest.delete({
     *   where: {
     *     // ... filter to delete one ReturnRequest
     *   }
     * })
     *
     */
    delete<T extends ReturnRequestDeleteArgs>(
      args: SelectSubset<T, ReturnRequestDeleteArgs<ExtArgs>>
    ): Prisma__ReturnRequestClient<
      $Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ReturnRequest.
     * @param {ReturnRequestUpdateArgs} args - Arguments to update one ReturnRequest.
     * @example
     * // Update one ReturnRequest
     * const returnRequest = await prisma.returnRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ReturnRequestUpdateArgs>(
      args: SelectSubset<T, ReturnRequestUpdateArgs<ExtArgs>>
    ): Prisma__ReturnRequestClient<
      $Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ReturnRequests.
     * @param {ReturnRequestDeleteManyArgs} args - Arguments to filter ReturnRequests to delete.
     * @example
     * // Delete a few ReturnRequests
     * const { count } = await prisma.returnRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ReturnRequestDeleteManyArgs>(
      args?: SelectSubset<T, ReturnRequestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ReturnRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReturnRequests
     * const returnRequest = await prisma.returnRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ReturnRequestUpdateManyArgs>(
      args: SelectSubset<T, ReturnRequestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ReturnRequests and returns the data updated in the database.
     * @param {ReturnRequestUpdateManyAndReturnArgs} args - Arguments to update many ReturnRequests.
     * @example
     * // Update many ReturnRequests
     * const returnRequest = await prisma.returnRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ReturnRequests and only return the `id`
     * const returnRequestWithIdOnly = await prisma.returnRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ReturnRequestUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ReturnRequestUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one ReturnRequest.
     * @param {ReturnRequestUpsertArgs} args - Arguments to update or create a ReturnRequest.
     * @example
     * // Update or create a ReturnRequest
     * const returnRequest = await prisma.returnRequest.upsert({
     *   create: {
     *     // ... data to create a ReturnRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReturnRequest we want to update
     *   }
     * })
     */
    upsert<T extends ReturnRequestUpsertArgs>(
      args: SelectSubset<T, ReturnRequestUpsertArgs<ExtArgs>>
    ): Prisma__ReturnRequestClient<
      $Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ReturnRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestCountArgs} args - Arguments to filter ReturnRequests to count.
     * @example
     * // Count the number of ReturnRequests
     * const count = await prisma.returnRequest.count({
     *   where: {
     *     // ... the filter for the ReturnRequests we want to count
     *   }
     * })
     **/
    count<T extends ReturnRequestCountArgs>(
      args?: Subset<T, ReturnRequestCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ReturnRequestCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ReturnRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ReturnRequestAggregateArgs>(
      args: Subset<T, ReturnRequestAggregateArgs>
    ): Prisma.PrismaPromise<GetReturnRequestAggregateType<T>>;

    /**
     * Group by ReturnRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ReturnRequestGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReturnRequestGroupByArgs["orderBy"] }
        : { orderBy?: ReturnRequestGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ReturnRequestGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetReturnRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ReturnRequest model
     */
    readonly fields: ReturnRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReturnRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReturnRequestClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrderDefaultArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    orderItem<T extends OrderItemDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrderItemDefaultArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    refund<T extends ReturnRequest$refundArgs<ExtArgs> = {}>(
      args?: Subset<T, ReturnRequest$refundArgs<ExtArgs>>
    ): Prisma__RefundClient<
      $Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ReturnRequest model
   */
  interface ReturnRequestFieldRefs {
    readonly id: FieldRef<"ReturnRequest", "Int">;
    readonly orderId: FieldRef<"ReturnRequest", "Int">;
    readonly orderItemId: FieldRef<"ReturnRequest", "Int">;
    readonly reason: FieldRef<"ReturnRequest", "String">;
    readonly status: FieldRef<"ReturnRequest", "ReturnStatus">;
    readonly evidence: FieldRef<"ReturnRequest", "Json">;
    readonly requestedAt: FieldRef<"ReturnRequest", "DateTime">;
    readonly processedAt: FieldRef<"ReturnRequest", "DateTime">;
    readonly metadata: FieldRef<"ReturnRequest", "Json">;
  }

  // Custom InputTypes
  /**
   * ReturnRequest findUnique
   */
  export type ReturnRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null;
    /**
     * Filter, which ReturnRequest to fetch.
     */
    where: ReturnRequestWhereUniqueInput;
  };

  /**
   * ReturnRequest findUniqueOrThrow
   */
  export type ReturnRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null;
    /**
     * Filter, which ReturnRequest to fetch.
     */
    where: ReturnRequestWhereUniqueInput;
  };

  /**
   * ReturnRequest findFirst
   */
  export type ReturnRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null;
    /**
     * Filter, which ReturnRequest to fetch.
     */
    where?: ReturnRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ReturnRequests to fetch.
     */
    orderBy?: ReturnRequestOrderByWithRelationInput | ReturnRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ReturnRequests.
     */
    cursor?: ReturnRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ReturnRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ReturnRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ReturnRequests.
     */
    distinct?: ReturnRequestScalarFieldEnum | ReturnRequestScalarFieldEnum[];
  };

  /**
   * ReturnRequest findFirstOrThrow
   */
  export type ReturnRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null;
    /**
     * Filter, which ReturnRequest to fetch.
     */
    where?: ReturnRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ReturnRequests to fetch.
     */
    orderBy?: ReturnRequestOrderByWithRelationInput | ReturnRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ReturnRequests.
     */
    cursor?: ReturnRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ReturnRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ReturnRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ReturnRequests.
     */
    distinct?: ReturnRequestScalarFieldEnum | ReturnRequestScalarFieldEnum[];
  };

  /**
   * ReturnRequest findMany
   */
  export type ReturnRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null;
    /**
     * Filter, which ReturnRequests to fetch.
     */
    where?: ReturnRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ReturnRequests to fetch.
     */
    orderBy?: ReturnRequestOrderByWithRelationInput | ReturnRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ReturnRequests.
     */
    cursor?: ReturnRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ReturnRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ReturnRequests.
     */
    skip?: number;
    distinct?: ReturnRequestScalarFieldEnum | ReturnRequestScalarFieldEnum[];
  };

  /**
   * ReturnRequest create
   */
  export type ReturnRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null;
    /**
     * The data needed to create a ReturnRequest.
     */
    data: XOR<ReturnRequestCreateInput, ReturnRequestUncheckedCreateInput>;
  };

  /**
   * ReturnRequest createMany
   */
  export type ReturnRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReturnRequests.
     */
    data: ReturnRequestCreateManyInput | ReturnRequestCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ReturnRequest createManyAndReturn
   */
  export type ReturnRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the ReturnRequest
       */
      select?: ReturnRequestSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the ReturnRequest
       */
      omit?: ReturnRequestOmit<ExtArgs> | null;
      /**
       * The data used to create many ReturnRequests.
       */
      data: ReturnRequestCreateManyInput | ReturnRequestCreateManyInput[];
      skipDuplicates?: boolean;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ReturnRequestIncludeCreateManyAndReturn<ExtArgs> | null;
    };

  /**
   * ReturnRequest update
   */
  export type ReturnRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null;
    /**
     * The data needed to update a ReturnRequest.
     */
    data: XOR<ReturnRequestUpdateInput, ReturnRequestUncheckedUpdateInput>;
    /**
     * Choose, which ReturnRequest to update.
     */
    where: ReturnRequestWhereUniqueInput;
  };

  /**
   * ReturnRequest updateMany
   */
  export type ReturnRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReturnRequests.
     */
    data: XOR<ReturnRequestUpdateManyMutationInput, ReturnRequestUncheckedUpdateManyInput>;
    /**
     * Filter which ReturnRequests to update
     */
    where?: ReturnRequestWhereInput;
    /**
     * Limit how many ReturnRequests to update.
     */
    limit?: number;
  };

  /**
   * ReturnRequest updateManyAndReturn
   */
  export type ReturnRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the ReturnRequest
       */
      select?: ReturnRequestSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the ReturnRequest
       */
      omit?: ReturnRequestOmit<ExtArgs> | null;
      /**
       * The data used to update ReturnRequests.
       */
      data: XOR<ReturnRequestUpdateManyMutationInput, ReturnRequestUncheckedUpdateManyInput>;
      /**
       * Filter which ReturnRequests to update
       */
      where?: ReturnRequestWhereInput;
      /**
       * Limit how many ReturnRequests to update.
       */
      limit?: number;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ReturnRequestIncludeUpdateManyAndReturn<ExtArgs> | null;
    };

  /**
   * ReturnRequest upsert
   */
  export type ReturnRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null;
    /**
     * The filter to search for the ReturnRequest to update in case it exists.
     */
    where: ReturnRequestWhereUniqueInput;
    /**
     * In case the ReturnRequest found by the `where` argument doesn't exist, create a new ReturnRequest with this data.
     */
    create: XOR<ReturnRequestCreateInput, ReturnRequestUncheckedCreateInput>;
    /**
     * In case the ReturnRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReturnRequestUpdateInput, ReturnRequestUncheckedUpdateInput>;
  };

  /**
   * ReturnRequest delete
   */
  export type ReturnRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null;
    /**
     * Filter which ReturnRequest to delete.
     */
    where: ReturnRequestWhereUniqueInput;
  };

  /**
   * ReturnRequest deleteMany
   */
  export type ReturnRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnRequests to delete
     */
    where?: ReturnRequestWhereInput;
    /**
     * Limit how many ReturnRequests to delete.
     */
    limit?: number;
  };

  /**
   * ReturnRequest.refund
   */
  export type ReturnRequest$refundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null;
    where?: RefundWhereInput;
  };

  /**
   * ReturnRequest without action
   */
  export type ReturnRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null;
  };

  /**
   * Model Refund
   */

  export type AggregateRefund = {
    _count: RefundCountAggregateOutputType | null;
    _avg: RefundAvgAggregateOutputType | null;
    _sum: RefundSumAggregateOutputType | null;
    _min: RefundMinAggregateOutputType | null;
    _max: RefundMaxAggregateOutputType | null;
  };

  export type RefundAvgAggregateOutputType = {
    id: number | null;
    orderId: number | null;
    returnRequestId: number | null;
    amount: Decimal | null;
  };

  export type RefundSumAggregateOutputType = {
    id: number | null;
    orderId: number | null;
    returnRequestId: number | null;
    amount: Decimal | null;
  };

  export type RefundMinAggregateOutputType = {
    id: number | null;
    orderId: number | null;
    returnRequestId: number | null;
    amount: Decimal | null;
    method: string | null;
    status: $Enums.RefundStatus | null;
    providerRef: string | null;
    createdAt: Date | null;
    processedAt: Date | null;
  };

  export type RefundMaxAggregateOutputType = {
    id: number | null;
    orderId: number | null;
    returnRequestId: number | null;
    amount: Decimal | null;
    method: string | null;
    status: $Enums.RefundStatus | null;
    providerRef: string | null;
    createdAt: Date | null;
    processedAt: Date | null;
  };

  export type RefundCountAggregateOutputType = {
    id: number;
    orderId: number;
    returnRequestId: number;
    amount: number;
    method: number;
    status: number;
    providerRef: number;
    metadata: number;
    createdAt: number;
    processedAt: number;
    _all: number;
  };

  export type RefundAvgAggregateInputType = {
    id?: true;
    orderId?: true;
    returnRequestId?: true;
    amount?: true;
  };

  export type RefundSumAggregateInputType = {
    id?: true;
    orderId?: true;
    returnRequestId?: true;
    amount?: true;
  };

  export type RefundMinAggregateInputType = {
    id?: true;
    orderId?: true;
    returnRequestId?: true;
    amount?: true;
    method?: true;
    status?: true;
    providerRef?: true;
    createdAt?: true;
    processedAt?: true;
  };

  export type RefundMaxAggregateInputType = {
    id?: true;
    orderId?: true;
    returnRequestId?: true;
    amount?: true;
    method?: true;
    status?: true;
    providerRef?: true;
    createdAt?: true;
    processedAt?: true;
  };

  export type RefundCountAggregateInputType = {
    id?: true;
    orderId?: true;
    returnRequestId?: true;
    amount?: true;
    method?: true;
    status?: true;
    providerRef?: true;
    metadata?: true;
    createdAt?: true;
    processedAt?: true;
    _all?: true;
  };

  export type RefundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refund to aggregate.
     */
    where?: RefundWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RefundWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Refunds.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Refunds
     **/
    _count?: true | RefundCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: RefundAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: RefundSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RefundMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RefundMaxAggregateInputType;
  };

  export type GetRefundAggregateType<T extends RefundAggregateArgs> = {
    [P in keyof T & keyof AggregateRefund]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefund[P]>
      : GetScalarType<T[P], AggregateRefund[P]>;
  };

  export type RefundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundWhereInput;
    orderBy?: RefundOrderByWithAggregationInput | RefundOrderByWithAggregationInput[];
    by: RefundScalarFieldEnum[] | RefundScalarFieldEnum;
    having?: RefundScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RefundCountAggregateInputType | true;
    _avg?: RefundAvgAggregateInputType;
    _sum?: RefundSumAggregateInputType;
    _min?: RefundMinAggregateInputType;
    _max?: RefundMaxAggregateInputType;
  };

  export type RefundGroupByOutputType = {
    id: number;
    orderId: number;
    returnRequestId: number | null;
    amount: Decimal;
    method: string;
    status: $Enums.RefundStatus;
    providerRef: string | null;
    metadata: JsonValue | null;
    createdAt: Date;
    processedAt: Date | null;
    _count: RefundCountAggregateOutputType | null;
    _avg: RefundAvgAggregateOutputType | null;
    _sum: RefundSumAggregateOutputType | null;
    _min: RefundMinAggregateOutputType | null;
    _max: RefundMaxAggregateOutputType | null;
  };

  type GetRefundGroupByPayload<T extends RefundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefundGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof RefundGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], RefundGroupByOutputType[P]>
          : GetScalarType<T[P], RefundGroupByOutputType[P]>;
      }
    >
  >;

  export type RefundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
    {
      id?: boolean;
      orderId?: boolean;
      returnRequestId?: boolean;
      amount?: boolean;
      method?: boolean;
      status?: boolean;
      providerRef?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      processedAt?: boolean;
      order?: boolean | OrderDefaultArgs<ExtArgs>;
      returnRequest?: boolean | Refund$returnRequestArgs<ExtArgs>;
    },
    ExtArgs["result"]["refund"]
  >;

  export type RefundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        orderId?: boolean;
        returnRequestId?: boolean;
        amount?: boolean;
        method?: boolean;
        status?: boolean;
        providerRef?: boolean;
        metadata?: boolean;
        createdAt?: boolean;
        processedAt?: boolean;
        order?: boolean | OrderDefaultArgs<ExtArgs>;
        returnRequest?: boolean | Refund$returnRequestArgs<ExtArgs>;
      },
      ExtArgs["result"]["refund"]
    >;

  export type RefundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        orderId?: boolean;
        returnRequestId?: boolean;
        amount?: boolean;
        method?: boolean;
        status?: boolean;
        providerRef?: boolean;
        metadata?: boolean;
        createdAt?: boolean;
        processedAt?: boolean;
        order?: boolean | OrderDefaultArgs<ExtArgs>;
        returnRequest?: boolean | Refund$returnRequestArgs<ExtArgs>;
      },
      ExtArgs["result"]["refund"]
    >;

  export type RefundSelectScalar = {
    id?: boolean;
    orderId?: boolean;
    returnRequestId?: boolean;
    amount?: boolean;
    method?: boolean;
    status?: boolean;
    providerRef?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
    processedAt?: boolean;
  };

  export type RefundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    | "id"
    | "orderId"
    | "returnRequestId"
    | "amount"
    | "method"
    | "status"
    | "providerRef"
    | "metadata"
    | "createdAt"
    | "processedAt",
    ExtArgs["result"]["refund"]
  >;
  export type RefundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>;
    returnRequest?: boolean | Refund$returnRequestArgs<ExtArgs>;
  };
  export type RefundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>;
    returnRequest?: boolean | Refund$returnRequestArgs<ExtArgs>;
  };
  export type RefundIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>;
    returnRequest?: boolean | Refund$returnRequestArgs<ExtArgs>;
  };

  export type $RefundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Refund";
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>;
      returnRequest: Prisma.$ReturnRequestPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        orderId: number;
        returnRequestId: number | null;
        amount: Prisma.Decimal;
        method: string;
        status: $Enums.RefundStatus;
        providerRef: string | null;
        metadata: Prisma.JsonValue | null;
        createdAt: Date;
        processedAt: Date | null;
      },
      ExtArgs["result"]["refund"]
    >;
    composites: {};
  };

  type RefundGetPayload<S extends boolean | null | undefined | RefundDefaultArgs> = $Result.GetResult<
    Prisma.$RefundPayload,
    S
  >;

  type RefundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    RefundFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: RefundCountAggregateInputType | true;
  };

  export interface RefundDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["Refund"]; meta: { name: "Refund" } };
    /**
     * Find zero or one Refund that matches the filter.
     * @param {RefundFindUniqueArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefundFindUniqueArgs>(
      args: SelectSubset<T, RefundFindUniqueArgs<ExtArgs>>
    ): Prisma__RefundClient<
      $Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Refund that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefundFindUniqueOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefundFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RefundFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RefundClient<
      $Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Refund that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindFirstArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefundFindFirstArgs>(
      args?: SelectSubset<T, RefundFindFirstArgs<ExtArgs>>
    ): Prisma__RefundClient<
      $Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Refund that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindFirstOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefundFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RefundFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RefundClient<
      $Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Refunds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refunds
     * const refunds = await prisma.refund.findMany()
     *
     * // Get first 10 Refunds
     * const refunds = await prisma.refund.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const refundWithIdOnly = await prisma.refund.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RefundFindManyArgs>(
      args?: SelectSubset<T, RefundFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Refund.
     * @param {RefundCreateArgs} args - Arguments to create a Refund.
     * @example
     * // Create one Refund
     * const Refund = await prisma.refund.create({
     *   data: {
     *     // ... data to create a Refund
     *   }
     * })
     *
     */
    create<T extends RefundCreateArgs>(
      args: SelectSubset<T, RefundCreateArgs<ExtArgs>>
    ): Prisma__RefundClient<
      $Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Refunds.
     * @param {RefundCreateManyArgs} args - Arguments to create many Refunds.
     * @example
     * // Create many Refunds
     * const refund = await prisma.refund.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RefundCreateManyArgs>(
      args?: SelectSubset<T, RefundCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Refunds and returns the data saved in the database.
     * @param {RefundCreateManyAndReturnArgs} args - Arguments to create many Refunds.
     * @example
     * // Create many Refunds
     * const refund = await prisma.refund.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Refunds and only return the `id`
     * const refundWithIdOnly = await prisma.refund.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends RefundCreateManyAndReturnArgs>(
      args?: SelectSubset<T, RefundCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Refund.
     * @param {RefundDeleteArgs} args - Arguments to delete one Refund.
     * @example
     * // Delete one Refund
     * const Refund = await prisma.refund.delete({
     *   where: {
     *     // ... filter to delete one Refund
     *   }
     * })
     *
     */
    delete<T extends RefundDeleteArgs>(
      args: SelectSubset<T, RefundDeleteArgs<ExtArgs>>
    ): Prisma__RefundClient<
      $Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Refund.
     * @param {RefundUpdateArgs} args - Arguments to update one Refund.
     * @example
     * // Update one Refund
     * const refund = await prisma.refund.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RefundUpdateArgs>(
      args: SelectSubset<T, RefundUpdateArgs<ExtArgs>>
    ): Prisma__RefundClient<
      $Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Refunds.
     * @param {RefundDeleteManyArgs} args - Arguments to filter Refunds to delete.
     * @example
     * // Delete a few Refunds
     * const { count } = await prisma.refund.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RefundDeleteManyArgs>(
      args?: SelectSubset<T, RefundDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refunds
     * const refund = await prisma.refund.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RefundUpdateManyArgs>(
      args: SelectSubset<T, RefundUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Refunds and returns the data updated in the database.
     * @param {RefundUpdateManyAndReturnArgs} args - Arguments to update many Refunds.
     * @example
     * // Update many Refunds
     * const refund = await prisma.refund.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Refunds and only return the `id`
     * const refundWithIdOnly = await prisma.refund.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends RefundUpdateManyAndReturnArgs>(
      args: SelectSubset<T, RefundUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Refund.
     * @param {RefundUpsertArgs} args - Arguments to update or create a Refund.
     * @example
     * // Update or create a Refund
     * const refund = await prisma.refund.upsert({
     *   create: {
     *     // ... data to create a Refund
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refund we want to update
     *   }
     * })
     */
    upsert<T extends RefundUpsertArgs>(
      args: SelectSubset<T, RefundUpsertArgs<ExtArgs>>
    ): Prisma__RefundClient<
      $Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundCountArgs} args - Arguments to filter Refunds to count.
     * @example
     * // Count the number of Refunds
     * const count = await prisma.refund.count({
     *   where: {
     *     // ... the filter for the Refunds we want to count
     *   }
     * })
     **/
    count<T extends RefundCountArgs>(
      args?: Subset<T, RefundCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], RefundCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RefundAggregateArgs>(
      args: Subset<T, RefundAggregateArgs>
    ): Prisma.PrismaPromise<GetRefundAggregateType<T>>;

    /**
     * Group by Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RefundGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefundGroupByArgs["orderBy"] }
        : { orderBy?: RefundGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RefundGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetRefundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Refund model
     */
    readonly fields: RefundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Refund.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefundClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrderDefaultArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    returnRequest<T extends Refund$returnRequestArgs<ExtArgs> = {}>(
      args?: Subset<T, Refund$returnRequestArgs<ExtArgs>>
    ): Prisma__ReturnRequestClient<
      $Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Refund model
   */
  interface RefundFieldRefs {
    readonly id: FieldRef<"Refund", "Int">;
    readonly orderId: FieldRef<"Refund", "Int">;
    readonly returnRequestId: FieldRef<"Refund", "Int">;
    readonly amount: FieldRef<"Refund", "Decimal">;
    readonly method: FieldRef<"Refund", "String">;
    readonly status: FieldRef<"Refund", "RefundStatus">;
    readonly providerRef: FieldRef<"Refund", "String">;
    readonly metadata: FieldRef<"Refund", "Json">;
    readonly createdAt: FieldRef<"Refund", "DateTime">;
    readonly processedAt: FieldRef<"Refund", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Refund findUnique
   */
  export type RefundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null;
    /**
     * Filter, which Refund to fetch.
     */
    where: RefundWhereUniqueInput;
  };

  /**
   * Refund findUniqueOrThrow
   */
  export type RefundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null;
    /**
     * Filter, which Refund to fetch.
     */
    where: RefundWhereUniqueInput;
  };

  /**
   * Refund findFirst
   */
  export type RefundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null;
    /**
     * Filter, which Refund to fetch.
     */
    where?: RefundWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Refunds.
     */
    cursor?: RefundWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Refunds.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[];
  };

  /**
   * Refund findFirstOrThrow
   */
  export type RefundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null;
    /**
     * Filter, which Refund to fetch.
     */
    where?: RefundWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Refunds.
     */
    cursor?: RefundWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Refunds.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[];
  };

  /**
   * Refund findMany
   */
  export type RefundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null;
    /**
     * Filter, which Refunds to fetch.
     */
    where?: RefundWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Refunds.
     */
    cursor?: RefundWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Refunds.
     */
    skip?: number;
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[];
  };

  /**
   * Refund create
   */
  export type RefundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null;
    /**
     * The data needed to create a Refund.
     */
    data: XOR<RefundCreateInput, RefundUncheckedCreateInput>;
  };

  /**
   * Refund createMany
   */
  export type RefundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Refunds.
     */
    data: RefundCreateManyInput | RefundCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Refund createManyAndReturn
   */
  export type RefundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null;
    /**
     * The data used to create many Refunds.
     */
    data: RefundCreateManyInput | RefundCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Refund update
   */
  export type RefundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null;
    /**
     * The data needed to update a Refund.
     */
    data: XOR<RefundUpdateInput, RefundUncheckedUpdateInput>;
    /**
     * Choose, which Refund to update.
     */
    where: RefundWhereUniqueInput;
  };

  /**
   * Refund updateMany
   */
  export type RefundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Refunds.
     */
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyInput>;
    /**
     * Filter which Refunds to update
     */
    where?: RefundWhereInput;
    /**
     * Limit how many Refunds to update.
     */
    limit?: number;
  };

  /**
   * Refund updateManyAndReturn
   */
  export type RefundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null;
    /**
     * The data used to update Refunds.
     */
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyInput>;
    /**
     * Filter which Refunds to update
     */
    where?: RefundWhereInput;
    /**
     * Limit how many Refunds to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Refund upsert
   */
  export type RefundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null;
    /**
     * The filter to search for the Refund to update in case it exists.
     */
    where: RefundWhereUniqueInput;
    /**
     * In case the Refund found by the `where` argument doesn't exist, create a new Refund with this data.
     */
    create: XOR<RefundCreateInput, RefundUncheckedCreateInput>;
    /**
     * In case the Refund was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefundUpdateInput, RefundUncheckedUpdateInput>;
  };

  /**
   * Refund delete
   */
  export type RefundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null;
    /**
     * Filter which Refund to delete.
     */
    where: RefundWhereUniqueInput;
  };

  /**
   * Refund deleteMany
   */
  export type RefundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refunds to delete
     */
    where?: RefundWhereInput;
    /**
     * Limit how many Refunds to delete.
     */
    limit?: number;
  };

  /**
   * Refund.returnRequest
   */
  export type Refund$returnRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null;
    where?: ReturnRequestWhereInput;
  };

  /**
   * Refund without action
   */
  export type RefundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null;
  };

  /**
   * Model PaymentMeta
   */

  export type AggregatePaymentMeta = {
    _count: PaymentMetaCountAggregateOutputType | null;
    _avg: PaymentMetaAvgAggregateOutputType | null;
    _sum: PaymentMetaSumAggregateOutputType | null;
    _min: PaymentMetaMinAggregateOutputType | null;
    _max: PaymentMetaMaxAggregateOutputType | null;
  };

  export type PaymentMetaAvgAggregateOutputType = {
    id: number | null;
    orderId: number | null;
    amount: Decimal | null;
  };

  export type PaymentMetaSumAggregateOutputType = {
    id: number | null;
    orderId: number | null;
    amount: Decimal | null;
  };

  export type PaymentMetaMinAggregateOutputType = {
    id: number | null;
    orderId: number | null;
    provider: string | null;
    transactionId: string | null;
    status: string | null;
    amount: Decimal | null;
    capturedAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PaymentMetaMaxAggregateOutputType = {
    id: number | null;
    orderId: number | null;
    provider: string | null;
    transactionId: string | null;
    status: string | null;
    amount: Decimal | null;
    capturedAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PaymentMetaCountAggregateOutputType = {
    id: number;
    orderId: number;
    provider: number;
    transactionId: number;
    status: number;
    amount: number;
    raw: number;
    capturedAt: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type PaymentMetaAvgAggregateInputType = {
    id?: true;
    orderId?: true;
    amount?: true;
  };

  export type PaymentMetaSumAggregateInputType = {
    id?: true;
    orderId?: true;
    amount?: true;
  };

  export type PaymentMetaMinAggregateInputType = {
    id?: true;
    orderId?: true;
    provider?: true;
    transactionId?: true;
    status?: true;
    amount?: true;
    capturedAt?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PaymentMetaMaxAggregateInputType = {
    id?: true;
    orderId?: true;
    provider?: true;
    transactionId?: true;
    status?: true;
    amount?: true;
    capturedAt?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PaymentMetaCountAggregateInputType = {
    id?: true;
    orderId?: true;
    provider?: true;
    transactionId?: true;
    status?: true;
    amount?: true;
    raw?: true;
    capturedAt?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type PaymentMetaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMeta to aggregate.
     */
    where?: PaymentMetaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PaymentMetas to fetch.
     */
    orderBy?: PaymentMetaOrderByWithRelationInput | PaymentMetaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PaymentMetaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PaymentMetas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PaymentMetas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PaymentMetas
     **/
    _count?: true | PaymentMetaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PaymentMetaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PaymentMetaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PaymentMetaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PaymentMetaMaxAggregateInputType;
  };

  export type GetPaymentMetaAggregateType<T extends PaymentMetaAggregateArgs> = {
    [P in keyof T & keyof AggregatePaymentMeta]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMeta[P]>
      : GetScalarType<T[P], AggregatePaymentMeta[P]>;
  };

  export type PaymentMetaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMetaWhereInput;
    orderBy?: PaymentMetaOrderByWithAggregationInput | PaymentMetaOrderByWithAggregationInput[];
    by: PaymentMetaScalarFieldEnum[] | PaymentMetaScalarFieldEnum;
    having?: PaymentMetaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PaymentMetaCountAggregateInputType | true;
    _avg?: PaymentMetaAvgAggregateInputType;
    _sum?: PaymentMetaSumAggregateInputType;
    _min?: PaymentMetaMinAggregateInputType;
    _max?: PaymentMetaMaxAggregateInputType;
  };

  export type PaymentMetaGroupByOutputType = {
    id: number;
    orderId: number;
    provider: string;
    transactionId: string | null;
    status: string;
    amount: Decimal;
    raw: JsonValue | null;
    capturedAt: Date | null;
    createdAt: Date;
    updatedAt: Date;
    _count: PaymentMetaCountAggregateOutputType | null;
    _avg: PaymentMetaAvgAggregateOutputType | null;
    _sum: PaymentMetaSumAggregateOutputType | null;
    _min: PaymentMetaMinAggregateOutputType | null;
    _max: PaymentMetaMaxAggregateOutputType | null;
  };

  type GetPaymentMetaGroupByPayload<T extends PaymentMetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMetaGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof PaymentMetaGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PaymentMetaGroupByOutputType[P]>
          : GetScalarType<T[P], PaymentMetaGroupByOutputType[P]>;
      }
    >
  >;

  export type PaymentMetaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        orderId?: boolean;
        provider?: boolean;
        transactionId?: boolean;
        status?: boolean;
        amount?: boolean;
        raw?: boolean;
        capturedAt?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        order?: boolean | OrderDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["paymentMeta"]
    >;

  export type PaymentMetaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        orderId?: boolean;
        provider?: boolean;
        transactionId?: boolean;
        status?: boolean;
        amount?: boolean;
        raw?: boolean;
        capturedAt?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        order?: boolean | OrderDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["paymentMeta"]
    >;

  export type PaymentMetaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        orderId?: boolean;
        provider?: boolean;
        transactionId?: boolean;
        status?: boolean;
        amount?: boolean;
        raw?: boolean;
        capturedAt?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        order?: boolean | OrderDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["paymentMeta"]
    >;

  export type PaymentMetaSelectScalar = {
    id?: boolean;
    orderId?: boolean;
    provider?: boolean;
    transactionId?: boolean;
    status?: boolean;
    amount?: boolean;
    raw?: boolean;
    capturedAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type PaymentMetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    | "id"
    | "orderId"
    | "provider"
    | "transactionId"
    | "status"
    | "amount"
    | "raw"
    | "capturedAt"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["paymentMeta"]
  >;
  export type PaymentMetaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>;
  };
  export type PaymentMetaIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    order?: boolean | OrderDefaultArgs<ExtArgs>;
  };
  export type PaymentMetaIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    order?: boolean | OrderDefaultArgs<ExtArgs>;
  };

  export type $PaymentMetaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMeta";
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        orderId: number;
        provider: string;
        transactionId: string | null;
        status: string;
        amount: Prisma.Decimal;
        raw: Prisma.JsonValue | null;
        capturedAt: Date | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["paymentMeta"]
    >;
    composites: {};
  };

  type PaymentMetaGetPayload<S extends boolean | null | undefined | PaymentMetaDefaultArgs> = $Result.GetResult<
    Prisma.$PaymentMetaPayload,
    S
  >;

  type PaymentMetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    PaymentMetaFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: PaymentMetaCountAggregateInputType | true;
  };

  export interface PaymentMetaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["PaymentMeta"];
      meta: { name: "PaymentMeta" };
    };
    /**
     * Find zero or one PaymentMeta that matches the filter.
     * @param {PaymentMetaFindUniqueArgs} args - Arguments to find a PaymentMeta
     * @example
     * // Get one PaymentMeta
     * const paymentMeta = await prisma.paymentMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMetaFindUniqueArgs>(
      args: SelectSubset<T, PaymentMetaFindUniqueArgs<ExtArgs>>
    ): Prisma__PaymentMetaClient<
      $Result.GetResult<Prisma.$PaymentMetaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one PaymentMeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMetaFindUniqueOrThrowArgs} args - Arguments to find a PaymentMeta
     * @example
     * // Get one PaymentMeta
     * const paymentMeta = await prisma.paymentMeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMetaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PaymentMetaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentMetaClient<
      $Result.GetResult<Prisma.$PaymentMetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PaymentMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMetaFindFirstArgs} args - Arguments to find a PaymentMeta
     * @example
     * // Get one PaymentMeta
     * const paymentMeta = await prisma.paymentMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMetaFindFirstArgs>(
      args?: SelectSubset<T, PaymentMetaFindFirstArgs<ExtArgs>>
    ): Prisma__PaymentMetaClient<
      $Result.GetResult<Prisma.$PaymentMetaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PaymentMeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMetaFindFirstOrThrowArgs} args - Arguments to find a PaymentMeta
     * @example
     * // Get one PaymentMeta
     * const paymentMeta = await prisma.paymentMeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMetaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PaymentMetaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentMetaClient<
      $Result.GetResult<Prisma.$PaymentMetaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more PaymentMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMetas
     * const paymentMetas = await prisma.paymentMeta.findMany()
     *
     * // Get first 10 PaymentMetas
     * const paymentMetas = await prisma.paymentMeta.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const paymentMetaWithIdOnly = await prisma.paymentMeta.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PaymentMetaFindManyArgs>(
      args?: SelectSubset<T, PaymentMetaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMetaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a PaymentMeta.
     * @param {PaymentMetaCreateArgs} args - Arguments to create a PaymentMeta.
     * @example
     * // Create one PaymentMeta
     * const PaymentMeta = await prisma.paymentMeta.create({
     *   data: {
     *     // ... data to create a PaymentMeta
     *   }
     * })
     *
     */
    create<T extends PaymentMetaCreateArgs>(
      args: SelectSubset<T, PaymentMetaCreateArgs<ExtArgs>>
    ): Prisma__PaymentMetaClient<
      $Result.GetResult<Prisma.$PaymentMetaPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many PaymentMetas.
     * @param {PaymentMetaCreateManyArgs} args - Arguments to create many PaymentMetas.
     * @example
     * // Create many PaymentMetas
     * const paymentMeta = await prisma.paymentMeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PaymentMetaCreateManyArgs>(
      args?: SelectSubset<T, PaymentMetaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many PaymentMetas and returns the data saved in the database.
     * @param {PaymentMetaCreateManyAndReturnArgs} args - Arguments to create many PaymentMetas.
     * @example
     * // Create many PaymentMetas
     * const paymentMeta = await prisma.paymentMeta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PaymentMetas and only return the `id`
     * const paymentMetaWithIdOnly = await prisma.paymentMeta.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PaymentMetaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PaymentMetaCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PaymentMetaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a PaymentMeta.
     * @param {PaymentMetaDeleteArgs} args - Arguments to delete one PaymentMeta.
     * @example
     * // Delete one PaymentMeta
     * const PaymentMeta = await prisma.paymentMeta.delete({
     *   where: {
     *     // ... filter to delete one PaymentMeta
     *   }
     * })
     *
     */
    delete<T extends PaymentMetaDeleteArgs>(
      args: SelectSubset<T, PaymentMetaDeleteArgs<ExtArgs>>
    ): Prisma__PaymentMetaClient<
      $Result.GetResult<Prisma.$PaymentMetaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one PaymentMeta.
     * @param {PaymentMetaUpdateArgs} args - Arguments to update one PaymentMeta.
     * @example
     * // Update one PaymentMeta
     * const paymentMeta = await prisma.paymentMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PaymentMetaUpdateArgs>(
      args: SelectSubset<T, PaymentMetaUpdateArgs<ExtArgs>>
    ): Prisma__PaymentMetaClient<
      $Result.GetResult<Prisma.$PaymentMetaPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more PaymentMetas.
     * @param {PaymentMetaDeleteManyArgs} args - Arguments to filter PaymentMetas to delete.
     * @example
     * // Delete a few PaymentMetas
     * const { count } = await prisma.paymentMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PaymentMetaDeleteManyArgs>(
      args?: SelectSubset<T, PaymentMetaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PaymentMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMetas
     * const paymentMeta = await prisma.paymentMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PaymentMetaUpdateManyArgs>(
      args: SelectSubset<T, PaymentMetaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PaymentMetas and returns the data updated in the database.
     * @param {PaymentMetaUpdateManyAndReturnArgs} args - Arguments to update many PaymentMetas.
     * @example
     * // Update many PaymentMetas
     * const paymentMeta = await prisma.paymentMeta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more PaymentMetas and only return the `id`
     * const paymentMetaWithIdOnly = await prisma.paymentMeta.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PaymentMetaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PaymentMetaUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PaymentMetaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one PaymentMeta.
     * @param {PaymentMetaUpsertArgs} args - Arguments to update or create a PaymentMeta.
     * @example
     * // Update or create a PaymentMeta
     * const paymentMeta = await prisma.paymentMeta.upsert({
     *   create: {
     *     // ... data to create a PaymentMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMeta we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMetaUpsertArgs>(
      args: SelectSubset<T, PaymentMetaUpsertArgs<ExtArgs>>
    ): Prisma__PaymentMetaClient<
      $Result.GetResult<Prisma.$PaymentMetaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of PaymentMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMetaCountArgs} args - Arguments to filter PaymentMetas to count.
     * @example
     * // Count the number of PaymentMetas
     * const count = await prisma.paymentMeta.count({
     *   where: {
     *     // ... the filter for the PaymentMetas we want to count
     *   }
     * })
     **/
    count<T extends PaymentMetaCountArgs>(
      args?: Subset<T, PaymentMetaCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], PaymentMetaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a PaymentMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PaymentMetaAggregateArgs>(
      args: Subset<T, PaymentMetaAggregateArgs>
    ): Prisma.PrismaPromise<GetPaymentMetaAggregateType<T>>;

    /**
     * Group by PaymentMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PaymentMetaGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMetaGroupByArgs["orderBy"] }
        : { orderBy?: PaymentMetaGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PaymentMetaGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetPaymentMetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the PaymentMeta model
     */
    readonly fields: PaymentMetaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMetaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrderDefaultArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the PaymentMeta model
   */
  interface PaymentMetaFieldRefs {
    readonly id: FieldRef<"PaymentMeta", "Int">;
    readonly orderId: FieldRef<"PaymentMeta", "Int">;
    readonly provider: FieldRef<"PaymentMeta", "String">;
    readonly transactionId: FieldRef<"PaymentMeta", "String">;
    readonly status: FieldRef<"PaymentMeta", "String">;
    readonly amount: FieldRef<"PaymentMeta", "Decimal">;
    readonly raw: FieldRef<"PaymentMeta", "Json">;
    readonly capturedAt: FieldRef<"PaymentMeta", "DateTime">;
    readonly createdAt: FieldRef<"PaymentMeta", "DateTime">;
    readonly updatedAt: FieldRef<"PaymentMeta", "DateTime">;
  }

  // Custom InputTypes
  /**
   * PaymentMeta findUnique
   */
  export type PaymentMetaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMeta
     */
    select?: PaymentMetaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentMeta
     */
    omit?: PaymentMetaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMetaInclude<ExtArgs> | null;
    /**
     * Filter, which PaymentMeta to fetch.
     */
    where: PaymentMetaWhereUniqueInput;
  };

  /**
   * PaymentMeta findUniqueOrThrow
   */
  export type PaymentMetaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMeta
     */
    select?: PaymentMetaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentMeta
     */
    omit?: PaymentMetaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMetaInclude<ExtArgs> | null;
    /**
     * Filter, which PaymentMeta to fetch.
     */
    where: PaymentMetaWhereUniqueInput;
  };

  /**
   * PaymentMeta findFirst
   */
  export type PaymentMetaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMeta
     */
    select?: PaymentMetaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentMeta
     */
    omit?: PaymentMetaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMetaInclude<ExtArgs> | null;
    /**
     * Filter, which PaymentMeta to fetch.
     */
    where?: PaymentMetaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PaymentMetas to fetch.
     */
    orderBy?: PaymentMetaOrderByWithRelationInput | PaymentMetaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PaymentMetas.
     */
    cursor?: PaymentMetaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PaymentMetas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PaymentMetas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PaymentMetas.
     */
    distinct?: PaymentMetaScalarFieldEnum | PaymentMetaScalarFieldEnum[];
  };

  /**
   * PaymentMeta findFirstOrThrow
   */
  export type PaymentMetaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMeta
     */
    select?: PaymentMetaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentMeta
     */
    omit?: PaymentMetaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMetaInclude<ExtArgs> | null;
    /**
     * Filter, which PaymentMeta to fetch.
     */
    where?: PaymentMetaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PaymentMetas to fetch.
     */
    orderBy?: PaymentMetaOrderByWithRelationInput | PaymentMetaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PaymentMetas.
     */
    cursor?: PaymentMetaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PaymentMetas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PaymentMetas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PaymentMetas.
     */
    distinct?: PaymentMetaScalarFieldEnum | PaymentMetaScalarFieldEnum[];
  };

  /**
   * PaymentMeta findMany
   */
  export type PaymentMetaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMeta
     */
    select?: PaymentMetaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentMeta
     */
    omit?: PaymentMetaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMetaInclude<ExtArgs> | null;
    /**
     * Filter, which PaymentMetas to fetch.
     */
    where?: PaymentMetaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PaymentMetas to fetch.
     */
    orderBy?: PaymentMetaOrderByWithRelationInput | PaymentMetaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PaymentMetas.
     */
    cursor?: PaymentMetaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PaymentMetas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PaymentMetas.
     */
    skip?: number;
    distinct?: PaymentMetaScalarFieldEnum | PaymentMetaScalarFieldEnum[];
  };

  /**
   * PaymentMeta create
   */
  export type PaymentMetaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMeta
     */
    select?: PaymentMetaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentMeta
     */
    omit?: PaymentMetaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMetaInclude<ExtArgs> | null;
    /**
     * The data needed to create a PaymentMeta.
     */
    data: XOR<PaymentMetaCreateInput, PaymentMetaUncheckedCreateInput>;
  };

  /**
   * PaymentMeta createMany
   */
  export type PaymentMetaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMetas.
     */
    data: PaymentMetaCreateManyInput | PaymentMetaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * PaymentMeta createManyAndReturn
   */
  export type PaymentMetaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMeta
     */
    select?: PaymentMetaSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentMeta
     */
    omit?: PaymentMetaOmit<ExtArgs> | null;
    /**
     * The data used to create many PaymentMetas.
     */
    data: PaymentMetaCreateManyInput | PaymentMetaCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMetaIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * PaymentMeta update
   */
  export type PaymentMetaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMeta
     */
    select?: PaymentMetaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentMeta
     */
    omit?: PaymentMetaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMetaInclude<ExtArgs> | null;
    /**
     * The data needed to update a PaymentMeta.
     */
    data: XOR<PaymentMetaUpdateInput, PaymentMetaUncheckedUpdateInput>;
    /**
     * Choose, which PaymentMeta to update.
     */
    where: PaymentMetaWhereUniqueInput;
  };

  /**
   * PaymentMeta updateMany
   */
  export type PaymentMetaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMetas.
     */
    data: XOR<PaymentMetaUpdateManyMutationInput, PaymentMetaUncheckedUpdateManyInput>;
    /**
     * Filter which PaymentMetas to update
     */
    where?: PaymentMetaWhereInput;
    /**
     * Limit how many PaymentMetas to update.
     */
    limit?: number;
  };

  /**
   * PaymentMeta updateManyAndReturn
   */
  export type PaymentMetaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMeta
     */
    select?: PaymentMetaSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentMeta
     */
    omit?: PaymentMetaOmit<ExtArgs> | null;
    /**
     * The data used to update PaymentMetas.
     */
    data: XOR<PaymentMetaUpdateManyMutationInput, PaymentMetaUncheckedUpdateManyInput>;
    /**
     * Filter which PaymentMetas to update
     */
    where?: PaymentMetaWhereInput;
    /**
     * Limit how many PaymentMetas to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMetaIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * PaymentMeta upsert
   */
  export type PaymentMetaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMeta
     */
    select?: PaymentMetaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentMeta
     */
    omit?: PaymentMetaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMetaInclude<ExtArgs> | null;
    /**
     * The filter to search for the PaymentMeta to update in case it exists.
     */
    where: PaymentMetaWhereUniqueInput;
    /**
     * In case the PaymentMeta found by the `where` argument doesn't exist, create a new PaymentMeta with this data.
     */
    create: XOR<PaymentMetaCreateInput, PaymentMetaUncheckedCreateInput>;
    /**
     * In case the PaymentMeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMetaUpdateInput, PaymentMetaUncheckedUpdateInput>;
  };

  /**
   * PaymentMeta delete
   */
  export type PaymentMetaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMeta
     */
    select?: PaymentMetaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentMeta
     */
    omit?: PaymentMetaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMetaInclude<ExtArgs> | null;
    /**
     * Filter which PaymentMeta to delete.
     */
    where: PaymentMetaWhereUniqueInput;
  };

  /**
   * PaymentMeta deleteMany
   */
  export type PaymentMetaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMetas to delete
     */
    where?: PaymentMetaWhereInput;
    /**
     * Limit how many PaymentMetas to delete.
     */
    limit?: number;
  };

  /**
   * PaymentMeta without action
   */
  export type PaymentMetaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMeta
     */
    select?: PaymentMetaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaymentMeta
     */
    omit?: PaymentMetaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMetaInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: "ReadUncommitted";
    ReadCommitted: "ReadCommitted";
    RepeatableRead: "RepeatableRead";
    Serializable: "Serializable";
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const UserScalarFieldEnum: {
    id: "id";
    email: "email";
    username: "username";
    password: "password";
    displayName: "displayName";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    lastLogin: "lastLogin";
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const RoleScalarFieldEnum: {
    id: "id";
    name: "name";
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum];

  export const UserRoleScalarFieldEnum: {
    id: "id";
    userId: "userId";
    roleId: "roleId";
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum];

  export const ProductScalarFieldEnum: {
    id: "id";
    title: "title";
    slug: "slug";
    shortDescription: "shortDescription";
    description: "description";
    status: "status";
    metadata: "metadata";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum];

  export const ProductImageScalarFieldEnum: {
    id: "id";
    url: "url";
    alt: "alt";
    isPrimary: "isPrimary";
    productId: "productId";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type ProductImageScalarFieldEnum =
    (typeof ProductImageScalarFieldEnum)[keyof typeof ProductImageScalarFieldEnum];

  export const ProductVariantScalarFieldEnum: {
    id: "id";
    productId: "productId";
    name: "name";
    skuPrefix: "skuPrefix";
    price: "price";
    compareAtPrice: "compareAtPrice";
    attributes: "attributes";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type ProductVariantScalarFieldEnum =
    (typeof ProductVariantScalarFieldEnum)[keyof typeof ProductVariantScalarFieldEnum];

  export const InventoryScalarFieldEnum: {
    id: "id";
    sku: "sku";
    variantId: "variantId";
    quantity: "quantity";
    reserved: "reserved";
    location: "location";
    metadata: "metadata";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum];

  export const OrderScalarFieldEnum: {
    id: "id";
    orderNumber: "orderNumber";
    userId: "userId";
    status: "status";
    subtotal: "subtotal";
    shipping: "shipping";
    tax: "tax";
    total: "total";
    paymentMethod: "paymentMethod";
    shippingAddressId: "shippingAddressId";
    billingAddressId: "billingAddressId";
    couponId: "couponId";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum];

  export const OrderItemScalarFieldEnum: {
    id: "id";
    orderId: "orderId";
    productId: "productId";
    variantId: "variantId";
    sku: "sku";
    name: "name";
    price: "price";
    quantity: "quantity";
    total: "total";
    returned: "returned";
    createdAt: "createdAt";
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum];

  export const CouponScalarFieldEnum: {
    id: "id";
    code: "code";
    type: "type";
    amount: "amount";
    percent: "percent";
    description: "description";
    startsAt: "startsAt";
    expiresAt: "expiresAt";
    usageLimit: "usageLimit";
    usagePerUser: "usagePerUser";
    timesUsed: "timesUsed";
    active: "active";
    metadata: "metadata";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum];

  export const ReviewScalarFieldEnum: {
    id: "id";
    userId: "userId";
    productId: "productId";
    rating: "rating";
    title: "title";
    body: "body";
    approved: "approved";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum];

  export const WishlistScalarFieldEnum: {
    id: "id";
    userId: "userId";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type WishlistScalarFieldEnum = (typeof WishlistScalarFieldEnum)[keyof typeof WishlistScalarFieldEnum];

  export const WishlistItemScalarFieldEnum: {
    id: "id";
    wishlistId: "wishlistId";
    productId: "productId";
    variantId: "variantId";
    createdAt: "createdAt";
  };

  export type WishlistItemScalarFieldEnum =
    (typeof WishlistItemScalarFieldEnum)[keyof typeof WishlistItemScalarFieldEnum];

  export const AddressScalarFieldEnum: {
    id: "id";
    userId: "userId";
    fullName: "fullName";
    line1: "line1";
    line2: "line2";
    city: "city";
    province: "province";
    postalCode: "postalCode";
    country: "country";
    phone: "phone";
    metadata: "metadata";
    isDefaultShipping: "isDefaultShipping";
    isDefaultBilling: "isDefaultBilling";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum];

  export const AuditLogScalarFieldEnum: {
    id: "id";
    actorId: "actorId";
    action: "action";
    entity: "entity";
    entityId: "entityId";
    changes: "changes";
    ip: "ip";
    userAgent: "userAgent";
    createdAt: "createdAt";
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum];

  export const ReturnRequestScalarFieldEnum: {
    id: "id";
    orderId: "orderId";
    orderItemId: "orderItemId";
    reason: "reason";
    status: "status";
    evidence: "evidence";
    requestedAt: "requestedAt";
    processedAt: "processedAt";
    metadata: "metadata";
  };

  export type ReturnRequestScalarFieldEnum =
    (typeof ReturnRequestScalarFieldEnum)[keyof typeof ReturnRequestScalarFieldEnum];

  export const RefundScalarFieldEnum: {
    id: "id";
    orderId: "orderId";
    returnRequestId: "returnRequestId";
    amount: "amount";
    method: "method";
    status: "status";
    providerRef: "providerRef";
    metadata: "metadata";
    createdAt: "createdAt";
    processedAt: "processedAt";
  };

  export type RefundScalarFieldEnum = (typeof RefundScalarFieldEnum)[keyof typeof RefundScalarFieldEnum];

  export const PaymentMetaScalarFieldEnum: {
    id: "id";
    orderId: "orderId";
    provider: "provider";
    transactionId: "transactionId";
    status: "status";
    amount: "amount";
    raw: "raw";
    capturedAt: "capturedAt";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type PaymentMetaScalarFieldEnum = (typeof PaymentMetaScalarFieldEnum)[keyof typeof PaymentMetaScalarFieldEnum];

  export const SortOrder: {
    asc: "asc";
    desc: "desc";
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const QueryMode: {
    default: "default";
    insensitive: "insensitive";
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: "first";
    last: "last";
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Int">;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Int[]">;

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "String">;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "String[]">;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "DateTime">;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "DateTime[]">;

  /**
   * Reference to a field of type 'ProductStatus'
   */
  export type EnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "ProductStatus">;

  /**
   * Reference to a field of type 'ProductStatus[]'
   */
  export type ListEnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "ProductStatus[]">;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Json">;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "QueryMode">;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Boolean">;

  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Decimal">;

  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Decimal[]">;

  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "OrderStatus">;

  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "OrderStatus[]">;

  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "PaymentMethod">;

  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "PaymentMethod[]">;

  /**
   * Reference to a field of type 'CouponType'
   */
  export type EnumCouponTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "CouponType">;

  /**
   * Reference to a field of type 'CouponType[]'
   */
  export type ListEnumCouponTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "CouponType[]">;

  /**
   * Reference to a field of type 'ReturnStatus'
   */
  export type EnumReturnStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "ReturnStatus">;

  /**
   * Reference to a field of type 'ReturnStatus[]'
   */
  export type ListEnumReturnStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "ReturnStatus[]">;

  /**
   * Reference to a field of type 'RefundStatus'
   */
  export type EnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "RefundStatus">;

  /**
   * Reference to a field of type 'RefundStatus[]'
   */
  export type ListEnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "RefundStatus[]">;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Float">;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Float[]">;

  /**
   * Deep Input Types
   */

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: IntFilter<"User"> | number;
    email?: StringFilter<"User"> | string;
    username?: StringNullableFilter<"User"> | string | null;
    password?: StringNullableFilter<"User"> | string | null;
    displayName?: StringNullableFilter<"User"> | string | null;
    createdAt?: DateTimeFilter<"User"> | Date | string;
    updatedAt?: DateTimeFilter<"User"> | Date | string;
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null;
    userRoles?: UserRoleListRelationFilter;
    addresses?: AddressListRelationFilter;
    wishlist?: XOR<WishlistNullableScalarRelationFilter, WishlistWhereInput> | null;
    reviews?: ReviewListRelationFilter;
    orders?: OrderListRelationFilter;
    AuditLog?: AuditLogListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    email?: SortOrder;
    username?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    displayName?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLogin?: SortOrderInput | SortOrder;
    userRoles?: UserRoleOrderByRelationAggregateInput;
    addresses?: AddressOrderByRelationAggregateInput;
    wishlist?: WishlistOrderByWithRelationInput;
    reviews?: ReviewOrderByRelationAggregateInput;
    orders?: OrderOrderByRelationAggregateInput;
    AuditLog?: AuditLogOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      email?: string;
      username?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      password?: StringNullableFilter<"User"> | string | null;
      displayName?: StringNullableFilter<"User"> | string | null;
      createdAt?: DateTimeFilter<"User"> | Date | string;
      updatedAt?: DateTimeFilter<"User"> | Date | string;
      lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null;
      userRoles?: UserRoleListRelationFilter;
      addresses?: AddressListRelationFilter;
      wishlist?: XOR<WishlistNullableScalarRelationFilter, WishlistWhereInput> | null;
      reviews?: ReviewListRelationFilter;
      orders?: OrderListRelationFilter;
      AuditLog?: AuditLogListRelationFilter;
    },
    "id" | "email" | "username"
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    email?: SortOrder;
    username?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    displayName?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLogin?: SortOrderInput | SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _avg?: UserAvgOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
    _sum?: UserSumOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"User"> | number;
    email?: StringWithAggregatesFilter<"User"> | string;
    username?: StringNullableWithAggregatesFilter<"User"> | string | null;
    password?: StringNullableWithAggregatesFilter<"User"> | string | null;
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null;
  };

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[];
    OR?: RoleWhereInput[];
    NOT?: RoleWhereInput | RoleWhereInput[];
    id?: IntFilter<"Role"> | number;
    name?: StringFilter<"Role"> | string;
    userRoles?: UserRoleListRelationFilter;
  };

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    userRoles?: UserRoleOrderByRelationAggregateInput;
  };

  export type RoleWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      name?: string;
      AND?: RoleWhereInput | RoleWhereInput[];
      OR?: RoleWhereInput[];
      NOT?: RoleWhereInput | RoleWhereInput[];
      userRoles?: UserRoleListRelationFilter;
    },
    "id" | "name"
  >;

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    _count?: RoleCountOrderByAggregateInput;
    _avg?: RoleAvgOrderByAggregateInput;
    _max?: RoleMaxOrderByAggregateInput;
    _min?: RoleMinOrderByAggregateInput;
    _sum?: RoleSumOrderByAggregateInput;
  };

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[];
    OR?: RoleScalarWhereWithAggregatesInput[];
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Role"> | number;
    name?: StringWithAggregatesFilter<"Role"> | string;
  };

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[];
    OR?: UserRoleWhereInput[];
    NOT?: UserRoleWhereInput | UserRoleWhereInput[];
    id?: IntFilter<"UserRole"> | number;
    userId?: IntFilter<"UserRole"> | number;
    roleId?: IntFilter<"UserRole"> | number;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>;
  };

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    roleId?: SortOrder;
    user?: UserOrderByWithRelationInput;
    role?: RoleOrderByWithRelationInput;
  };

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput;
      AND?: UserRoleWhereInput | UserRoleWhereInput[];
      OR?: UserRoleWhereInput[];
      NOT?: UserRoleWhereInput | UserRoleWhereInput[];
      userId?: IntFilter<"UserRole"> | number;
      roleId?: IntFilter<"UserRole"> | number;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      role?: XOR<RoleScalarRelationFilter, RoleWhereInput>;
    },
    "id" | "userId_roleId"
  >;

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    roleId?: SortOrder;
    _count?: UserRoleCountOrderByAggregateInput;
    _avg?: UserRoleAvgOrderByAggregateInput;
    _max?: UserRoleMaxOrderByAggregateInput;
    _min?: UserRoleMinOrderByAggregateInput;
    _sum?: UserRoleSumOrderByAggregateInput;
  };

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[];
    OR?: UserRoleScalarWhereWithAggregatesInput[];
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"UserRole"> | number;
    userId?: IntWithAggregatesFilter<"UserRole"> | number;
    roleId?: IntWithAggregatesFilter<"UserRole"> | number;
  };

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[];
    OR?: ProductWhereInput[];
    NOT?: ProductWhereInput | ProductWhereInput[];
    id?: IntFilter<"Product"> | number;
    title?: StringFilter<"Product"> | string;
    slug?: StringFilter<"Product"> | string;
    shortDescription?: StringNullableFilter<"Product"> | string | null;
    description?: StringNullableFilter<"Product"> | string | null;
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus;
    metadata?: JsonNullableFilter<"Product">;
    createdAt?: DateTimeFilter<"Product"> | Date | string;
    updatedAt?: DateTimeFilter<"Product"> | Date | string;
    images?: ProductImageListRelationFilter;
    variants?: ProductVariantListRelationFilter;
    reviews?: ReviewListRelationFilter;
    OrderItem?: OrderItemListRelationFilter;
    WishlistItem?: WishlistItemListRelationFilter;
  };

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    slug?: SortOrder;
    shortDescription?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    status?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    images?: ProductImageOrderByRelationAggregateInput;
    variants?: ProductVariantOrderByRelationAggregateInput;
    reviews?: ReviewOrderByRelationAggregateInput;
    OrderItem?: OrderItemOrderByRelationAggregateInput;
    WishlistItem?: WishlistItemOrderByRelationAggregateInput;
  };

  export type ProductWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      slug?: string;
      AND?: ProductWhereInput | ProductWhereInput[];
      OR?: ProductWhereInput[];
      NOT?: ProductWhereInput | ProductWhereInput[];
      title?: StringFilter<"Product"> | string;
      shortDescription?: StringNullableFilter<"Product"> | string | null;
      description?: StringNullableFilter<"Product"> | string | null;
      status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus;
      metadata?: JsonNullableFilter<"Product">;
      createdAt?: DateTimeFilter<"Product"> | Date | string;
      updatedAt?: DateTimeFilter<"Product"> | Date | string;
      images?: ProductImageListRelationFilter;
      variants?: ProductVariantListRelationFilter;
      reviews?: ReviewListRelationFilter;
      OrderItem?: OrderItemListRelationFilter;
      WishlistItem?: WishlistItemListRelationFilter;
    },
    "id" | "slug"
  >;

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    slug?: SortOrder;
    shortDescription?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    status?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ProductCountOrderByAggregateInput;
    _avg?: ProductAvgOrderByAggregateInput;
    _max?: ProductMaxOrderByAggregateInput;
    _min?: ProductMinOrderByAggregateInput;
    _sum?: ProductSumOrderByAggregateInput;
  };

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[];
    OR?: ProductScalarWhereWithAggregatesInput[];
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Product"> | number;
    title?: StringWithAggregatesFilter<"Product"> | string;
    slug?: StringWithAggregatesFilter<"Product"> | string;
    shortDescription?: StringNullableWithAggregatesFilter<"Product"> | string | null;
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null;
    status?: EnumProductStatusWithAggregatesFilter<"Product"> | $Enums.ProductStatus;
    metadata?: JsonNullableWithAggregatesFilter<"Product">;
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string;
  };

  export type ProductImageWhereInput = {
    AND?: ProductImageWhereInput | ProductImageWhereInput[];
    OR?: ProductImageWhereInput[];
    NOT?: ProductImageWhereInput | ProductImageWhereInput[];
    id?: IntFilter<"ProductImage"> | number;
    url?: StringFilter<"ProductImage"> | string;
    alt?: StringNullableFilter<"ProductImage"> | string | null;
    isPrimary?: BoolFilter<"ProductImage"> | boolean;
    productId?: IntFilter<"ProductImage"> | number;
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string;
    updatedAt?: DateTimeFilter<"ProductImage"> | Date | string;
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>;
  };

  export type ProductImageOrderByWithRelationInput = {
    id?: SortOrder;
    url?: SortOrder;
    alt?: SortOrderInput | SortOrder;
    isPrimary?: SortOrder;
    productId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    product?: ProductOrderByWithRelationInput;
  };

  export type ProductImageWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: ProductImageWhereInput | ProductImageWhereInput[];
      OR?: ProductImageWhereInput[];
      NOT?: ProductImageWhereInput | ProductImageWhereInput[];
      url?: StringFilter<"ProductImage"> | string;
      alt?: StringNullableFilter<"ProductImage"> | string | null;
      isPrimary?: BoolFilter<"ProductImage"> | boolean;
      productId?: IntFilter<"ProductImage"> | number;
      createdAt?: DateTimeFilter<"ProductImage"> | Date | string;
      updatedAt?: DateTimeFilter<"ProductImage"> | Date | string;
      product?: XOR<ProductScalarRelationFilter, ProductWhereInput>;
    },
    "id"
  >;

  export type ProductImageOrderByWithAggregationInput = {
    id?: SortOrder;
    url?: SortOrder;
    alt?: SortOrderInput | SortOrder;
    isPrimary?: SortOrder;
    productId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ProductImageCountOrderByAggregateInput;
    _avg?: ProductImageAvgOrderByAggregateInput;
    _max?: ProductImageMaxOrderByAggregateInput;
    _min?: ProductImageMinOrderByAggregateInput;
    _sum?: ProductImageSumOrderByAggregateInput;
  };

  export type ProductImageScalarWhereWithAggregatesInput = {
    AND?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[];
    OR?: ProductImageScalarWhereWithAggregatesInput[];
    NOT?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"ProductImage"> | number;
    url?: StringWithAggregatesFilter<"ProductImage"> | string;
    alt?: StringNullableWithAggregatesFilter<"ProductImage"> | string | null;
    isPrimary?: BoolWithAggregatesFilter<"ProductImage"> | boolean;
    productId?: IntWithAggregatesFilter<"ProductImage"> | number;
    createdAt?: DateTimeWithAggregatesFilter<"ProductImage"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"ProductImage"> | Date | string;
  };

  export type ProductVariantWhereInput = {
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[];
    OR?: ProductVariantWhereInput[];
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[];
    id?: IntFilter<"ProductVariant"> | number;
    productId?: IntFilter<"ProductVariant"> | number;
    name?: StringFilter<"ProductVariant"> | string;
    skuPrefix?: StringNullableFilter<"ProductVariant"> | string | null;
    price?: DecimalFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string;
    compareAtPrice?: DecimalNullableFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null;
    attributes?: JsonNullableFilter<"ProductVariant">;
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string;
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string;
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>;
    inventory?: InventoryListRelationFilter;
    OrderItem?: OrderItemListRelationFilter;
  };

  export type ProductVariantOrderByWithRelationInput = {
    id?: SortOrder;
    productId?: SortOrder;
    name?: SortOrder;
    skuPrefix?: SortOrderInput | SortOrder;
    price?: SortOrder;
    compareAtPrice?: SortOrderInput | SortOrder;
    attributes?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    product?: ProductOrderByWithRelationInput;
    inventory?: InventoryOrderByRelationAggregateInput;
    OrderItem?: OrderItemOrderByRelationAggregateInput;
  };

  export type ProductVariantWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: ProductVariantWhereInput | ProductVariantWhereInput[];
      OR?: ProductVariantWhereInput[];
      NOT?: ProductVariantWhereInput | ProductVariantWhereInput[];
      productId?: IntFilter<"ProductVariant"> | number;
      name?: StringFilter<"ProductVariant"> | string;
      skuPrefix?: StringNullableFilter<"ProductVariant"> | string | null;
      price?: DecimalFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string;
      compareAtPrice?: DecimalNullableFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null;
      attributes?: JsonNullableFilter<"ProductVariant">;
      createdAt?: DateTimeFilter<"ProductVariant"> | Date | string;
      updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string;
      product?: XOR<ProductScalarRelationFilter, ProductWhereInput>;
      inventory?: InventoryListRelationFilter;
      OrderItem?: OrderItemListRelationFilter;
    },
    "id"
  >;

  export type ProductVariantOrderByWithAggregationInput = {
    id?: SortOrder;
    productId?: SortOrder;
    name?: SortOrder;
    skuPrefix?: SortOrderInput | SortOrder;
    price?: SortOrder;
    compareAtPrice?: SortOrderInput | SortOrder;
    attributes?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ProductVariantCountOrderByAggregateInput;
    _avg?: ProductVariantAvgOrderByAggregateInput;
    _max?: ProductVariantMaxOrderByAggregateInput;
    _min?: ProductVariantMinOrderByAggregateInput;
    _sum?: ProductVariantSumOrderByAggregateInput;
  };

  export type ProductVariantScalarWhereWithAggregatesInput = {
    AND?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[];
    OR?: ProductVariantScalarWhereWithAggregatesInput[];
    NOT?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"ProductVariant"> | number;
    productId?: IntWithAggregatesFilter<"ProductVariant"> | number;
    name?: StringWithAggregatesFilter<"ProductVariant"> | string;
    skuPrefix?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null;
    price?: DecimalWithAggregatesFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string;
    compareAtPrice?:
      | DecimalNullableWithAggregatesFilter<"ProductVariant">
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    attributes?: JsonNullableWithAggregatesFilter<"ProductVariant">;
    createdAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string;
  };

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[];
    OR?: InventoryWhereInput[];
    NOT?: InventoryWhereInput | InventoryWhereInput[];
    id?: IntFilter<"Inventory"> | number;
    sku?: StringFilter<"Inventory"> | string;
    variantId?: IntFilter<"Inventory"> | number;
    quantity?: IntFilter<"Inventory"> | number;
    reserved?: IntFilter<"Inventory"> | number;
    location?: StringNullableFilter<"Inventory"> | string | null;
    metadata?: JsonNullableFilter<"Inventory">;
    createdAt?: DateTimeFilter<"Inventory"> | Date | string;
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string;
    variant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>;
  };

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder;
    sku?: SortOrder;
    variantId?: SortOrder;
    quantity?: SortOrder;
    reserved?: SortOrder;
    location?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    variant?: ProductVariantOrderByWithRelationInput;
  };

  export type InventoryWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      sku?: string;
      AND?: InventoryWhereInput | InventoryWhereInput[];
      OR?: InventoryWhereInput[];
      NOT?: InventoryWhereInput | InventoryWhereInput[];
      variantId?: IntFilter<"Inventory"> | number;
      quantity?: IntFilter<"Inventory"> | number;
      reserved?: IntFilter<"Inventory"> | number;
      location?: StringNullableFilter<"Inventory"> | string | null;
      metadata?: JsonNullableFilter<"Inventory">;
      createdAt?: DateTimeFilter<"Inventory"> | Date | string;
      updatedAt?: DateTimeFilter<"Inventory"> | Date | string;
      variant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>;
    },
    "id" | "sku"
  >;

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder;
    sku?: SortOrder;
    variantId?: SortOrder;
    quantity?: SortOrder;
    reserved?: SortOrder;
    location?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: InventoryCountOrderByAggregateInput;
    _avg?: InventoryAvgOrderByAggregateInput;
    _max?: InventoryMaxOrderByAggregateInput;
    _min?: InventoryMinOrderByAggregateInput;
    _sum?: InventorySumOrderByAggregateInput;
  };

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[];
    OR?: InventoryScalarWhereWithAggregatesInput[];
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Inventory"> | number;
    sku?: StringWithAggregatesFilter<"Inventory"> | string;
    variantId?: IntWithAggregatesFilter<"Inventory"> | number;
    quantity?: IntWithAggregatesFilter<"Inventory"> | number;
    reserved?: IntWithAggregatesFilter<"Inventory"> | number;
    location?: StringNullableWithAggregatesFilter<"Inventory"> | string | null;
    metadata?: JsonNullableWithAggregatesFilter<"Inventory">;
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string;
  };

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[];
    OR?: OrderWhereInput[];
    NOT?: OrderWhereInput | OrderWhereInput[];
    id?: IntFilter<"Order"> | number;
    orderNumber?: StringFilter<"Order"> | string;
    userId?: IntNullableFilter<"Order"> | number | null;
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus;
    subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string;
    total?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFilter<"Order"> | $Enums.PaymentMethod;
    shippingAddressId?: IntNullableFilter<"Order"> | number | null;
    billingAddressId?: IntNullableFilter<"Order"> | number | null;
    couponId?: IntNullableFilter<"Order"> | number | null;
    createdAt?: DateTimeFilter<"Order"> | Date | string;
    updatedAt?: DateTimeFilter<"Order"> | Date | string;
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    paymentMeta?: XOR<PaymentMetaNullableScalarRelationFilter, PaymentMetaWhereInput> | null;
    items?: OrderItemListRelationFilter;
    shippingAddress?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null;
    billingAddress?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null;
    coupon?: XOR<CouponNullableScalarRelationFilter, CouponWhereInput> | null;
    ReturnRequest?: ReturnRequestListRelationFilter;
    Refund?: RefundListRelationFilter;
  };

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder;
    orderNumber?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    status?: SortOrder;
    subtotal?: SortOrder;
    shipping?: SortOrder;
    tax?: SortOrder;
    total?: SortOrder;
    paymentMethod?: SortOrder;
    shippingAddressId?: SortOrderInput | SortOrder;
    billingAddressId?: SortOrderInput | SortOrder;
    couponId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    paymentMeta?: PaymentMetaOrderByWithRelationInput;
    items?: OrderItemOrderByRelationAggregateInput;
    shippingAddress?: AddressOrderByWithRelationInput;
    billingAddress?: AddressOrderByWithRelationInput;
    coupon?: CouponOrderByWithRelationInput;
    ReturnRequest?: ReturnRequestOrderByRelationAggregateInput;
    Refund?: RefundOrderByRelationAggregateInput;
  };

  export type OrderWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      orderNumber?: string;
      AND?: OrderWhereInput | OrderWhereInput[];
      OR?: OrderWhereInput[];
      NOT?: OrderWhereInput | OrderWhereInput[];
      userId?: IntNullableFilter<"Order"> | number | null;
      status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus;
      subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string;
      shipping?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string;
      tax?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string;
      total?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string;
      paymentMethod?: EnumPaymentMethodFilter<"Order"> | $Enums.PaymentMethod;
      shippingAddressId?: IntNullableFilter<"Order"> | number | null;
      billingAddressId?: IntNullableFilter<"Order"> | number | null;
      couponId?: IntNullableFilter<"Order"> | number | null;
      createdAt?: DateTimeFilter<"Order"> | Date | string;
      updatedAt?: DateTimeFilter<"Order"> | Date | string;
      user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      paymentMeta?: XOR<PaymentMetaNullableScalarRelationFilter, PaymentMetaWhereInput> | null;
      items?: OrderItemListRelationFilter;
      shippingAddress?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null;
      billingAddress?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null;
      coupon?: XOR<CouponNullableScalarRelationFilter, CouponWhereInput> | null;
      ReturnRequest?: ReturnRequestListRelationFilter;
      Refund?: RefundListRelationFilter;
    },
    "id" | "orderNumber"
  >;

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder;
    orderNumber?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    status?: SortOrder;
    subtotal?: SortOrder;
    shipping?: SortOrder;
    tax?: SortOrder;
    total?: SortOrder;
    paymentMethod?: SortOrder;
    shippingAddressId?: SortOrderInput | SortOrder;
    billingAddressId?: SortOrderInput | SortOrder;
    couponId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: OrderCountOrderByAggregateInput;
    _avg?: OrderAvgOrderByAggregateInput;
    _max?: OrderMaxOrderByAggregateInput;
    _min?: OrderMinOrderByAggregateInput;
    _sum?: OrderSumOrderByAggregateInput;
  };

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[];
    OR?: OrderScalarWhereWithAggregatesInput[];
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Order"> | number;
    orderNumber?: StringWithAggregatesFilter<"Order"> | string;
    userId?: IntNullableWithAggregatesFilter<"Order"> | number | null;
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus;
    subtotal?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string;
    tax?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string;
    total?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Order"> | $Enums.PaymentMethod;
    shippingAddressId?: IntNullableWithAggregatesFilter<"Order"> | number | null;
    billingAddressId?: IntNullableWithAggregatesFilter<"Order"> | number | null;
    couponId?: IntNullableWithAggregatesFilter<"Order"> | number | null;
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string;
  };

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[];
    OR?: OrderItemWhereInput[];
    NOT?: OrderItemWhereInput | OrderItemWhereInput[];
    id?: IntFilter<"OrderItem"> | number;
    orderId?: IntFilter<"OrderItem"> | number;
    productId?: IntNullableFilter<"OrderItem"> | number | null;
    variantId?: IntNullableFilter<"OrderItem"> | number | null;
    sku?: StringNullableFilter<"OrderItem"> | string | null;
    name?: StringFilter<"OrderItem"> | string;
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string;
    quantity?: IntFilter<"OrderItem"> | number;
    total?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string;
    returned?: BoolFilter<"OrderItem"> | boolean;
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string;
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>;
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null;
    variant?: XOR<ProductVariantNullableScalarRelationFilter, ProductVariantWhereInput> | null;
    ReturnRequest?: ReturnRequestListRelationFilter;
  };

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    productId?: SortOrderInput | SortOrder;
    variantId?: SortOrderInput | SortOrder;
    sku?: SortOrderInput | SortOrder;
    name?: SortOrder;
    price?: SortOrder;
    quantity?: SortOrder;
    total?: SortOrder;
    returned?: SortOrder;
    createdAt?: SortOrder;
    order?: OrderOrderByWithRelationInput;
    product?: ProductOrderByWithRelationInput;
    variant?: ProductVariantOrderByWithRelationInput;
    ReturnRequest?: ReturnRequestOrderByRelationAggregateInput;
  };

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: OrderItemWhereInput | OrderItemWhereInput[];
      OR?: OrderItemWhereInput[];
      NOT?: OrderItemWhereInput | OrderItemWhereInput[];
      orderId?: IntFilter<"OrderItem"> | number;
      productId?: IntNullableFilter<"OrderItem"> | number | null;
      variantId?: IntNullableFilter<"OrderItem"> | number | null;
      sku?: StringNullableFilter<"OrderItem"> | string | null;
      name?: StringFilter<"OrderItem"> | string;
      price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string;
      quantity?: IntFilter<"OrderItem"> | number;
      total?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string;
      returned?: BoolFilter<"OrderItem"> | boolean;
      createdAt?: DateTimeFilter<"OrderItem"> | Date | string;
      order?: XOR<OrderScalarRelationFilter, OrderWhereInput>;
      product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null;
      variant?: XOR<ProductVariantNullableScalarRelationFilter, ProductVariantWhereInput> | null;
      ReturnRequest?: ReturnRequestListRelationFilter;
    },
    "id"
  >;

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    productId?: SortOrderInput | SortOrder;
    variantId?: SortOrderInput | SortOrder;
    sku?: SortOrderInput | SortOrder;
    name?: SortOrder;
    price?: SortOrder;
    quantity?: SortOrder;
    total?: SortOrder;
    returned?: SortOrder;
    createdAt?: SortOrder;
    _count?: OrderItemCountOrderByAggregateInput;
    _avg?: OrderItemAvgOrderByAggregateInput;
    _max?: OrderItemMaxOrderByAggregateInput;
    _min?: OrderItemMinOrderByAggregateInput;
    _sum?: OrderItemSumOrderByAggregateInput;
  };

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[];
    OR?: OrderItemScalarWhereWithAggregatesInput[];
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"OrderItem"> | number;
    orderId?: IntWithAggregatesFilter<"OrderItem"> | number;
    productId?: IntNullableWithAggregatesFilter<"OrderItem"> | number | null;
    variantId?: IntNullableWithAggregatesFilter<"OrderItem"> | number | null;
    sku?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null;
    name?: StringWithAggregatesFilter<"OrderItem"> | string;
    price?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string;
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number;
    total?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string;
    returned?: BoolWithAggregatesFilter<"OrderItem"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string;
  };

  export type CouponWhereInput = {
    AND?: CouponWhereInput | CouponWhereInput[];
    OR?: CouponWhereInput[];
    NOT?: CouponWhereInput | CouponWhereInput[];
    id?: IntFilter<"Coupon"> | number;
    code?: StringFilter<"Coupon"> | string;
    type?: EnumCouponTypeFilter<"Coupon"> | $Enums.CouponType;
    amount?: DecimalNullableFilter<"Coupon"> | Decimal | DecimalJsLike | number | string | null;
    percent?: IntNullableFilter<"Coupon"> | number | null;
    description?: StringNullableFilter<"Coupon"> | string | null;
    startsAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null;
    expiresAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null;
    usageLimit?: IntNullableFilter<"Coupon"> | number | null;
    usagePerUser?: IntNullableFilter<"Coupon"> | number | null;
    timesUsed?: IntFilter<"Coupon"> | number;
    active?: BoolFilter<"Coupon"> | boolean;
    metadata?: JsonNullableFilter<"Coupon">;
    createdAt?: DateTimeFilter<"Coupon"> | Date | string;
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string;
    Order?: OrderListRelationFilter;
  };

  export type CouponOrderByWithRelationInput = {
    id?: SortOrder;
    code?: SortOrder;
    type?: SortOrder;
    amount?: SortOrderInput | SortOrder;
    percent?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    startsAt?: SortOrderInput | SortOrder;
    expiresAt?: SortOrderInput | SortOrder;
    usageLimit?: SortOrderInput | SortOrder;
    usagePerUser?: SortOrderInput | SortOrder;
    timesUsed?: SortOrder;
    active?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    Order?: OrderOrderByRelationAggregateInput;
  };

  export type CouponWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      code?: string;
      AND?: CouponWhereInput | CouponWhereInput[];
      OR?: CouponWhereInput[];
      NOT?: CouponWhereInput | CouponWhereInput[];
      type?: EnumCouponTypeFilter<"Coupon"> | $Enums.CouponType;
      amount?: DecimalNullableFilter<"Coupon"> | Decimal | DecimalJsLike | number | string | null;
      percent?: IntNullableFilter<"Coupon"> | number | null;
      description?: StringNullableFilter<"Coupon"> | string | null;
      startsAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null;
      expiresAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null;
      usageLimit?: IntNullableFilter<"Coupon"> | number | null;
      usagePerUser?: IntNullableFilter<"Coupon"> | number | null;
      timesUsed?: IntFilter<"Coupon"> | number;
      active?: BoolFilter<"Coupon"> | boolean;
      metadata?: JsonNullableFilter<"Coupon">;
      createdAt?: DateTimeFilter<"Coupon"> | Date | string;
      updatedAt?: DateTimeFilter<"Coupon"> | Date | string;
      Order?: OrderListRelationFilter;
    },
    "id" | "code"
  >;

  export type CouponOrderByWithAggregationInput = {
    id?: SortOrder;
    code?: SortOrder;
    type?: SortOrder;
    amount?: SortOrderInput | SortOrder;
    percent?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    startsAt?: SortOrderInput | SortOrder;
    expiresAt?: SortOrderInput | SortOrder;
    usageLimit?: SortOrderInput | SortOrder;
    usagePerUser?: SortOrderInput | SortOrder;
    timesUsed?: SortOrder;
    active?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: CouponCountOrderByAggregateInput;
    _avg?: CouponAvgOrderByAggregateInput;
    _max?: CouponMaxOrderByAggregateInput;
    _min?: CouponMinOrderByAggregateInput;
    _sum?: CouponSumOrderByAggregateInput;
  };

  export type CouponScalarWhereWithAggregatesInput = {
    AND?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[];
    OR?: CouponScalarWhereWithAggregatesInput[];
    NOT?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Coupon"> | number;
    code?: StringWithAggregatesFilter<"Coupon"> | string;
    type?: EnumCouponTypeWithAggregatesFilter<"Coupon"> | $Enums.CouponType;
    amount?: DecimalNullableWithAggregatesFilter<"Coupon"> | Decimal | DecimalJsLike | number | string | null;
    percent?: IntNullableWithAggregatesFilter<"Coupon"> | number | null;
    description?: StringNullableWithAggregatesFilter<"Coupon"> | string | null;
    startsAt?: DateTimeNullableWithAggregatesFilter<"Coupon"> | Date | string | null;
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Coupon"> | Date | string | null;
    usageLimit?: IntNullableWithAggregatesFilter<"Coupon"> | number | null;
    usagePerUser?: IntNullableWithAggregatesFilter<"Coupon"> | number | null;
    timesUsed?: IntWithAggregatesFilter<"Coupon"> | number;
    active?: BoolWithAggregatesFilter<"Coupon"> | boolean;
    metadata?: JsonNullableWithAggregatesFilter<"Coupon">;
    createdAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string;
  };

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[];
    OR?: ReviewWhereInput[];
    NOT?: ReviewWhereInput | ReviewWhereInput[];
    id?: IntFilter<"Review"> | number;
    userId?: IntNullableFilter<"Review"> | number | null;
    productId?: IntFilter<"Review"> | number;
    rating?: IntFilter<"Review"> | number;
    title?: StringNullableFilter<"Review"> | string | null;
    body?: StringNullableFilter<"Review"> | string | null;
    approved?: BoolFilter<"Review"> | boolean;
    createdAt?: DateTimeFilter<"Review"> | Date | string;
    updatedAt?: DateTimeFilter<"Review"> | Date | string;
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>;
  };

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    productId?: SortOrder;
    rating?: SortOrder;
    title?: SortOrderInput | SortOrder;
    body?: SortOrderInput | SortOrder;
    approved?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    product?: ProductOrderByWithRelationInput;
  };

  export type ReviewWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      userId_productId?: ReviewUserIdProductIdCompoundUniqueInput;
      AND?: ReviewWhereInput | ReviewWhereInput[];
      OR?: ReviewWhereInput[];
      NOT?: ReviewWhereInput | ReviewWhereInput[];
      userId?: IntNullableFilter<"Review"> | number | null;
      productId?: IntFilter<"Review"> | number;
      rating?: IntFilter<"Review"> | number;
      title?: StringNullableFilter<"Review"> | string | null;
      body?: StringNullableFilter<"Review"> | string | null;
      approved?: BoolFilter<"Review"> | boolean;
      createdAt?: DateTimeFilter<"Review"> | Date | string;
      updatedAt?: DateTimeFilter<"Review"> | Date | string;
      user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      product?: XOR<ProductScalarRelationFilter, ProductWhereInput>;
    },
    "id" | "userId_productId"
  >;

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    productId?: SortOrder;
    rating?: SortOrder;
    title?: SortOrderInput | SortOrder;
    body?: SortOrderInput | SortOrder;
    approved?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ReviewCountOrderByAggregateInput;
    _avg?: ReviewAvgOrderByAggregateInput;
    _max?: ReviewMaxOrderByAggregateInput;
    _min?: ReviewMinOrderByAggregateInput;
    _sum?: ReviewSumOrderByAggregateInput;
  };

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[];
    OR?: ReviewScalarWhereWithAggregatesInput[];
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Review"> | number;
    userId?: IntNullableWithAggregatesFilter<"Review"> | number | null;
    productId?: IntWithAggregatesFilter<"Review"> | number;
    rating?: IntWithAggregatesFilter<"Review"> | number;
    title?: StringNullableWithAggregatesFilter<"Review"> | string | null;
    body?: StringNullableWithAggregatesFilter<"Review"> | string | null;
    approved?: BoolWithAggregatesFilter<"Review"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string;
  };

  export type WishlistWhereInput = {
    AND?: WishlistWhereInput | WishlistWhereInput[];
    OR?: WishlistWhereInput[];
    NOT?: WishlistWhereInput | WishlistWhereInput[];
    id?: IntFilter<"Wishlist"> | number;
    userId?: IntFilter<"Wishlist"> | number;
    createdAt?: DateTimeFilter<"Wishlist"> | Date | string;
    updatedAt?: DateTimeFilter<"Wishlist"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    items?: WishlistItemListRelationFilter;
  };

  export type WishlistOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    items?: WishlistItemOrderByRelationAggregateInput;
  };

  export type WishlistWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      userId?: number;
      AND?: WishlistWhereInput | WishlistWhereInput[];
      OR?: WishlistWhereInput[];
      NOT?: WishlistWhereInput | WishlistWhereInput[];
      createdAt?: DateTimeFilter<"Wishlist"> | Date | string;
      updatedAt?: DateTimeFilter<"Wishlist"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      items?: WishlistItemListRelationFilter;
    },
    "id" | "userId"
  >;

  export type WishlistOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: WishlistCountOrderByAggregateInput;
    _avg?: WishlistAvgOrderByAggregateInput;
    _max?: WishlistMaxOrderByAggregateInput;
    _min?: WishlistMinOrderByAggregateInput;
    _sum?: WishlistSumOrderByAggregateInput;
  };

  export type WishlistScalarWhereWithAggregatesInput = {
    AND?: WishlistScalarWhereWithAggregatesInput | WishlistScalarWhereWithAggregatesInput[];
    OR?: WishlistScalarWhereWithAggregatesInput[];
    NOT?: WishlistScalarWhereWithAggregatesInput | WishlistScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Wishlist"> | number;
    userId?: IntWithAggregatesFilter<"Wishlist"> | number;
    createdAt?: DateTimeWithAggregatesFilter<"Wishlist"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Wishlist"> | Date | string;
  };

  export type WishlistItemWhereInput = {
    AND?: WishlistItemWhereInput | WishlistItemWhereInput[];
    OR?: WishlistItemWhereInput[];
    NOT?: WishlistItemWhereInput | WishlistItemWhereInput[];
    id?: IntFilter<"WishlistItem"> | number;
    wishlistId?: IntFilter<"WishlistItem"> | number;
    productId?: IntFilter<"WishlistItem"> | number;
    variantId?: IntNullableFilter<"WishlistItem"> | number | null;
    createdAt?: DateTimeFilter<"WishlistItem"> | Date | string;
    wishlist?: XOR<WishlistScalarRelationFilter, WishlistWhereInput>;
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>;
  };

  export type WishlistItemOrderByWithRelationInput = {
    id?: SortOrder;
    wishlistId?: SortOrder;
    productId?: SortOrder;
    variantId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    wishlist?: WishlistOrderByWithRelationInput;
    product?: ProductOrderByWithRelationInput;
  };

  export type WishlistItemWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      wishlistId_productId_variantId?: WishlistItemWishlistIdProductIdVariantIdCompoundUniqueInput;
      AND?: WishlistItemWhereInput | WishlistItemWhereInput[];
      OR?: WishlistItemWhereInput[];
      NOT?: WishlistItemWhereInput | WishlistItemWhereInput[];
      wishlistId?: IntFilter<"WishlistItem"> | number;
      productId?: IntFilter<"WishlistItem"> | number;
      variantId?: IntNullableFilter<"WishlistItem"> | number | null;
      createdAt?: DateTimeFilter<"WishlistItem"> | Date | string;
      wishlist?: XOR<WishlistScalarRelationFilter, WishlistWhereInput>;
      product?: XOR<ProductScalarRelationFilter, ProductWhereInput>;
    },
    "id" | "wishlistId_productId_variantId"
  >;

  export type WishlistItemOrderByWithAggregationInput = {
    id?: SortOrder;
    wishlistId?: SortOrder;
    productId?: SortOrder;
    variantId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: WishlistItemCountOrderByAggregateInput;
    _avg?: WishlistItemAvgOrderByAggregateInput;
    _max?: WishlistItemMaxOrderByAggregateInput;
    _min?: WishlistItemMinOrderByAggregateInput;
    _sum?: WishlistItemSumOrderByAggregateInput;
  };

  export type WishlistItemScalarWhereWithAggregatesInput = {
    AND?: WishlistItemScalarWhereWithAggregatesInput | WishlistItemScalarWhereWithAggregatesInput[];
    OR?: WishlistItemScalarWhereWithAggregatesInput[];
    NOT?: WishlistItemScalarWhereWithAggregatesInput | WishlistItemScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"WishlistItem"> | number;
    wishlistId?: IntWithAggregatesFilter<"WishlistItem"> | number;
    productId?: IntWithAggregatesFilter<"WishlistItem"> | number;
    variantId?: IntNullableWithAggregatesFilter<"WishlistItem"> | number | null;
    createdAt?: DateTimeWithAggregatesFilter<"WishlistItem"> | Date | string;
  };

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[];
    OR?: AddressWhereInput[];
    NOT?: AddressWhereInput | AddressWhereInput[];
    id?: IntFilter<"Address"> | number;
    userId?: IntNullableFilter<"Address"> | number | null;
    fullName?: StringFilter<"Address"> | string;
    line1?: StringFilter<"Address"> | string;
    line2?: StringNullableFilter<"Address"> | string | null;
    city?: StringFilter<"Address"> | string;
    province?: StringNullableFilter<"Address"> | string | null;
    postalCode?: StringNullableFilter<"Address"> | string | null;
    country?: StringFilter<"Address"> | string;
    phone?: StringNullableFilter<"Address"> | string | null;
    metadata?: JsonNullableFilter<"Address">;
    isDefaultShipping?: BoolFilter<"Address"> | boolean;
    isDefaultBilling?: BoolFilter<"Address"> | boolean;
    createdAt?: DateTimeFilter<"Address"> | Date | string;
    updatedAt?: DateTimeFilter<"Address"> | Date | string;
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    ordersShipping?: OrderListRelationFilter;
    ordersBilling?: OrderListRelationFilter;
  };

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    fullName?: SortOrder;
    line1?: SortOrder;
    line2?: SortOrderInput | SortOrder;
    city?: SortOrder;
    province?: SortOrderInput | SortOrder;
    postalCode?: SortOrderInput | SortOrder;
    country?: SortOrder;
    phone?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    isDefaultShipping?: SortOrder;
    isDefaultBilling?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    ordersShipping?: OrderOrderByRelationAggregateInput;
    ordersBilling?: OrderOrderByRelationAggregateInput;
  };

  export type AddressWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: AddressWhereInput | AddressWhereInput[];
      OR?: AddressWhereInput[];
      NOT?: AddressWhereInput | AddressWhereInput[];
      userId?: IntNullableFilter<"Address"> | number | null;
      fullName?: StringFilter<"Address"> | string;
      line1?: StringFilter<"Address"> | string;
      line2?: StringNullableFilter<"Address"> | string | null;
      city?: StringFilter<"Address"> | string;
      province?: StringNullableFilter<"Address"> | string | null;
      postalCode?: StringNullableFilter<"Address"> | string | null;
      country?: StringFilter<"Address"> | string;
      phone?: StringNullableFilter<"Address"> | string | null;
      metadata?: JsonNullableFilter<"Address">;
      isDefaultShipping?: BoolFilter<"Address"> | boolean;
      isDefaultBilling?: BoolFilter<"Address"> | boolean;
      createdAt?: DateTimeFilter<"Address"> | Date | string;
      updatedAt?: DateTimeFilter<"Address"> | Date | string;
      user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      ordersShipping?: OrderListRelationFilter;
      ordersBilling?: OrderListRelationFilter;
    },
    "id"
  >;

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    fullName?: SortOrder;
    line1?: SortOrder;
    line2?: SortOrderInput | SortOrder;
    city?: SortOrder;
    province?: SortOrderInput | SortOrder;
    postalCode?: SortOrderInput | SortOrder;
    country?: SortOrder;
    phone?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    isDefaultShipping?: SortOrder;
    isDefaultBilling?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: AddressCountOrderByAggregateInput;
    _avg?: AddressAvgOrderByAggregateInput;
    _max?: AddressMaxOrderByAggregateInput;
    _min?: AddressMinOrderByAggregateInput;
    _sum?: AddressSumOrderByAggregateInput;
  };

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[];
    OR?: AddressScalarWhereWithAggregatesInput[];
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Address"> | number;
    userId?: IntNullableWithAggregatesFilter<"Address"> | number | null;
    fullName?: StringWithAggregatesFilter<"Address"> | string;
    line1?: StringWithAggregatesFilter<"Address"> | string;
    line2?: StringNullableWithAggregatesFilter<"Address"> | string | null;
    city?: StringWithAggregatesFilter<"Address"> | string;
    province?: StringNullableWithAggregatesFilter<"Address"> | string | null;
    postalCode?: StringNullableWithAggregatesFilter<"Address"> | string | null;
    country?: StringWithAggregatesFilter<"Address"> | string;
    phone?: StringNullableWithAggregatesFilter<"Address"> | string | null;
    metadata?: JsonNullableWithAggregatesFilter<"Address">;
    isDefaultShipping?: BoolWithAggregatesFilter<"Address"> | boolean;
    isDefaultBilling?: BoolWithAggregatesFilter<"Address"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string;
  };

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[];
    OR?: AuditLogWhereInput[];
    NOT?: AuditLogWhereInput | AuditLogWhereInput[];
    id?: IntFilter<"AuditLog"> | number;
    actorId?: IntNullableFilter<"AuditLog"> | number | null;
    action?: StringFilter<"AuditLog"> | string;
    entity?: StringFilter<"AuditLog"> | string;
    entityId?: StringNullableFilter<"AuditLog"> | string | null;
    changes?: JsonNullableFilter<"AuditLog">;
    ip?: StringNullableFilter<"AuditLog"> | string | null;
    userAgent?: StringNullableFilter<"AuditLog"> | string | null;
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string;
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder;
    actorId?: SortOrderInput | SortOrder;
    action?: SortOrder;
    entity?: SortOrder;
    entityId?: SortOrderInput | SortOrder;
    changes?: SortOrderInput | SortOrder;
    ip?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    actor?: UserOrderByWithRelationInput;
  };

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: AuditLogWhereInput | AuditLogWhereInput[];
      OR?: AuditLogWhereInput[];
      NOT?: AuditLogWhereInput | AuditLogWhereInput[];
      actorId?: IntNullableFilter<"AuditLog"> | number | null;
      action?: StringFilter<"AuditLog"> | string;
      entity?: StringFilter<"AuditLog"> | string;
      entityId?: StringNullableFilter<"AuditLog"> | string | null;
      changes?: JsonNullableFilter<"AuditLog">;
      ip?: StringNullableFilter<"AuditLog"> | string | null;
      userAgent?: StringNullableFilter<"AuditLog"> | string | null;
      createdAt?: DateTimeFilter<"AuditLog"> | Date | string;
      actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    "id"
  >;

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder;
    actorId?: SortOrderInput | SortOrder;
    action?: SortOrder;
    entity?: SortOrder;
    entityId?: SortOrderInput | SortOrder;
    changes?: SortOrderInput | SortOrder;
    ip?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: AuditLogCountOrderByAggregateInput;
    _avg?: AuditLogAvgOrderByAggregateInput;
    _max?: AuditLogMaxOrderByAggregateInput;
    _min?: AuditLogMinOrderByAggregateInput;
    _sum?: AuditLogSumOrderByAggregateInput;
  };

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[];
    OR?: AuditLogScalarWhereWithAggregatesInput[];
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"AuditLog"> | number;
    actorId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null;
    action?: StringWithAggregatesFilter<"AuditLog"> | string;
    entity?: StringWithAggregatesFilter<"AuditLog"> | string;
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null;
    changes?: JsonNullableWithAggregatesFilter<"AuditLog">;
    ip?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null;
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string;
  };

  export type ReturnRequestWhereInput = {
    AND?: ReturnRequestWhereInput | ReturnRequestWhereInput[];
    OR?: ReturnRequestWhereInput[];
    NOT?: ReturnRequestWhereInput | ReturnRequestWhereInput[];
    id?: IntFilter<"ReturnRequest"> | number;
    orderId?: IntFilter<"ReturnRequest"> | number;
    orderItemId?: IntFilter<"ReturnRequest"> | number;
    reason?: StringFilter<"ReturnRequest"> | string;
    status?: EnumReturnStatusFilter<"ReturnRequest"> | $Enums.ReturnStatus;
    evidence?: JsonNullableFilter<"ReturnRequest">;
    requestedAt?: DateTimeFilter<"ReturnRequest"> | Date | string;
    processedAt?: DateTimeNullableFilter<"ReturnRequest"> | Date | string | null;
    metadata?: JsonNullableFilter<"ReturnRequest">;
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>;
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>;
    refund?: XOR<RefundNullableScalarRelationFilter, RefundWhereInput> | null;
  };

  export type ReturnRequestOrderByWithRelationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    orderItemId?: SortOrder;
    reason?: SortOrder;
    status?: SortOrder;
    evidence?: SortOrderInput | SortOrder;
    requestedAt?: SortOrder;
    processedAt?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    order?: OrderOrderByWithRelationInput;
    orderItem?: OrderItemOrderByWithRelationInput;
    refund?: RefundOrderByWithRelationInput;
  };

  export type ReturnRequestWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: ReturnRequestWhereInput | ReturnRequestWhereInput[];
      OR?: ReturnRequestWhereInput[];
      NOT?: ReturnRequestWhereInput | ReturnRequestWhereInput[];
      orderId?: IntFilter<"ReturnRequest"> | number;
      orderItemId?: IntFilter<"ReturnRequest"> | number;
      reason?: StringFilter<"ReturnRequest"> | string;
      status?: EnumReturnStatusFilter<"ReturnRequest"> | $Enums.ReturnStatus;
      evidence?: JsonNullableFilter<"ReturnRequest">;
      requestedAt?: DateTimeFilter<"ReturnRequest"> | Date | string;
      processedAt?: DateTimeNullableFilter<"ReturnRequest"> | Date | string | null;
      metadata?: JsonNullableFilter<"ReturnRequest">;
      order?: XOR<OrderScalarRelationFilter, OrderWhereInput>;
      orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>;
      refund?: XOR<RefundNullableScalarRelationFilter, RefundWhereInput> | null;
    },
    "id"
  >;

  export type ReturnRequestOrderByWithAggregationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    orderItemId?: SortOrder;
    reason?: SortOrder;
    status?: SortOrder;
    evidence?: SortOrderInput | SortOrder;
    requestedAt?: SortOrder;
    processedAt?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    _count?: ReturnRequestCountOrderByAggregateInput;
    _avg?: ReturnRequestAvgOrderByAggregateInput;
    _max?: ReturnRequestMaxOrderByAggregateInput;
    _min?: ReturnRequestMinOrderByAggregateInput;
    _sum?: ReturnRequestSumOrderByAggregateInput;
  };

  export type ReturnRequestScalarWhereWithAggregatesInput = {
    AND?: ReturnRequestScalarWhereWithAggregatesInput | ReturnRequestScalarWhereWithAggregatesInput[];
    OR?: ReturnRequestScalarWhereWithAggregatesInput[];
    NOT?: ReturnRequestScalarWhereWithAggregatesInput | ReturnRequestScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"ReturnRequest"> | number;
    orderId?: IntWithAggregatesFilter<"ReturnRequest"> | number;
    orderItemId?: IntWithAggregatesFilter<"ReturnRequest"> | number;
    reason?: StringWithAggregatesFilter<"ReturnRequest"> | string;
    status?: EnumReturnStatusWithAggregatesFilter<"ReturnRequest"> | $Enums.ReturnStatus;
    evidence?: JsonNullableWithAggregatesFilter<"ReturnRequest">;
    requestedAt?: DateTimeWithAggregatesFilter<"ReturnRequest"> | Date | string;
    processedAt?: DateTimeNullableWithAggregatesFilter<"ReturnRequest"> | Date | string | null;
    metadata?: JsonNullableWithAggregatesFilter<"ReturnRequest">;
  };

  export type RefundWhereInput = {
    AND?: RefundWhereInput | RefundWhereInput[];
    OR?: RefundWhereInput[];
    NOT?: RefundWhereInput | RefundWhereInput[];
    id?: IntFilter<"Refund"> | number;
    orderId?: IntFilter<"Refund"> | number;
    returnRequestId?: IntNullableFilter<"Refund"> | number | null;
    amount?: DecimalFilter<"Refund"> | Decimal | DecimalJsLike | number | string;
    method?: StringFilter<"Refund"> | string;
    status?: EnumRefundStatusFilter<"Refund"> | $Enums.RefundStatus;
    providerRef?: StringNullableFilter<"Refund"> | string | null;
    metadata?: JsonNullableFilter<"Refund">;
    createdAt?: DateTimeFilter<"Refund"> | Date | string;
    processedAt?: DateTimeNullableFilter<"Refund"> | Date | string | null;
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>;
    returnRequest?: XOR<ReturnRequestNullableScalarRelationFilter, ReturnRequestWhereInput> | null;
  };

  export type RefundOrderByWithRelationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    returnRequestId?: SortOrderInput | SortOrder;
    amount?: SortOrder;
    method?: SortOrder;
    status?: SortOrder;
    providerRef?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    processedAt?: SortOrderInput | SortOrder;
    order?: OrderOrderByWithRelationInput;
    returnRequest?: ReturnRequestOrderByWithRelationInput;
  };

  export type RefundWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      returnRequestId?: number;
      AND?: RefundWhereInput | RefundWhereInput[];
      OR?: RefundWhereInput[];
      NOT?: RefundWhereInput | RefundWhereInput[];
      orderId?: IntFilter<"Refund"> | number;
      amount?: DecimalFilter<"Refund"> | Decimal | DecimalJsLike | number | string;
      method?: StringFilter<"Refund"> | string;
      status?: EnumRefundStatusFilter<"Refund"> | $Enums.RefundStatus;
      providerRef?: StringNullableFilter<"Refund"> | string | null;
      metadata?: JsonNullableFilter<"Refund">;
      createdAt?: DateTimeFilter<"Refund"> | Date | string;
      processedAt?: DateTimeNullableFilter<"Refund"> | Date | string | null;
      order?: XOR<OrderScalarRelationFilter, OrderWhereInput>;
      returnRequest?: XOR<ReturnRequestNullableScalarRelationFilter, ReturnRequestWhereInput> | null;
    },
    "id" | "returnRequestId"
  >;

  export type RefundOrderByWithAggregationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    returnRequestId?: SortOrderInput | SortOrder;
    amount?: SortOrder;
    method?: SortOrder;
    status?: SortOrder;
    providerRef?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    processedAt?: SortOrderInput | SortOrder;
    _count?: RefundCountOrderByAggregateInput;
    _avg?: RefundAvgOrderByAggregateInput;
    _max?: RefundMaxOrderByAggregateInput;
    _min?: RefundMinOrderByAggregateInput;
    _sum?: RefundSumOrderByAggregateInput;
  };

  export type RefundScalarWhereWithAggregatesInput = {
    AND?: RefundScalarWhereWithAggregatesInput | RefundScalarWhereWithAggregatesInput[];
    OR?: RefundScalarWhereWithAggregatesInput[];
    NOT?: RefundScalarWhereWithAggregatesInput | RefundScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Refund"> | number;
    orderId?: IntWithAggregatesFilter<"Refund"> | number;
    returnRequestId?: IntNullableWithAggregatesFilter<"Refund"> | number | null;
    amount?: DecimalWithAggregatesFilter<"Refund"> | Decimal | DecimalJsLike | number | string;
    method?: StringWithAggregatesFilter<"Refund"> | string;
    status?: EnumRefundStatusWithAggregatesFilter<"Refund"> | $Enums.RefundStatus;
    providerRef?: StringNullableWithAggregatesFilter<"Refund"> | string | null;
    metadata?: JsonNullableWithAggregatesFilter<"Refund">;
    createdAt?: DateTimeWithAggregatesFilter<"Refund"> | Date | string;
    processedAt?: DateTimeNullableWithAggregatesFilter<"Refund"> | Date | string | null;
  };

  export type PaymentMetaWhereInput = {
    AND?: PaymentMetaWhereInput | PaymentMetaWhereInput[];
    OR?: PaymentMetaWhereInput[];
    NOT?: PaymentMetaWhereInput | PaymentMetaWhereInput[];
    id?: IntFilter<"PaymentMeta"> | number;
    orderId?: IntFilter<"PaymentMeta"> | number;
    provider?: StringFilter<"PaymentMeta"> | string;
    transactionId?: StringNullableFilter<"PaymentMeta"> | string | null;
    status?: StringFilter<"PaymentMeta"> | string;
    amount?: DecimalFilter<"PaymentMeta"> | Decimal | DecimalJsLike | number | string;
    raw?: JsonNullableFilter<"PaymentMeta">;
    capturedAt?: DateTimeNullableFilter<"PaymentMeta"> | Date | string | null;
    createdAt?: DateTimeFilter<"PaymentMeta"> | Date | string;
    updatedAt?: DateTimeFilter<"PaymentMeta"> | Date | string;
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>;
  };

  export type PaymentMetaOrderByWithRelationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    provider?: SortOrder;
    transactionId?: SortOrderInput | SortOrder;
    status?: SortOrder;
    amount?: SortOrder;
    raw?: SortOrderInput | SortOrder;
    capturedAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    order?: OrderOrderByWithRelationInput;
  };

  export type PaymentMetaWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      orderId?: number;
      AND?: PaymentMetaWhereInput | PaymentMetaWhereInput[];
      OR?: PaymentMetaWhereInput[];
      NOT?: PaymentMetaWhereInput | PaymentMetaWhereInput[];
      provider?: StringFilter<"PaymentMeta"> | string;
      transactionId?: StringNullableFilter<"PaymentMeta"> | string | null;
      status?: StringFilter<"PaymentMeta"> | string;
      amount?: DecimalFilter<"PaymentMeta"> | Decimal | DecimalJsLike | number | string;
      raw?: JsonNullableFilter<"PaymentMeta">;
      capturedAt?: DateTimeNullableFilter<"PaymentMeta"> | Date | string | null;
      createdAt?: DateTimeFilter<"PaymentMeta"> | Date | string;
      updatedAt?: DateTimeFilter<"PaymentMeta"> | Date | string;
      order?: XOR<OrderScalarRelationFilter, OrderWhereInput>;
    },
    "id" | "orderId"
  >;

  export type PaymentMetaOrderByWithAggregationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    provider?: SortOrder;
    transactionId?: SortOrderInput | SortOrder;
    status?: SortOrder;
    amount?: SortOrder;
    raw?: SortOrderInput | SortOrder;
    capturedAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: PaymentMetaCountOrderByAggregateInput;
    _avg?: PaymentMetaAvgOrderByAggregateInput;
    _max?: PaymentMetaMaxOrderByAggregateInput;
    _min?: PaymentMetaMinOrderByAggregateInput;
    _sum?: PaymentMetaSumOrderByAggregateInput;
  };

  export type PaymentMetaScalarWhereWithAggregatesInput = {
    AND?: PaymentMetaScalarWhereWithAggregatesInput | PaymentMetaScalarWhereWithAggregatesInput[];
    OR?: PaymentMetaScalarWhereWithAggregatesInput[];
    NOT?: PaymentMetaScalarWhereWithAggregatesInput | PaymentMetaScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"PaymentMeta"> | number;
    orderId?: IntWithAggregatesFilter<"PaymentMeta"> | number;
    provider?: StringWithAggregatesFilter<"PaymentMeta"> | string;
    transactionId?: StringNullableWithAggregatesFilter<"PaymentMeta"> | string | null;
    status?: StringWithAggregatesFilter<"PaymentMeta"> | string;
    amount?: DecimalWithAggregatesFilter<"PaymentMeta"> | Decimal | DecimalJsLike | number | string;
    raw?: JsonNullableWithAggregatesFilter<"PaymentMeta">;
    capturedAt?: DateTimeNullableWithAggregatesFilter<"PaymentMeta"> | Date | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMeta"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMeta"> | Date | string;
  };

  export type UserCreateInput = {
    email: string;
    username?: string | null;
    password?: string | null;
    displayName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    userRoles?: UserRoleCreateNestedManyWithoutUserInput;
    addresses?: AddressCreateNestedManyWithoutUserInput;
    wishlist?: WishlistCreateNestedOneWithoutUserInput;
    reviews?: ReviewCreateNestedManyWithoutUserInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutActorInput;
  };

  export type UserUncheckedCreateInput = {
    id?: number;
    email: string;
    username?: string | null;
    password?: string | null;
    displayName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput;
    wishlist?: WishlistUncheckedCreateNestedOneWithoutUserInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
  };

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput;
    addresses?: AddressUpdateManyWithoutUserNestedInput;
    wishlist?: WishlistUpdateOneWithoutUserNestedInput;
    reviews?: ReviewUpdateManyWithoutUserNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutActorNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput;
    wishlist?: WishlistUncheckedUpdateOneWithoutUserNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
  };

  export type UserCreateManyInput = {
    id?: number;
    email: string;
    username?: string | null;
    password?: string | null;
    displayName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
  };

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type RoleCreateInput = {
    name: string;
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput;
  };

  export type RoleUncheckedCreateInput = {
    id?: number;
    name: string;
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput;
  };

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string;
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput;
  };

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    name?: StringFieldUpdateOperationsInput | string;
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput;
  };

  export type RoleCreateManyInput = {
    id?: number;
    name: string;
  };

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string;
  };

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    name?: StringFieldUpdateOperationsInput | string;
  };

  export type UserRoleCreateInput = {
    user: UserCreateNestedOneWithoutUserRolesInput;
    role: RoleCreateNestedOneWithoutUserRolesInput;
  };

  export type UserRoleUncheckedCreateInput = {
    id?: number;
    userId: number;
    roleId: number;
  };

  export type UserRoleUpdateInput = {
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput;
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput;
  };

  export type UserRoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: IntFieldUpdateOperationsInput | number;
    roleId?: IntFieldUpdateOperationsInput | number;
  };

  export type UserRoleCreateManyInput = {
    id?: number;
    userId: number;
    roleId: number;
  };

  export type UserRoleUpdateManyMutationInput = {};

  export type UserRoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: IntFieldUpdateOperationsInput | number;
    roleId?: IntFieldUpdateOperationsInput | number;
  };

  export type ProductCreateInput = {
    title: string;
    slug: string;
    shortDescription?: string | null;
    description?: string | null;
    status?: $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    images?: ProductImageCreateNestedManyWithoutProductInput;
    variants?: ProductVariantCreateNestedManyWithoutProductInput;
    reviews?: ReviewCreateNestedManyWithoutProductInput;
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput;
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput;
  };

  export type ProductUncheckedCreateInput = {
    id?: number;
    title: string;
    slug: string;
    shortDescription?: string | null;
    description?: string | null;
    status?: $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput;
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput;
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput;
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput;
  };

  export type ProductUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    images?: ProductImageUpdateManyWithoutProductNestedInput;
    variants?: ProductVariantUpdateManyWithoutProductNestedInput;
    reviews?: ReviewUpdateManyWithoutProductNestedInput;
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput;
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput;
  };

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput;
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput;
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput;
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput;
  };

  export type ProductCreateManyInput = {
    id?: number;
    title: string;
    slug: string;
    shortDescription?: string | null;
    description?: string | null;
    status?: $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProductUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductImageCreateInput = {
    url: string;
    alt?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    product: ProductCreateNestedOneWithoutImagesInput;
  };

  export type ProductImageUncheckedCreateInput = {
    id?: number;
    url: string;
    alt?: string | null;
    isPrimary?: boolean;
    productId: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProductImageUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string;
    alt?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    product?: ProductUpdateOneRequiredWithoutImagesNestedInput;
  };

  export type ProductImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    url?: StringFieldUpdateOperationsInput | string;
    alt?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    productId?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductImageCreateManyInput = {
    id?: number;
    url: string;
    alt?: string | null;
    isPrimary?: boolean;
    productId: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProductImageUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string;
    alt?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    url?: StringFieldUpdateOperationsInput | string;
    alt?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    productId?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductVariantCreateInput = {
    name: string;
    skuPrefix?: string | null;
    price: Decimal | DecimalJsLike | number | string;
    compareAtPrice?: Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    product: ProductCreateNestedOneWithoutVariantsInput;
    inventory?: InventoryCreateNestedManyWithoutVariantInput;
    OrderItem?: OrderItemCreateNestedManyWithoutVariantInput;
  };

  export type ProductVariantUncheckedCreateInput = {
    id?: number;
    productId: number;
    name: string;
    skuPrefix?: string | null;
    price: Decimal | DecimalJsLike | number | string;
    compareAtPrice?: Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inventory?: InventoryUncheckedCreateNestedManyWithoutVariantInput;
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutVariantInput;
  };

  export type ProductVariantUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string;
    skuPrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    compareAtPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput;
    inventory?: InventoryUpdateManyWithoutVariantNestedInput;
    OrderItem?: OrderItemUpdateManyWithoutVariantNestedInput;
  };

  export type ProductVariantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    productId?: IntFieldUpdateOperationsInput | number;
    name?: StringFieldUpdateOperationsInput | string;
    skuPrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    compareAtPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inventory?: InventoryUncheckedUpdateManyWithoutVariantNestedInput;
    OrderItem?: OrderItemUncheckedUpdateManyWithoutVariantNestedInput;
  };

  export type ProductVariantCreateManyInput = {
    id?: number;
    productId: number;
    name: string;
    skuPrefix?: string | null;
    price: Decimal | DecimalJsLike | number | string;
    compareAtPrice?: Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProductVariantUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string;
    skuPrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    compareAtPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductVariantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    productId?: IntFieldUpdateOperationsInput | number;
    name?: StringFieldUpdateOperationsInput | string;
    skuPrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    compareAtPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InventoryCreateInput = {
    sku: string;
    quantity?: number;
    reserved?: number;
    location?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    variant: ProductVariantCreateNestedOneWithoutInventoryInput;
  };

  export type InventoryUncheckedCreateInput = {
    id?: number;
    sku: string;
    variantId: number;
    quantity?: number;
    reserved?: number;
    location?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type InventoryUpdateInput = {
    sku?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    reserved?: IntFieldUpdateOperationsInput | number;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    variant?: ProductVariantUpdateOneRequiredWithoutInventoryNestedInput;
  };

  export type InventoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    sku?: StringFieldUpdateOperationsInput | string;
    variantId?: IntFieldUpdateOperationsInput | number;
    quantity?: IntFieldUpdateOperationsInput | number;
    reserved?: IntFieldUpdateOperationsInput | number;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InventoryCreateManyInput = {
    id?: number;
    sku: string;
    variantId: number;
    quantity?: number;
    reserved?: number;
    location?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type InventoryUpdateManyMutationInput = {
    sku?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    reserved?: IntFieldUpdateOperationsInput | number;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InventoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    sku?: StringFieldUpdateOperationsInput | string;
    variantId?: IntFieldUpdateOperationsInput | number;
    quantity?: IntFieldUpdateOperationsInput | number;
    reserved?: IntFieldUpdateOperationsInput | number;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderCreateInput = {
    orderNumber: string;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user?: UserCreateNestedOneWithoutOrdersInput;
    paymentMeta?: PaymentMetaCreateNestedOneWithoutOrderInput;
    items?: OrderItemCreateNestedManyWithoutOrderInput;
    shippingAddress?: AddressCreateNestedOneWithoutOrdersShippingInput;
    billingAddress?: AddressCreateNestedOneWithoutOrdersBillingInput;
    coupon?: CouponCreateNestedOneWithoutOrderInput;
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderInput;
    Refund?: RefundCreateNestedManyWithoutOrderInput;
  };

  export type OrderUncheckedCreateInput = {
    id?: number;
    orderNumber: string;
    userId?: number | null;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    shippingAddressId?: number | null;
    billingAddressId?: number | null;
    couponId?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paymentMeta?: PaymentMetaUncheckedCreateNestedOneWithoutOrderInput;
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput;
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderInput;
    Refund?: RefundUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderUpdateInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutOrdersNestedInput;
    paymentMeta?: PaymentMetaUpdateOneWithoutOrderNestedInput;
    items?: OrderItemUpdateManyWithoutOrderNestedInput;
    shippingAddress?: AddressUpdateOneWithoutOrdersShippingNestedInput;
    billingAddress?: AddressUpdateOneWithoutOrdersBillingNestedInput;
    coupon?: CouponUpdateOneWithoutOrderNestedInput;
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderNestedInput;
    Refund?: RefundUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    shippingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    billingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    couponId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentMeta?: PaymentMetaUncheckedUpdateOneWithoutOrderNestedInput;
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput;
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderNestedInput;
    Refund?: RefundUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderCreateManyInput = {
    id?: number;
    orderNumber: string;
    userId?: number | null;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    shippingAddressId?: number | null;
    billingAddressId?: number | null;
    couponId?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrderUpdateManyMutationInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    shippingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    billingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    couponId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderItemCreateInput = {
    sku?: string | null;
    name: string;
    price: Decimal | DecimalJsLike | number | string;
    quantity: number;
    total: Decimal | DecimalJsLike | number | string;
    returned?: boolean;
    createdAt?: Date | string;
    order: OrderCreateNestedOneWithoutItemsInput;
    product?: ProductCreateNestedOneWithoutOrderItemInput;
    variant?: ProductVariantCreateNestedOneWithoutOrderItemInput;
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderItemInput;
  };

  export type OrderItemUncheckedCreateInput = {
    id?: number;
    orderId: number;
    productId?: number | null;
    variantId?: number | null;
    sku?: string | null;
    name: string;
    price: Decimal | DecimalJsLike | number | string;
    quantity: number;
    total: Decimal | DecimalJsLike | number | string;
    returned?: boolean;
    createdAt?: Date | string;
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderItemInput;
  };

  export type OrderItemUpdateInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    returned?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput;
    product?: ProductUpdateOneWithoutOrderItemNestedInput;
    variant?: ProductVariantUpdateOneWithoutOrderItemNestedInput;
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderItemNestedInput;
  };

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    productId?: NullableIntFieldUpdateOperationsInput | number | null;
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    sku?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    returned?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderItemNestedInput;
  };

  export type OrderItemCreateManyInput = {
    id?: number;
    orderId: number;
    productId?: number | null;
    variantId?: number | null;
    sku?: string | null;
    name: string;
    price: Decimal | DecimalJsLike | number | string;
    quantity: number;
    total: Decimal | DecimalJsLike | number | string;
    returned?: boolean;
    createdAt?: Date | string;
  };

  export type OrderItemUpdateManyMutationInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    returned?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    productId?: NullableIntFieldUpdateOperationsInput | number | null;
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    sku?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    returned?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CouponCreateInput = {
    code: string;
    type: $Enums.CouponType;
    amount?: Decimal | DecimalJsLike | number | string | null;
    percent?: number | null;
    description?: string | null;
    startsAt?: Date | string | null;
    expiresAt?: Date | string | null;
    usageLimit?: number | null;
    usagePerUser?: number | null;
    timesUsed?: number;
    active?: boolean;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Order?: OrderCreateNestedManyWithoutCouponInput;
  };

  export type CouponUncheckedCreateInput = {
    id?: number;
    code: string;
    type: $Enums.CouponType;
    amount?: Decimal | DecimalJsLike | number | string | null;
    percent?: number | null;
    description?: string | null;
    startsAt?: Date | string | null;
    expiresAt?: Date | string | null;
    usageLimit?: number | null;
    usagePerUser?: number | null;
    timesUsed?: number;
    active?: boolean;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Order?: OrderUncheckedCreateNestedManyWithoutCouponInput;
  };

  export type CouponUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string;
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType;
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    percent?: NullableIntFieldUpdateOperationsInput | number | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null;
    usagePerUser?: NullableIntFieldUpdateOperationsInput | number | null;
    timesUsed?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Order?: OrderUpdateManyWithoutCouponNestedInput;
  };

  export type CouponUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    code?: StringFieldUpdateOperationsInput | string;
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType;
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    percent?: NullableIntFieldUpdateOperationsInput | number | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null;
    usagePerUser?: NullableIntFieldUpdateOperationsInput | number | null;
    timesUsed?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Order?: OrderUncheckedUpdateManyWithoutCouponNestedInput;
  };

  export type CouponCreateManyInput = {
    id?: number;
    code: string;
    type: $Enums.CouponType;
    amount?: Decimal | DecimalJsLike | number | string | null;
    percent?: number | null;
    description?: string | null;
    startsAt?: Date | string | null;
    expiresAt?: Date | string | null;
    usageLimit?: number | null;
    usagePerUser?: number | null;
    timesUsed?: number;
    active?: boolean;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CouponUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string;
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType;
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    percent?: NullableIntFieldUpdateOperationsInput | number | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null;
    usagePerUser?: NullableIntFieldUpdateOperationsInput | number | null;
    timesUsed?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CouponUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    code?: StringFieldUpdateOperationsInput | string;
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType;
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    percent?: NullableIntFieldUpdateOperationsInput | number | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null;
    usagePerUser?: NullableIntFieldUpdateOperationsInput | number | null;
    timesUsed?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewCreateInput = {
    rating: number;
    title?: string | null;
    body?: string | null;
    approved?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user?: UserCreateNestedOneWithoutReviewsInput;
    product: ProductCreateNestedOneWithoutReviewsInput;
  };

  export type ReviewUncheckedCreateInput = {
    id?: number;
    userId?: number | null;
    productId: number;
    rating: number;
    title?: string | null;
    body?: string | null;
    approved?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ReviewUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: NullableStringFieldUpdateOperationsInput | string | null;
    approved?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutReviewsNestedInput;
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput;
  };

  export type ReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    productId?: IntFieldUpdateOperationsInput | number;
    rating?: IntFieldUpdateOperationsInput | number;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: NullableStringFieldUpdateOperationsInput | string | null;
    approved?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewCreateManyInput = {
    id?: number;
    userId?: number | null;
    productId: number;
    rating: number;
    title?: string | null;
    body?: string | null;
    approved?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ReviewUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: NullableStringFieldUpdateOperationsInput | string | null;
    approved?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    productId?: IntFieldUpdateOperationsInput | number;
    rating?: IntFieldUpdateOperationsInput | number;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: NullableStringFieldUpdateOperationsInput | string | null;
    approved?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WishlistCreateInput = {
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutWishlistInput;
    items?: WishlistItemCreateNestedManyWithoutWishlistInput;
  };

  export type WishlistUncheckedCreateInput = {
    id?: number;
    userId: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    items?: WishlistItemUncheckedCreateNestedManyWithoutWishlistInput;
  };

  export type WishlistUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutWishlistNestedInput;
    items?: WishlistItemUpdateManyWithoutWishlistNestedInput;
  };

  export type WishlistUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: WishlistItemUncheckedUpdateManyWithoutWishlistNestedInput;
  };

  export type WishlistCreateManyInput = {
    id?: number;
    userId: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type WishlistUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WishlistUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WishlistItemCreateInput = {
    variantId?: number | null;
    createdAt?: Date | string;
    wishlist: WishlistCreateNestedOneWithoutItemsInput;
    product: ProductCreateNestedOneWithoutWishlistItemInput;
  };

  export type WishlistItemUncheckedCreateInput = {
    id?: number;
    wishlistId: number;
    productId: number;
    variantId?: number | null;
    createdAt?: Date | string;
  };

  export type WishlistItemUpdateInput = {
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    wishlist?: WishlistUpdateOneRequiredWithoutItemsNestedInput;
    product?: ProductUpdateOneRequiredWithoutWishlistItemNestedInput;
  };

  export type WishlistItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    wishlistId?: IntFieldUpdateOperationsInput | number;
    productId?: IntFieldUpdateOperationsInput | number;
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WishlistItemCreateManyInput = {
    id?: number;
    wishlistId: number;
    productId: number;
    variantId?: number | null;
    createdAt?: Date | string;
  };

  export type WishlistItemUpdateManyMutationInput = {
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WishlistItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    wishlistId?: IntFieldUpdateOperationsInput | number;
    productId?: IntFieldUpdateOperationsInput | number;
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AddressCreateInput = {
    fullName: string;
    line1: string;
    line2?: string | null;
    city: string;
    province?: string | null;
    postalCode?: string | null;
    country: string;
    phone?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: boolean;
    isDefaultBilling?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user?: UserCreateNestedOneWithoutAddressesInput;
    ordersShipping?: OrderCreateNestedManyWithoutShippingAddressInput;
    ordersBilling?: OrderCreateNestedManyWithoutBillingAddressInput;
  };

  export type AddressUncheckedCreateInput = {
    id?: number;
    userId?: number | null;
    fullName: string;
    line1: string;
    line2?: string | null;
    city: string;
    province?: string | null;
    postalCode?: string | null;
    country: string;
    phone?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: boolean;
    isDefaultBilling?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ordersShipping?: OrderUncheckedCreateNestedManyWithoutShippingAddressInput;
    ordersBilling?: OrderUncheckedCreateNestedManyWithoutBillingAddressInput;
  };

  export type AddressUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string;
    line1?: StringFieldUpdateOperationsInput | string;
    line2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    province?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: BoolFieldUpdateOperationsInput | boolean;
    isDefaultBilling?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutAddressesNestedInput;
    ordersShipping?: OrderUpdateManyWithoutShippingAddressNestedInput;
    ordersBilling?: OrderUpdateManyWithoutBillingAddressNestedInput;
  };

  export type AddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    fullName?: StringFieldUpdateOperationsInput | string;
    line1?: StringFieldUpdateOperationsInput | string;
    line2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    province?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: BoolFieldUpdateOperationsInput | boolean;
    isDefaultBilling?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ordersShipping?: OrderUncheckedUpdateManyWithoutShippingAddressNestedInput;
    ordersBilling?: OrderUncheckedUpdateManyWithoutBillingAddressNestedInput;
  };

  export type AddressCreateManyInput = {
    id?: number;
    userId?: number | null;
    fullName: string;
    line1: string;
    line2?: string | null;
    city: string;
    province?: string | null;
    postalCode?: string | null;
    country: string;
    phone?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: boolean;
    isDefaultBilling?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AddressUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string;
    line1?: StringFieldUpdateOperationsInput | string;
    line2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    province?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: BoolFieldUpdateOperationsInput | boolean;
    isDefaultBilling?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    fullName?: StringFieldUpdateOperationsInput | string;
    line1?: StringFieldUpdateOperationsInput | string;
    line2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    province?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: BoolFieldUpdateOperationsInput | boolean;
    isDefaultBilling?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogCreateInput = {
    action: string;
    entity: string;
    entityId?: string | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    ip?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
    actor?: UserCreateNestedOneWithoutAuditLogInput;
  };

  export type AuditLogUncheckedCreateInput = {
    id?: number;
    actorId?: number | null;
    action: string;
    entity: string;
    entityId?: string | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    ip?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string;
    entity?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    ip?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    actor?: UserUpdateOneWithoutAuditLogNestedInput;
  };

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    actorId?: NullableIntFieldUpdateOperationsInput | number | null;
    action?: StringFieldUpdateOperationsInput | string;
    entity?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    ip?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogCreateManyInput = {
    id?: number;
    actorId?: number | null;
    action: string;
    entity: string;
    entityId?: string | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    ip?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string;
    entity?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    ip?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    actorId?: NullableIntFieldUpdateOperationsInput | number | null;
    action?: StringFieldUpdateOperationsInput | string;
    entity?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    ip?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReturnRequestCreateInput = {
    reason: string;
    status?: $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: Date | string;
    processedAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    order: OrderCreateNestedOneWithoutReturnRequestInput;
    orderItem: OrderItemCreateNestedOneWithoutReturnRequestInput;
    refund?: RefundCreateNestedOneWithoutReturnRequestInput;
  };

  export type ReturnRequestUncheckedCreateInput = {
    id?: number;
    orderId: number;
    orderItemId: number;
    reason: string;
    status?: $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: Date | string;
    processedAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    refund?: RefundUncheckedCreateNestedOneWithoutReturnRequestInput;
  };

  export type ReturnRequestUpdateInput = {
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    order?: OrderUpdateOneRequiredWithoutReturnRequestNestedInput;
    orderItem?: OrderItemUpdateOneRequiredWithoutReturnRequestNestedInput;
    refund?: RefundUpdateOneWithoutReturnRequestNestedInput;
  };

  export type ReturnRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    orderItemId?: IntFieldUpdateOperationsInput | number;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    refund?: RefundUncheckedUpdateOneWithoutReturnRequestNestedInput;
  };

  export type ReturnRequestCreateManyInput = {
    id?: number;
    orderId: number;
    orderItemId: number;
    reason: string;
    status?: $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: Date | string;
    processedAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type ReturnRequestUpdateManyMutationInput = {
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type ReturnRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    orderItemId?: IntFieldUpdateOperationsInput | number;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type RefundCreateInput = {
    amount: Decimal | DecimalJsLike | number | string;
    method: string;
    status?: $Enums.RefundStatus;
    providerRef?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    processedAt?: Date | string | null;
    order: OrderCreateNestedOneWithoutRefundInput;
    returnRequest?: ReturnRequestCreateNestedOneWithoutRefundInput;
  };

  export type RefundUncheckedCreateInput = {
    id?: number;
    orderId: number;
    returnRequestId?: number | null;
    amount: Decimal | DecimalJsLike | number | string;
    method: string;
    status?: $Enums.RefundStatus;
    providerRef?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    processedAt?: Date | string | null;
  };

  export type RefundUpdateInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    method?: StringFieldUpdateOperationsInput | string;
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus;
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    order?: OrderUpdateOneRequiredWithoutRefundNestedInput;
    returnRequest?: ReturnRequestUpdateOneWithoutRefundNestedInput;
  };

  export type RefundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    returnRequestId?: NullableIntFieldUpdateOperationsInput | number | null;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    method?: StringFieldUpdateOperationsInput | string;
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus;
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type RefundCreateManyInput = {
    id?: number;
    orderId: number;
    returnRequestId?: number | null;
    amount: Decimal | DecimalJsLike | number | string;
    method: string;
    status?: $Enums.RefundStatus;
    providerRef?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    processedAt?: Date | string | null;
  };

  export type RefundUpdateManyMutationInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    method?: StringFieldUpdateOperationsInput | string;
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus;
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type RefundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    returnRequestId?: NullableIntFieldUpdateOperationsInput | number | null;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    method?: StringFieldUpdateOperationsInput | string;
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus;
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type PaymentMetaCreateInput = {
    provider: string;
    transactionId?: string | null;
    status: string;
    amount: Decimal | DecimalJsLike | number | string;
    raw?: NullableJsonNullValueInput | InputJsonValue;
    capturedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    order: OrderCreateNestedOneWithoutPaymentMetaInput;
  };

  export type PaymentMetaUncheckedCreateInput = {
    id?: number;
    orderId: number;
    provider: string;
    transactionId?: string | null;
    status: string;
    amount: Decimal | DecimalJsLike | number | string;
    raw?: NullableJsonNullValueInput | InputJsonValue;
    capturedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentMetaUpdateInput = {
    provider?: StringFieldUpdateOperationsInput | string;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    raw?: NullableJsonNullValueInput | InputJsonValue;
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: OrderUpdateOneRequiredWithoutPaymentMetaNestedInput;
  };

  export type PaymentMetaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    provider?: StringFieldUpdateOperationsInput | string;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    raw?: NullableJsonNullValueInput | InputJsonValue;
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentMetaCreateManyInput = {
    id?: number;
    orderId: number;
    provider: string;
    transactionId?: string | null;
    status: string;
    amount: Decimal | DecimalJsLike | number | string;
    raw?: NullableJsonNullValueInput | InputJsonValue;
    capturedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentMetaUpdateManyMutationInput = {
    provider?: StringFieldUpdateOperationsInput | string;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    raw?: NullableJsonNullValueInput | InputJsonValue;
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentMetaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    provider?: StringFieldUpdateOperationsInput | string;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    raw?: NullableJsonNullValueInput | InputJsonValue;
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput;
    some?: UserRoleWhereInput;
    none?: UserRoleWhereInput;
  };

  export type AddressListRelationFilter = {
    every?: AddressWhereInput;
    some?: AddressWhereInput;
    none?: AddressWhereInput;
  };

  export type WishlistNullableScalarRelationFilter = {
    is?: WishlistWhereInput | null;
    isNot?: WishlistWhereInput | null;
  };

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput;
    some?: ReviewWhereInput;
    none?: ReviewWhereInput;
  };

  export type OrderListRelationFilter = {
    every?: OrderWhereInput;
    some?: OrderWhereInput;
    none?: OrderWhereInput;
  };

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput;
    some?: AuditLogWhereInput;
    none?: AuditLogWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    displayName?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLogin?: SortOrder;
  };

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    displayName?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLogin?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    displayName?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLogin?: SortOrder;
  };

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
  };

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
  };

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
  };

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput;
    isNot?: RoleWhereInput;
  };

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: number;
    roleId: number;
  };

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    roleId?: SortOrder;
  };

  export type UserRoleAvgOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    roleId?: SortOrder;
  };

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    roleId?: SortOrder;
  };

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    roleId?: SortOrder;
  };

  export type UserRoleSumOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    roleId?: SortOrder;
  };

  export type EnumProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, "path">>;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type ProductImageListRelationFilter = {
    every?: ProductImageWhereInput;
    some?: ProductImageWhereInput;
    none?: ProductImageWhereInput;
  };

  export type ProductVariantListRelationFilter = {
    every?: ProductVariantWhereInput;
    some?: ProductVariantWhereInput;
    none?: ProductVariantWhereInput;
  };

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput;
    some?: OrderItemWhereInput;
    none?: OrderItemWhereInput;
  };

  export type WishlistItemListRelationFilter = {
    every?: WishlistItemWhereInput;
    some?: WishlistItemWhereInput;
    none?: WishlistItemWhereInput;
  };

  export type ProductImageOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ProductVariantOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type WishlistItemOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    slug?: SortOrder;
    shortDescription?: SortOrder;
    description?: SortOrder;
    status?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    slug?: SortOrder;
    shortDescription?: SortOrder;
    description?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    slug?: SortOrder;
    shortDescription?: SortOrder;
    description?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type EnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumProductStatusFilter<$PrismaModel>;
    _max?: NestedEnumProductStatusFilter<$PrismaModel>;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, "path">>;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput;
    isNot?: ProductWhereInput;
  };

  export type ProductImageCountOrderByAggregateInput = {
    id?: SortOrder;
    url?: SortOrder;
    alt?: SortOrder;
    isPrimary?: SortOrder;
    productId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ProductImageAvgOrderByAggregateInput = {
    id?: SortOrder;
    productId?: SortOrder;
  };

  export type ProductImageMaxOrderByAggregateInput = {
    id?: SortOrder;
    url?: SortOrder;
    alt?: SortOrder;
    isPrimary?: SortOrder;
    productId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ProductImageMinOrderByAggregateInput = {
    id?: SortOrder;
    url?: SortOrder;
    alt?: SortOrder;
    isPrimary?: SortOrder;
    productId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ProductImageSumOrderByAggregateInput = {
    id?: SortOrder;
    productId?: SortOrder;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string;
  };

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null;
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null;
  };

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput;
    some?: InventoryWhereInput;
    none?: InventoryWhereInput;
  };

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ProductVariantCountOrderByAggregateInput = {
    id?: SortOrder;
    productId?: SortOrder;
    name?: SortOrder;
    skuPrefix?: SortOrder;
    price?: SortOrder;
    compareAtPrice?: SortOrder;
    attributes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ProductVariantAvgOrderByAggregateInput = {
    id?: SortOrder;
    productId?: SortOrder;
    price?: SortOrder;
    compareAtPrice?: SortOrder;
  };

  export type ProductVariantMaxOrderByAggregateInput = {
    id?: SortOrder;
    productId?: SortOrder;
    name?: SortOrder;
    skuPrefix?: SortOrder;
    price?: SortOrder;
    compareAtPrice?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ProductVariantMinOrderByAggregateInput = {
    id?: SortOrder;
    productId?: SortOrder;
    name?: SortOrder;
    skuPrefix?: SortOrder;
    price?: SortOrder;
    compareAtPrice?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ProductVariantSumOrderByAggregateInput = {
    id?: SortOrder;
    productId?: SortOrder;
    price?: SortOrder;
    compareAtPrice?: SortOrder;
  };

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null;
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedDecimalNullableFilter<$PrismaModel>;
    _sum?: NestedDecimalNullableFilter<$PrismaModel>;
    _min?: NestedDecimalNullableFilter<$PrismaModel>;
    _max?: NestedDecimalNullableFilter<$PrismaModel>;
  };

  export type ProductVariantScalarRelationFilter = {
    is?: ProductVariantWhereInput;
    isNot?: ProductVariantWhereInput;
  };

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder;
    sku?: SortOrder;
    variantId?: SortOrder;
    quantity?: SortOrder;
    reserved?: SortOrder;
    location?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type InventoryAvgOrderByAggregateInput = {
    id?: SortOrder;
    variantId?: SortOrder;
    quantity?: SortOrder;
    reserved?: SortOrder;
  };

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder;
    sku?: SortOrder;
    variantId?: SortOrder;
    quantity?: SortOrder;
    reserved?: SortOrder;
    location?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder;
    sku?: SortOrder;
    variantId?: SortOrder;
    quantity?: SortOrder;
    reserved?: SortOrder;
    location?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type InventorySumOrderByAggregateInput = {
    id?: SortOrder;
    variantId?: SortOrder;
    quantity?: SortOrder;
    reserved?: SortOrder;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus;
  };

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>;
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>;
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod;
  };

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
  };

  export type PaymentMetaNullableScalarRelationFilter = {
    is?: PaymentMetaWhereInput | null;
    isNot?: PaymentMetaWhereInput | null;
  };

  export type AddressNullableScalarRelationFilter = {
    is?: AddressWhereInput | null;
    isNot?: AddressWhereInput | null;
  };

  export type CouponNullableScalarRelationFilter = {
    is?: CouponWhereInput | null;
    isNot?: CouponWhereInput | null;
  };

  export type ReturnRequestListRelationFilter = {
    every?: ReturnRequestWhereInput;
    some?: ReturnRequestWhereInput;
    none?: ReturnRequestWhereInput;
  };

  export type RefundListRelationFilter = {
    every?: RefundWhereInput;
    some?: RefundWhereInput;
    none?: RefundWhereInput;
  };

  export type ReturnRequestOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RefundOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder;
    orderNumber?: SortOrder;
    userId?: SortOrder;
    status?: SortOrder;
    subtotal?: SortOrder;
    shipping?: SortOrder;
    tax?: SortOrder;
    total?: SortOrder;
    paymentMethod?: SortOrder;
    shippingAddressId?: SortOrder;
    billingAddressId?: SortOrder;
    couponId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    subtotal?: SortOrder;
    shipping?: SortOrder;
    tax?: SortOrder;
    total?: SortOrder;
    shippingAddressId?: SortOrder;
    billingAddressId?: SortOrder;
    couponId?: SortOrder;
  };

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder;
    orderNumber?: SortOrder;
    userId?: SortOrder;
    status?: SortOrder;
    subtotal?: SortOrder;
    shipping?: SortOrder;
    tax?: SortOrder;
    total?: SortOrder;
    paymentMethod?: SortOrder;
    shippingAddressId?: SortOrder;
    billingAddressId?: SortOrder;
    couponId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder;
    orderNumber?: SortOrder;
    userId?: SortOrder;
    status?: SortOrder;
    subtotal?: SortOrder;
    shipping?: SortOrder;
    tax?: SortOrder;
    total?: SortOrder;
    paymentMethod?: SortOrder;
    shippingAddressId?: SortOrder;
    billingAddressId?: SortOrder;
    couponId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    subtotal?: SortOrder;
    shipping?: SortOrder;
    tax?: SortOrder;
    total?: SortOrder;
    shippingAddressId?: SortOrder;
    billingAddressId?: SortOrder;
    couponId?: SortOrder;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>;
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>;
  };

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>;
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>;
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>;
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>;
  };

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput;
    isNot?: OrderWhereInput;
  };

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null;
    isNot?: ProductWhereInput | null;
  };

  export type ProductVariantNullableScalarRelationFilter = {
    is?: ProductVariantWhereInput | null;
    isNot?: ProductVariantWhereInput | null;
  };

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    productId?: SortOrder;
    variantId?: SortOrder;
    sku?: SortOrder;
    name?: SortOrder;
    price?: SortOrder;
    quantity?: SortOrder;
    total?: SortOrder;
    returned?: SortOrder;
    createdAt?: SortOrder;
  };

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    productId?: SortOrder;
    variantId?: SortOrder;
    price?: SortOrder;
    quantity?: SortOrder;
    total?: SortOrder;
  };

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    productId?: SortOrder;
    variantId?: SortOrder;
    sku?: SortOrder;
    name?: SortOrder;
    price?: SortOrder;
    quantity?: SortOrder;
    total?: SortOrder;
    returned?: SortOrder;
    createdAt?: SortOrder;
  };

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    productId?: SortOrder;
    variantId?: SortOrder;
    sku?: SortOrder;
    name?: SortOrder;
    price?: SortOrder;
    quantity?: SortOrder;
    total?: SortOrder;
    returned?: SortOrder;
    createdAt?: SortOrder;
  };

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    productId?: SortOrder;
    variantId?: SortOrder;
    price?: SortOrder;
    quantity?: SortOrder;
    total?: SortOrder;
  };

  export type EnumCouponTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponType | EnumCouponTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumCouponTypeFilter<$PrismaModel> | $Enums.CouponType;
  };

  export type CouponCountOrderByAggregateInput = {
    id?: SortOrder;
    code?: SortOrder;
    type?: SortOrder;
    amount?: SortOrder;
    percent?: SortOrder;
    description?: SortOrder;
    startsAt?: SortOrder;
    expiresAt?: SortOrder;
    usageLimit?: SortOrder;
    usagePerUser?: SortOrder;
    timesUsed?: SortOrder;
    active?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CouponAvgOrderByAggregateInput = {
    id?: SortOrder;
    amount?: SortOrder;
    percent?: SortOrder;
    usageLimit?: SortOrder;
    usagePerUser?: SortOrder;
    timesUsed?: SortOrder;
  };

  export type CouponMaxOrderByAggregateInput = {
    id?: SortOrder;
    code?: SortOrder;
    type?: SortOrder;
    amount?: SortOrder;
    percent?: SortOrder;
    description?: SortOrder;
    startsAt?: SortOrder;
    expiresAt?: SortOrder;
    usageLimit?: SortOrder;
    usagePerUser?: SortOrder;
    timesUsed?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CouponMinOrderByAggregateInput = {
    id?: SortOrder;
    code?: SortOrder;
    type?: SortOrder;
    amount?: SortOrder;
    percent?: SortOrder;
    description?: SortOrder;
    startsAt?: SortOrder;
    expiresAt?: SortOrder;
    usageLimit?: SortOrder;
    usagePerUser?: SortOrder;
    timesUsed?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CouponSumOrderByAggregateInput = {
    id?: SortOrder;
    amount?: SortOrder;
    percent?: SortOrder;
    usageLimit?: SortOrder;
    usagePerUser?: SortOrder;
    timesUsed?: SortOrder;
  };

  export type EnumCouponTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponType | EnumCouponTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumCouponTypeWithAggregatesFilter<$PrismaModel> | $Enums.CouponType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumCouponTypeFilter<$PrismaModel>;
    _max?: NestedEnumCouponTypeFilter<$PrismaModel>;
  };

  export type ReviewUserIdProductIdCompoundUniqueInput = {
    userId: number;
    productId: number;
  };

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    productId?: SortOrder;
    rating?: SortOrder;
    title?: SortOrder;
    body?: SortOrder;
    approved?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ReviewAvgOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    productId?: SortOrder;
    rating?: SortOrder;
  };

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    productId?: SortOrder;
    rating?: SortOrder;
    title?: SortOrder;
    body?: SortOrder;
    approved?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    productId?: SortOrder;
    rating?: SortOrder;
    title?: SortOrder;
    body?: SortOrder;
    approved?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ReviewSumOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    productId?: SortOrder;
    rating?: SortOrder;
  };

  export type WishlistCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type WishlistAvgOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
  };

  export type WishlistMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type WishlistMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type WishlistSumOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
  };

  export type WishlistScalarRelationFilter = {
    is?: WishlistWhereInput;
    isNot?: WishlistWhereInput;
  };

  export type WishlistItemWishlistIdProductIdVariantIdCompoundUniqueInput = {
    wishlistId: number;
    productId: number;
    variantId: number;
  };

  export type WishlistItemCountOrderByAggregateInput = {
    id?: SortOrder;
    wishlistId?: SortOrder;
    productId?: SortOrder;
    variantId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type WishlistItemAvgOrderByAggregateInput = {
    id?: SortOrder;
    wishlistId?: SortOrder;
    productId?: SortOrder;
    variantId?: SortOrder;
  };

  export type WishlistItemMaxOrderByAggregateInput = {
    id?: SortOrder;
    wishlistId?: SortOrder;
    productId?: SortOrder;
    variantId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type WishlistItemMinOrderByAggregateInput = {
    id?: SortOrder;
    wishlistId?: SortOrder;
    productId?: SortOrder;
    variantId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type WishlistItemSumOrderByAggregateInput = {
    id?: SortOrder;
    wishlistId?: SortOrder;
    productId?: SortOrder;
    variantId?: SortOrder;
  };

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    fullName?: SortOrder;
    line1?: SortOrder;
    line2?: SortOrder;
    city?: SortOrder;
    province?: SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    phone?: SortOrder;
    metadata?: SortOrder;
    isDefaultShipping?: SortOrder;
    isDefaultBilling?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AddressAvgOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
  };

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    fullName?: SortOrder;
    line1?: SortOrder;
    line2?: SortOrder;
    city?: SortOrder;
    province?: SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    phone?: SortOrder;
    isDefaultShipping?: SortOrder;
    isDefaultBilling?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    fullName?: SortOrder;
    line1?: SortOrder;
    line2?: SortOrder;
    city?: SortOrder;
    province?: SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    phone?: SortOrder;
    isDefaultShipping?: SortOrder;
    isDefaultBilling?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AddressSumOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
  };

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder;
    actorId?: SortOrder;
    action?: SortOrder;
    entity?: SortOrder;
    entityId?: SortOrder;
    changes?: SortOrder;
    ip?: SortOrder;
    userAgent?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder;
    actorId?: SortOrder;
  };

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    actorId?: SortOrder;
    action?: SortOrder;
    entity?: SortOrder;
    entityId?: SortOrder;
    ip?: SortOrder;
    userAgent?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder;
    actorId?: SortOrder;
    action?: SortOrder;
    entity?: SortOrder;
    entityId?: SortOrder;
    ip?: SortOrder;
    userAgent?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder;
    actorId?: SortOrder;
  };

  export type EnumReturnStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnStatus | EnumReturnStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumReturnStatusFilter<$PrismaModel> | $Enums.ReturnStatus;
  };

  export type OrderItemScalarRelationFilter = {
    is?: OrderItemWhereInput;
    isNot?: OrderItemWhereInput;
  };

  export type RefundNullableScalarRelationFilter = {
    is?: RefundWhereInput | null;
    isNot?: RefundWhereInput | null;
  };

  export type ReturnRequestCountOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    orderItemId?: SortOrder;
    reason?: SortOrder;
    status?: SortOrder;
    evidence?: SortOrder;
    requestedAt?: SortOrder;
    processedAt?: SortOrder;
    metadata?: SortOrder;
  };

  export type ReturnRequestAvgOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    orderItemId?: SortOrder;
  };

  export type ReturnRequestMaxOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    orderItemId?: SortOrder;
    reason?: SortOrder;
    status?: SortOrder;
    requestedAt?: SortOrder;
    processedAt?: SortOrder;
  };

  export type ReturnRequestMinOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    orderItemId?: SortOrder;
    reason?: SortOrder;
    status?: SortOrder;
    requestedAt?: SortOrder;
    processedAt?: SortOrder;
  };

  export type ReturnRequestSumOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    orderItemId?: SortOrder;
  };

  export type EnumReturnStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnStatus | EnumReturnStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumReturnStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReturnStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumReturnStatusFilter<$PrismaModel>;
    _max?: NestedEnumReturnStatusFilter<$PrismaModel>;
  };

  export type EnumRefundStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumRefundStatusFilter<$PrismaModel> | $Enums.RefundStatus;
  };

  export type ReturnRequestNullableScalarRelationFilter = {
    is?: ReturnRequestWhereInput | null;
    isNot?: ReturnRequestWhereInput | null;
  };

  export type RefundCountOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    returnRequestId?: SortOrder;
    amount?: SortOrder;
    method?: SortOrder;
    status?: SortOrder;
    providerRef?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
    processedAt?: SortOrder;
  };

  export type RefundAvgOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    returnRequestId?: SortOrder;
    amount?: SortOrder;
  };

  export type RefundMaxOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    returnRequestId?: SortOrder;
    amount?: SortOrder;
    method?: SortOrder;
    status?: SortOrder;
    providerRef?: SortOrder;
    createdAt?: SortOrder;
    processedAt?: SortOrder;
  };

  export type RefundMinOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    returnRequestId?: SortOrder;
    amount?: SortOrder;
    method?: SortOrder;
    status?: SortOrder;
    providerRef?: SortOrder;
    createdAt?: SortOrder;
    processedAt?: SortOrder;
  };

  export type RefundSumOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    returnRequestId?: SortOrder;
    amount?: SortOrder;
  };

  export type EnumRefundStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel> | $Enums.RefundStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRefundStatusFilter<$PrismaModel>;
    _max?: NestedEnumRefundStatusFilter<$PrismaModel>;
  };

  export type PaymentMetaCountOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    provider?: SortOrder;
    transactionId?: SortOrder;
    status?: SortOrder;
    amount?: SortOrder;
    raw?: SortOrder;
    capturedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PaymentMetaAvgOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    amount?: SortOrder;
  };

  export type PaymentMetaMaxOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    provider?: SortOrder;
    transactionId?: SortOrder;
    status?: SortOrder;
    amount?: SortOrder;
    capturedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PaymentMetaMinOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    provider?: SortOrder;
    transactionId?: SortOrder;
    status?: SortOrder;
    amount?: SortOrder;
    capturedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PaymentMetaSumOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    amount?: SortOrder;
  };

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
      | UserRoleCreateWithoutUserInput[]
      | UserRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[];
    createMany?: UserRoleCreateManyUserInputEnvelope;
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
  };

  export type AddressCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
      | AddressCreateWithoutUserInput[]
      | AddressUncheckedCreateWithoutUserInput[];
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[];
    createMany?: AddressCreateManyUserInputEnvelope;
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
  };

  export type WishlistCreateNestedOneWithoutUserInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput>;
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput;
    connect?: WishlistWhereUniqueInput;
  };

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
      | ReviewCreateWithoutUserInput[]
      | ReviewUncheckedCreateWithoutUserInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[];
    createMany?: ReviewCreateManyUserInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type OrderCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
      | OrderCreateWithoutUserInput[]
      | OrderUncheckedCreateWithoutUserInput[];
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[];
    createMany?: OrderCreateManyUserInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type AuditLogCreateNestedManyWithoutActorInput = {
    create?:
      | XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
      | AuditLogCreateWithoutActorInput[]
      | AuditLogUncheckedCreateWithoutActorInput[];
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[];
    createMany?: AuditLogCreateManyActorInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
      | UserRoleCreateWithoutUserInput[]
      | UserRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[];
    createMany?: UserRoleCreateManyUserInputEnvelope;
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
  };

  export type AddressUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
      | AddressCreateWithoutUserInput[]
      | AddressUncheckedCreateWithoutUserInput[];
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[];
    createMany?: AddressCreateManyUserInputEnvelope;
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
  };

  export type WishlistUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput>;
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput;
    connect?: WishlistWhereUniqueInput;
  };

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
      | ReviewCreateWithoutUserInput[]
      | ReviewUncheckedCreateWithoutUserInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[];
    createMany?: ReviewCreateManyUserInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
      | OrderCreateWithoutUserInput[]
      | OrderUncheckedCreateWithoutUserInput[];
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[];
    createMany?: OrderCreateManyUserInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type AuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?:
      | XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
      | AuditLogCreateWithoutActorInput[]
      | AuditLogUncheckedCreateWithoutActorInput[];
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[];
    createMany?: AuditLogCreateManyActorInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
      | UserRoleCreateWithoutUserInput[]
      | UserRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[];
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserRoleCreateManyUserInputEnvelope;
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[];
  };

  export type AddressUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
      | AddressCreateWithoutUserInput[]
      | AddressUncheckedCreateWithoutUserInput[];
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[];
    upsert?: AddressUpsertWithWhereUniqueWithoutUserInput | AddressUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AddressCreateManyUserInputEnvelope;
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    update?: AddressUpdateWithWhereUniqueWithoutUserInput | AddressUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: AddressUpdateManyWithWhereWithoutUserInput | AddressUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[];
  };

  export type WishlistUpdateOneWithoutUserNestedInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput>;
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput;
    upsert?: WishlistUpsertWithoutUserInput;
    disconnect?: WishlistWhereInput | boolean;
    delete?: WishlistWhereInput | boolean;
    connect?: WishlistWhereUniqueInput;
    update?: XOR<
      XOR<WishlistUpdateToOneWithWhereWithoutUserInput, WishlistUpdateWithoutUserInput>,
      WishlistUncheckedUpdateWithoutUserInput
    >;
  };

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
      | ReviewCreateWithoutUserInput[]
      | ReviewUncheckedCreateWithoutUserInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[];
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ReviewCreateManyUserInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
      | OrderCreateWithoutUserInput[]
      | OrderUncheckedCreateWithoutUserInput[];
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[];
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: OrderCreateManyUserInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type AuditLogUpdateManyWithoutActorNestedInput = {
    create?:
      | XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
      | AuditLogCreateWithoutActorInput[]
      | AuditLogUncheckedCreateWithoutActorInput[];
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[];
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[];
    createMany?: AuditLogCreateManyActorInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[];
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
      | UserRoleCreateWithoutUserInput[]
      | UserRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[];
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserRoleCreateManyUserInputEnvelope;
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[];
  };

  export type AddressUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
      | AddressCreateWithoutUserInput[]
      | AddressUncheckedCreateWithoutUserInput[];
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[];
    upsert?: AddressUpsertWithWhereUniqueWithoutUserInput | AddressUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AddressCreateManyUserInputEnvelope;
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    update?: AddressUpdateWithWhereUniqueWithoutUserInput | AddressUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: AddressUpdateManyWithWhereWithoutUserInput | AddressUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[];
  };

  export type WishlistUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput>;
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput;
    upsert?: WishlistUpsertWithoutUserInput;
    disconnect?: WishlistWhereInput | boolean;
    delete?: WishlistWhereInput | boolean;
    connect?: WishlistWhereUniqueInput;
    update?: XOR<
      XOR<WishlistUpdateToOneWithWhereWithoutUserInput, WishlistUpdateWithoutUserInput>,
      WishlistUncheckedUpdateWithoutUserInput
    >;
  };

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
      | ReviewCreateWithoutUserInput[]
      | ReviewUncheckedCreateWithoutUserInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[];
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ReviewCreateManyUserInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
      | OrderCreateWithoutUserInput[]
      | OrderUncheckedCreateWithoutUserInput[];
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[];
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: OrderCreateManyUserInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type AuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?:
      | XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
      | AuditLogCreateWithoutActorInput[]
      | AuditLogUncheckedCreateWithoutActorInput[];
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[];
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[];
    createMany?: AuditLogCreateManyActorInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[];
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?:
      | XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
      | UserRoleCreateWithoutRoleInput[]
      | UserRoleUncheckedCreateWithoutRoleInput[];
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[];
    createMany?: UserRoleCreateManyRoleInputEnvelope;
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
  };

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?:
      | XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
      | UserRoleCreateWithoutRoleInput[]
      | UserRoleUncheckedCreateWithoutRoleInput[];
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[];
    createMany?: UserRoleCreateManyRoleInputEnvelope;
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
  };

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?:
      | XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
      | UserRoleCreateWithoutRoleInput[]
      | UserRoleUncheckedCreateWithoutRoleInput[];
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[];
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[];
    createMany?: UserRoleCreateManyRoleInputEnvelope;
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[];
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[];
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[];
  };

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?:
      | XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
      | UserRoleCreateWithoutRoleInput[]
      | UserRoleUncheckedCreateWithoutRoleInput[];
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[];
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[];
    createMany?: UserRoleCreateManyRoleInputEnvelope;
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[];
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[];
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput;
    connect?: UserWhereUniqueInput;
  };

  export type RoleCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>;
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput;
    connect?: RoleWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput;
    upsert?: UserUpsertWithoutUserRolesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutUserRolesInput, UserUpdateWithoutUserRolesInput>,
      UserUncheckedUpdateWithoutUserRolesInput
    >;
  };

  export type RoleUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>;
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput;
    upsert?: RoleUpsertWithoutUserRolesInput;
    connect?: RoleWhereUniqueInput;
    update?: XOR<
      XOR<RoleUpdateToOneWithWhereWithoutUserRolesInput, RoleUpdateWithoutUserRolesInput>,
      RoleUncheckedUpdateWithoutUserRolesInput
    >;
  };

  export type ProductImageCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
      | ProductImageCreateWithoutProductInput[]
      | ProductImageUncheckedCreateWithoutProductInput[];
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[];
    createMany?: ProductImageCreateManyProductInputEnvelope;
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[];
  };

  export type ProductVariantCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
      | ProductVariantCreateWithoutProductInput[]
      | ProductVariantUncheckedCreateWithoutProductInput[];
    connectOrCreate?:
      | ProductVariantCreateOrConnectWithoutProductInput
      | ProductVariantCreateOrConnectWithoutProductInput[];
    createMany?: ProductVariantCreateManyProductInputEnvelope;
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[];
  };

  export type ReviewCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
      | ReviewCreateWithoutProductInput[]
      | ReviewUncheckedCreateWithoutProductInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[];
    createMany?: ReviewCreateManyProductInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
      | OrderItemCreateWithoutProductInput[]
      | OrderItemUncheckedCreateWithoutProductInput[];
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[];
    createMany?: OrderItemCreateManyProductInputEnvelope;
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
  };

  export type WishlistItemCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput>
      | WishlistItemCreateWithoutProductInput[]
      | WishlistItemUncheckedCreateWithoutProductInput[];
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[];
    createMany?: WishlistItemCreateManyProductInputEnvelope;
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
  };

  export type ProductImageUncheckedCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
      | ProductImageCreateWithoutProductInput[]
      | ProductImageUncheckedCreateWithoutProductInput[];
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[];
    createMany?: ProductImageCreateManyProductInputEnvelope;
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[];
  };

  export type ProductVariantUncheckedCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
      | ProductVariantCreateWithoutProductInput[]
      | ProductVariantUncheckedCreateWithoutProductInput[];
    connectOrCreate?:
      | ProductVariantCreateOrConnectWithoutProductInput
      | ProductVariantCreateOrConnectWithoutProductInput[];
    createMany?: ProductVariantCreateManyProductInputEnvelope;
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[];
  };

  export type ReviewUncheckedCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
      | ReviewCreateWithoutProductInput[]
      | ReviewUncheckedCreateWithoutProductInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[];
    createMany?: ReviewCreateManyProductInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
      | OrderItemCreateWithoutProductInput[]
      | OrderItemUncheckedCreateWithoutProductInput[];
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[];
    createMany?: OrderItemCreateManyProductInputEnvelope;
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
  };

  export type WishlistItemUncheckedCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput>
      | WishlistItemCreateWithoutProductInput[]
      | WishlistItemUncheckedCreateWithoutProductInput[];
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[];
    createMany?: WishlistItemCreateManyProductInputEnvelope;
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
  };

  export type EnumProductStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProductStatus;
  };

  export type ProductImageUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
      | ProductImageCreateWithoutProductInput[]
      | ProductImageUncheckedCreateWithoutProductInput[];
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[];
    upsert?:
      | ProductImageUpsertWithWhereUniqueWithoutProductInput
      | ProductImageUpsertWithWhereUniqueWithoutProductInput[];
    createMany?: ProductImageCreateManyProductInputEnvelope;
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[];
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[];
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[];
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[];
    update?:
      | ProductImageUpdateWithWhereUniqueWithoutProductInput
      | ProductImageUpdateWithWhereUniqueWithoutProductInput[];
    updateMany?:
      | ProductImageUpdateManyWithWhereWithoutProductInput
      | ProductImageUpdateManyWithWhereWithoutProductInput[];
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[];
  };

  export type ProductVariantUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
      | ProductVariantCreateWithoutProductInput[]
      | ProductVariantUncheckedCreateWithoutProductInput[];
    connectOrCreate?:
      | ProductVariantCreateOrConnectWithoutProductInput
      | ProductVariantCreateOrConnectWithoutProductInput[];
    upsert?:
      | ProductVariantUpsertWithWhereUniqueWithoutProductInput
      | ProductVariantUpsertWithWhereUniqueWithoutProductInput[];
    createMany?: ProductVariantCreateManyProductInputEnvelope;
    set?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[];
    disconnect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[];
    delete?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[];
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[];
    update?:
      | ProductVariantUpdateWithWhereUniqueWithoutProductInput
      | ProductVariantUpdateWithWhereUniqueWithoutProductInput[];
    updateMany?:
      | ProductVariantUpdateManyWithWhereWithoutProductInput
      | ProductVariantUpdateManyWithWhereWithoutProductInput[];
    deleteMany?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[];
  };

  export type ReviewUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
      | ReviewCreateWithoutProductInput[]
      | ReviewUncheckedCreateWithoutProductInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[];
    upsert?: ReviewUpsertWithWhereUniqueWithoutProductInput | ReviewUpsertWithWhereUniqueWithoutProductInput[];
    createMany?: ReviewCreateManyProductInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?: ReviewUpdateWithWhereUniqueWithoutProductInput | ReviewUpdateWithWhereUniqueWithoutProductInput[];
    updateMany?: ReviewUpdateManyWithWhereWithoutProductInput | ReviewUpdateManyWithWhereWithoutProductInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
      | OrderItemCreateWithoutProductInput[]
      | OrderItemUncheckedCreateWithoutProductInput[];
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[];
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[];
    createMany?: OrderItemCreateManyProductInputEnvelope;
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[];
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[];
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
  };

  export type WishlistItemUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput>
      | WishlistItemCreateWithoutProductInput[]
      | WishlistItemUncheckedCreateWithoutProductInput[];
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[];
    upsert?:
      | WishlistItemUpsertWithWhereUniqueWithoutProductInput
      | WishlistItemUpsertWithWhereUniqueWithoutProductInput[];
    createMany?: WishlistItemCreateManyProductInputEnvelope;
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
    update?:
      | WishlistItemUpdateWithWhereUniqueWithoutProductInput
      | WishlistItemUpdateWithWhereUniqueWithoutProductInput[];
    updateMany?:
      | WishlistItemUpdateManyWithWhereWithoutProductInput
      | WishlistItemUpdateManyWithWhereWithoutProductInput[];
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[];
  };

  export type ProductImageUncheckedUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
      | ProductImageCreateWithoutProductInput[]
      | ProductImageUncheckedCreateWithoutProductInput[];
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[];
    upsert?:
      | ProductImageUpsertWithWhereUniqueWithoutProductInput
      | ProductImageUpsertWithWhereUniqueWithoutProductInput[];
    createMany?: ProductImageCreateManyProductInputEnvelope;
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[];
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[];
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[];
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[];
    update?:
      | ProductImageUpdateWithWhereUniqueWithoutProductInput
      | ProductImageUpdateWithWhereUniqueWithoutProductInput[];
    updateMany?:
      | ProductImageUpdateManyWithWhereWithoutProductInput
      | ProductImageUpdateManyWithWhereWithoutProductInput[];
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[];
  };

  export type ProductVariantUncheckedUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
      | ProductVariantCreateWithoutProductInput[]
      | ProductVariantUncheckedCreateWithoutProductInput[];
    connectOrCreate?:
      | ProductVariantCreateOrConnectWithoutProductInput
      | ProductVariantCreateOrConnectWithoutProductInput[];
    upsert?:
      | ProductVariantUpsertWithWhereUniqueWithoutProductInput
      | ProductVariantUpsertWithWhereUniqueWithoutProductInput[];
    createMany?: ProductVariantCreateManyProductInputEnvelope;
    set?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[];
    disconnect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[];
    delete?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[];
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[];
    update?:
      | ProductVariantUpdateWithWhereUniqueWithoutProductInput
      | ProductVariantUpdateWithWhereUniqueWithoutProductInput[];
    updateMany?:
      | ProductVariantUpdateManyWithWhereWithoutProductInput
      | ProductVariantUpdateManyWithWhereWithoutProductInput[];
    deleteMany?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[];
  };

  export type ReviewUncheckedUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
      | ReviewCreateWithoutProductInput[]
      | ReviewUncheckedCreateWithoutProductInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[];
    upsert?: ReviewUpsertWithWhereUniqueWithoutProductInput | ReviewUpsertWithWhereUniqueWithoutProductInput[];
    createMany?: ReviewCreateManyProductInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?: ReviewUpdateWithWhereUniqueWithoutProductInput | ReviewUpdateWithWhereUniqueWithoutProductInput[];
    updateMany?: ReviewUpdateManyWithWhereWithoutProductInput | ReviewUpdateManyWithWhereWithoutProductInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
      | OrderItemCreateWithoutProductInput[]
      | OrderItemUncheckedCreateWithoutProductInput[];
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[];
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[];
    createMany?: OrderItemCreateManyProductInputEnvelope;
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[];
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[];
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
  };

  export type WishlistItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput>
      | WishlistItemCreateWithoutProductInput[]
      | WishlistItemUncheckedCreateWithoutProductInput[];
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[];
    upsert?:
      | WishlistItemUpsertWithWhereUniqueWithoutProductInput
      | WishlistItemUpsertWithWhereUniqueWithoutProductInput[];
    createMany?: WishlistItemCreateManyProductInputEnvelope;
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
    update?:
      | WishlistItemUpdateWithWhereUniqueWithoutProductInput
      | WishlistItemUpdateWithWhereUniqueWithoutProductInput[];
    updateMany?:
      | WishlistItemUpdateManyWithWhereWithoutProductInput
      | WishlistItemUpdateManyWithWhereWithoutProductInput[];
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[];
  };

  export type ProductCreateNestedOneWithoutImagesInput = {
    create?: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>;
    connectOrCreate?: ProductCreateOrConnectWithoutImagesInput;
    connect?: ProductWhereUniqueInput;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type ProductUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>;
    connectOrCreate?: ProductCreateOrConnectWithoutImagesInput;
    upsert?: ProductUpsertWithoutImagesInput;
    connect?: ProductWhereUniqueInput;
    update?: XOR<
      XOR<ProductUpdateToOneWithWhereWithoutImagesInput, ProductUpdateWithoutImagesInput>,
      ProductUncheckedUpdateWithoutImagesInput
    >;
  };

  export type ProductCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>;
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput;
    connect?: ProductWhereUniqueInput;
  };

  export type InventoryCreateNestedManyWithoutVariantInput = {
    create?:
      | XOR<InventoryCreateWithoutVariantInput, InventoryUncheckedCreateWithoutVariantInput>
      | InventoryCreateWithoutVariantInput[]
      | InventoryUncheckedCreateWithoutVariantInput[];
    connectOrCreate?: InventoryCreateOrConnectWithoutVariantInput | InventoryCreateOrConnectWithoutVariantInput[];
    createMany?: InventoryCreateManyVariantInputEnvelope;
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[];
  };

  export type OrderItemCreateNestedManyWithoutVariantInput = {
    create?:
      | XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput>
      | OrderItemCreateWithoutVariantInput[]
      | OrderItemUncheckedCreateWithoutVariantInput[];
    connectOrCreate?: OrderItemCreateOrConnectWithoutVariantInput | OrderItemCreateOrConnectWithoutVariantInput[];
    createMany?: OrderItemCreateManyVariantInputEnvelope;
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
  };

  export type InventoryUncheckedCreateNestedManyWithoutVariantInput = {
    create?:
      | XOR<InventoryCreateWithoutVariantInput, InventoryUncheckedCreateWithoutVariantInput>
      | InventoryCreateWithoutVariantInput[]
      | InventoryUncheckedCreateWithoutVariantInput[];
    connectOrCreate?: InventoryCreateOrConnectWithoutVariantInput | InventoryCreateOrConnectWithoutVariantInput[];
    createMany?: InventoryCreateManyVariantInputEnvelope;
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[];
  };

  export type OrderItemUncheckedCreateNestedManyWithoutVariantInput = {
    create?:
      | XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput>
      | OrderItemCreateWithoutVariantInput[]
      | OrderItemUncheckedCreateWithoutVariantInput[];
    connectOrCreate?: OrderItemCreateOrConnectWithoutVariantInput | OrderItemCreateOrConnectWithoutVariantInput[];
    createMany?: OrderItemCreateManyVariantInputEnvelope;
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
  };

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string;
    increment?: Decimal | DecimalJsLike | number | string;
    decrement?: Decimal | DecimalJsLike | number | string;
    multiply?: Decimal | DecimalJsLike | number | string;
    divide?: Decimal | DecimalJsLike | number | string;
  };

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null;
    increment?: Decimal | DecimalJsLike | number | string;
    decrement?: Decimal | DecimalJsLike | number | string;
    multiply?: Decimal | DecimalJsLike | number | string;
    divide?: Decimal | DecimalJsLike | number | string;
  };

  export type ProductUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>;
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput;
    upsert?: ProductUpsertWithoutVariantsInput;
    connect?: ProductWhereUniqueInput;
    update?: XOR<
      XOR<ProductUpdateToOneWithWhereWithoutVariantsInput, ProductUpdateWithoutVariantsInput>,
      ProductUncheckedUpdateWithoutVariantsInput
    >;
  };

  export type InventoryUpdateManyWithoutVariantNestedInput = {
    create?:
      | XOR<InventoryCreateWithoutVariantInput, InventoryUncheckedCreateWithoutVariantInput>
      | InventoryCreateWithoutVariantInput[]
      | InventoryUncheckedCreateWithoutVariantInput[];
    connectOrCreate?: InventoryCreateOrConnectWithoutVariantInput | InventoryCreateOrConnectWithoutVariantInput[];
    upsert?: InventoryUpsertWithWhereUniqueWithoutVariantInput | InventoryUpsertWithWhereUniqueWithoutVariantInput[];
    createMany?: InventoryCreateManyVariantInputEnvelope;
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[];
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[];
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[];
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[];
    update?: InventoryUpdateWithWhereUniqueWithoutVariantInput | InventoryUpdateWithWhereUniqueWithoutVariantInput[];
    updateMany?: InventoryUpdateManyWithWhereWithoutVariantInput | InventoryUpdateManyWithWhereWithoutVariantInput[];
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[];
  };

  export type OrderItemUpdateManyWithoutVariantNestedInput = {
    create?:
      | XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput>
      | OrderItemCreateWithoutVariantInput[]
      | OrderItemUncheckedCreateWithoutVariantInput[];
    connectOrCreate?: OrderItemCreateOrConnectWithoutVariantInput | OrderItemCreateOrConnectWithoutVariantInput[];
    upsert?: OrderItemUpsertWithWhereUniqueWithoutVariantInput | OrderItemUpsertWithWhereUniqueWithoutVariantInput[];
    createMany?: OrderItemCreateManyVariantInputEnvelope;
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    update?: OrderItemUpdateWithWhereUniqueWithoutVariantInput | OrderItemUpdateWithWhereUniqueWithoutVariantInput[];
    updateMany?: OrderItemUpdateManyWithWhereWithoutVariantInput | OrderItemUpdateManyWithWhereWithoutVariantInput[];
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
  };

  export type InventoryUncheckedUpdateManyWithoutVariantNestedInput = {
    create?:
      | XOR<InventoryCreateWithoutVariantInput, InventoryUncheckedCreateWithoutVariantInput>
      | InventoryCreateWithoutVariantInput[]
      | InventoryUncheckedCreateWithoutVariantInput[];
    connectOrCreate?: InventoryCreateOrConnectWithoutVariantInput | InventoryCreateOrConnectWithoutVariantInput[];
    upsert?: InventoryUpsertWithWhereUniqueWithoutVariantInput | InventoryUpsertWithWhereUniqueWithoutVariantInput[];
    createMany?: InventoryCreateManyVariantInputEnvelope;
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[];
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[];
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[];
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[];
    update?: InventoryUpdateWithWhereUniqueWithoutVariantInput | InventoryUpdateWithWhereUniqueWithoutVariantInput[];
    updateMany?: InventoryUpdateManyWithWhereWithoutVariantInput | InventoryUpdateManyWithWhereWithoutVariantInput[];
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[];
  };

  export type OrderItemUncheckedUpdateManyWithoutVariantNestedInput = {
    create?:
      | XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput>
      | OrderItemCreateWithoutVariantInput[]
      | OrderItemUncheckedCreateWithoutVariantInput[];
    connectOrCreate?: OrderItemCreateOrConnectWithoutVariantInput | OrderItemCreateOrConnectWithoutVariantInput[];
    upsert?: OrderItemUpsertWithWhereUniqueWithoutVariantInput | OrderItemUpsertWithWhereUniqueWithoutVariantInput[];
    createMany?: OrderItemCreateManyVariantInputEnvelope;
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    update?: OrderItemUpdateWithWhereUniqueWithoutVariantInput | OrderItemUpdateWithWhereUniqueWithoutVariantInput[];
    updateMany?: OrderItemUpdateManyWithWhereWithoutVariantInput | OrderItemUpdateManyWithWhereWithoutVariantInput[];
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
  };

  export type ProductVariantCreateNestedOneWithoutInventoryInput = {
    create?: XOR<ProductVariantCreateWithoutInventoryInput, ProductVariantUncheckedCreateWithoutInventoryInput>;
    connectOrCreate?: ProductVariantCreateOrConnectWithoutInventoryInput;
    connect?: ProductVariantWhereUniqueInput;
  };

  export type ProductVariantUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<ProductVariantCreateWithoutInventoryInput, ProductVariantUncheckedCreateWithoutInventoryInput>;
    connectOrCreate?: ProductVariantCreateOrConnectWithoutInventoryInput;
    upsert?: ProductVariantUpsertWithoutInventoryInput;
    connect?: ProductVariantWhereUniqueInput;
    update?: XOR<
      XOR<ProductVariantUpdateToOneWithWhereWithoutInventoryInput, ProductVariantUpdateWithoutInventoryInput>,
      ProductVariantUncheckedUpdateWithoutInventoryInput
    >;
  };

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>;
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput;
    connect?: UserWhereUniqueInput;
  };

  export type PaymentMetaCreateNestedOneWithoutOrderInput = {
    create?: XOR<PaymentMetaCreateWithoutOrderInput, PaymentMetaUncheckedCreateWithoutOrderInput>;
    connectOrCreate?: PaymentMetaCreateOrConnectWithoutOrderInput;
    connect?: PaymentMetaWhereUniqueInput;
  };

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?:
      | XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
      | OrderItemCreateWithoutOrderInput[]
      | OrderItemUncheckedCreateWithoutOrderInput[];
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[];
    createMany?: OrderItemCreateManyOrderInputEnvelope;
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
  };

  export type AddressCreateNestedOneWithoutOrdersShippingInput = {
    create?: XOR<AddressCreateWithoutOrdersShippingInput, AddressUncheckedCreateWithoutOrdersShippingInput>;
    connectOrCreate?: AddressCreateOrConnectWithoutOrdersShippingInput;
    connect?: AddressWhereUniqueInput;
  };

  export type AddressCreateNestedOneWithoutOrdersBillingInput = {
    create?: XOR<AddressCreateWithoutOrdersBillingInput, AddressUncheckedCreateWithoutOrdersBillingInput>;
    connectOrCreate?: AddressCreateOrConnectWithoutOrdersBillingInput;
    connect?: AddressWhereUniqueInput;
  };

  export type CouponCreateNestedOneWithoutOrderInput = {
    create?: XOR<CouponCreateWithoutOrderInput, CouponUncheckedCreateWithoutOrderInput>;
    connectOrCreate?: CouponCreateOrConnectWithoutOrderInput;
    connect?: CouponWhereUniqueInput;
  };

  export type ReturnRequestCreateNestedManyWithoutOrderInput = {
    create?:
      | XOR<ReturnRequestCreateWithoutOrderInput, ReturnRequestUncheckedCreateWithoutOrderInput>
      | ReturnRequestCreateWithoutOrderInput[]
      | ReturnRequestUncheckedCreateWithoutOrderInput[];
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutOrderInput | ReturnRequestCreateOrConnectWithoutOrderInput[];
    createMany?: ReturnRequestCreateManyOrderInputEnvelope;
    connect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
  };

  export type RefundCreateNestedManyWithoutOrderInput = {
    create?:
      | XOR<RefundCreateWithoutOrderInput, RefundUncheckedCreateWithoutOrderInput>
      | RefundCreateWithoutOrderInput[]
      | RefundUncheckedCreateWithoutOrderInput[];
    connectOrCreate?: RefundCreateOrConnectWithoutOrderInput | RefundCreateOrConnectWithoutOrderInput[];
    createMany?: RefundCreateManyOrderInputEnvelope;
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[];
  };

  export type PaymentMetaUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<PaymentMetaCreateWithoutOrderInput, PaymentMetaUncheckedCreateWithoutOrderInput>;
    connectOrCreate?: PaymentMetaCreateOrConnectWithoutOrderInput;
    connect?: PaymentMetaWhereUniqueInput;
  };

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?:
      | XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
      | OrderItemCreateWithoutOrderInput[]
      | OrderItemUncheckedCreateWithoutOrderInput[];
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[];
    createMany?: OrderItemCreateManyOrderInputEnvelope;
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
  };

  export type ReturnRequestUncheckedCreateNestedManyWithoutOrderInput = {
    create?:
      | XOR<ReturnRequestCreateWithoutOrderInput, ReturnRequestUncheckedCreateWithoutOrderInput>
      | ReturnRequestCreateWithoutOrderInput[]
      | ReturnRequestUncheckedCreateWithoutOrderInput[];
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutOrderInput | ReturnRequestCreateOrConnectWithoutOrderInput[];
    createMany?: ReturnRequestCreateManyOrderInputEnvelope;
    connect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
  };

  export type RefundUncheckedCreateNestedManyWithoutOrderInput = {
    create?:
      | XOR<RefundCreateWithoutOrderInput, RefundUncheckedCreateWithoutOrderInput>
      | RefundCreateWithoutOrderInput[]
      | RefundUncheckedCreateWithoutOrderInput[];
    connectOrCreate?: RefundCreateOrConnectWithoutOrderInput | RefundCreateOrConnectWithoutOrderInput[];
    createMany?: RefundCreateManyOrderInputEnvelope;
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[];
  };

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus;
  };

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod;
  };

  export type UserUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>;
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput;
    upsert?: UserUpsertWithoutOrdersInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>,
      UserUncheckedUpdateWithoutOrdersInput
    >;
  };

  export type PaymentMetaUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PaymentMetaCreateWithoutOrderInput, PaymentMetaUncheckedCreateWithoutOrderInput>;
    connectOrCreate?: PaymentMetaCreateOrConnectWithoutOrderInput;
    upsert?: PaymentMetaUpsertWithoutOrderInput;
    disconnect?: PaymentMetaWhereInput | boolean;
    delete?: PaymentMetaWhereInput | boolean;
    connect?: PaymentMetaWhereUniqueInput;
    update?: XOR<
      XOR<PaymentMetaUpdateToOneWithWhereWithoutOrderInput, PaymentMetaUpdateWithoutOrderInput>,
      PaymentMetaUncheckedUpdateWithoutOrderInput
    >;
  };

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?:
      | XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
      | OrderItemCreateWithoutOrderInput[]
      | OrderItemUncheckedCreateWithoutOrderInput[];
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[];
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[];
    createMany?: OrderItemCreateManyOrderInputEnvelope;
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[];
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[];
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
  };

  export type AddressUpdateOneWithoutOrdersShippingNestedInput = {
    create?: XOR<AddressCreateWithoutOrdersShippingInput, AddressUncheckedCreateWithoutOrdersShippingInput>;
    connectOrCreate?: AddressCreateOrConnectWithoutOrdersShippingInput;
    upsert?: AddressUpsertWithoutOrdersShippingInput;
    disconnect?: AddressWhereInput | boolean;
    delete?: AddressWhereInput | boolean;
    connect?: AddressWhereUniqueInput;
    update?: XOR<
      XOR<AddressUpdateToOneWithWhereWithoutOrdersShippingInput, AddressUpdateWithoutOrdersShippingInput>,
      AddressUncheckedUpdateWithoutOrdersShippingInput
    >;
  };

  export type AddressUpdateOneWithoutOrdersBillingNestedInput = {
    create?: XOR<AddressCreateWithoutOrdersBillingInput, AddressUncheckedCreateWithoutOrdersBillingInput>;
    connectOrCreate?: AddressCreateOrConnectWithoutOrdersBillingInput;
    upsert?: AddressUpsertWithoutOrdersBillingInput;
    disconnect?: AddressWhereInput | boolean;
    delete?: AddressWhereInput | boolean;
    connect?: AddressWhereUniqueInput;
    update?: XOR<
      XOR<AddressUpdateToOneWithWhereWithoutOrdersBillingInput, AddressUpdateWithoutOrdersBillingInput>,
      AddressUncheckedUpdateWithoutOrdersBillingInput
    >;
  };

  export type CouponUpdateOneWithoutOrderNestedInput = {
    create?: XOR<CouponCreateWithoutOrderInput, CouponUncheckedCreateWithoutOrderInput>;
    connectOrCreate?: CouponCreateOrConnectWithoutOrderInput;
    upsert?: CouponUpsertWithoutOrderInput;
    disconnect?: CouponWhereInput | boolean;
    delete?: CouponWhereInput | boolean;
    connect?: CouponWhereUniqueInput;
    update?: XOR<
      XOR<CouponUpdateToOneWithWhereWithoutOrderInput, CouponUpdateWithoutOrderInput>,
      CouponUncheckedUpdateWithoutOrderInput
    >;
  };

  export type ReturnRequestUpdateManyWithoutOrderNestedInput = {
    create?:
      | XOR<ReturnRequestCreateWithoutOrderInput, ReturnRequestUncheckedCreateWithoutOrderInput>
      | ReturnRequestCreateWithoutOrderInput[]
      | ReturnRequestUncheckedCreateWithoutOrderInput[];
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutOrderInput | ReturnRequestCreateOrConnectWithoutOrderInput[];
    upsert?:
      | ReturnRequestUpsertWithWhereUniqueWithoutOrderInput
      | ReturnRequestUpsertWithWhereUniqueWithoutOrderInput[];
    createMany?: ReturnRequestCreateManyOrderInputEnvelope;
    set?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
    disconnect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
    delete?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
    connect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
    update?:
      | ReturnRequestUpdateWithWhereUniqueWithoutOrderInput
      | ReturnRequestUpdateWithWhereUniqueWithoutOrderInput[];
    updateMany?:
      | ReturnRequestUpdateManyWithWhereWithoutOrderInput
      | ReturnRequestUpdateManyWithWhereWithoutOrderInput[];
    deleteMany?: ReturnRequestScalarWhereInput | ReturnRequestScalarWhereInput[];
  };

  export type RefundUpdateManyWithoutOrderNestedInput = {
    create?:
      | XOR<RefundCreateWithoutOrderInput, RefundUncheckedCreateWithoutOrderInput>
      | RefundCreateWithoutOrderInput[]
      | RefundUncheckedCreateWithoutOrderInput[];
    connectOrCreate?: RefundCreateOrConnectWithoutOrderInput | RefundCreateOrConnectWithoutOrderInput[];
    upsert?: RefundUpsertWithWhereUniqueWithoutOrderInput | RefundUpsertWithWhereUniqueWithoutOrderInput[];
    createMany?: RefundCreateManyOrderInputEnvelope;
    set?: RefundWhereUniqueInput | RefundWhereUniqueInput[];
    disconnect?: RefundWhereUniqueInput | RefundWhereUniqueInput[];
    delete?: RefundWhereUniqueInput | RefundWhereUniqueInput[];
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[];
    update?: RefundUpdateWithWhereUniqueWithoutOrderInput | RefundUpdateWithWhereUniqueWithoutOrderInput[];
    updateMany?: RefundUpdateManyWithWhereWithoutOrderInput | RefundUpdateManyWithWhereWithoutOrderInput[];
    deleteMany?: RefundScalarWhereInput | RefundScalarWhereInput[];
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type PaymentMetaUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PaymentMetaCreateWithoutOrderInput, PaymentMetaUncheckedCreateWithoutOrderInput>;
    connectOrCreate?: PaymentMetaCreateOrConnectWithoutOrderInput;
    upsert?: PaymentMetaUpsertWithoutOrderInput;
    disconnect?: PaymentMetaWhereInput | boolean;
    delete?: PaymentMetaWhereInput | boolean;
    connect?: PaymentMetaWhereUniqueInput;
    update?: XOR<
      XOR<PaymentMetaUpdateToOneWithWhereWithoutOrderInput, PaymentMetaUpdateWithoutOrderInput>,
      PaymentMetaUncheckedUpdateWithoutOrderInput
    >;
  };

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?:
      | XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
      | OrderItemCreateWithoutOrderInput[]
      | OrderItemUncheckedCreateWithoutOrderInput[];
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[];
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[];
    createMany?: OrderItemCreateManyOrderInputEnvelope;
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[];
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[];
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
  };

  export type ReturnRequestUncheckedUpdateManyWithoutOrderNestedInput = {
    create?:
      | XOR<ReturnRequestCreateWithoutOrderInput, ReturnRequestUncheckedCreateWithoutOrderInput>
      | ReturnRequestCreateWithoutOrderInput[]
      | ReturnRequestUncheckedCreateWithoutOrderInput[];
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutOrderInput | ReturnRequestCreateOrConnectWithoutOrderInput[];
    upsert?:
      | ReturnRequestUpsertWithWhereUniqueWithoutOrderInput
      | ReturnRequestUpsertWithWhereUniqueWithoutOrderInput[];
    createMany?: ReturnRequestCreateManyOrderInputEnvelope;
    set?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
    disconnect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
    delete?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
    connect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
    update?:
      | ReturnRequestUpdateWithWhereUniqueWithoutOrderInput
      | ReturnRequestUpdateWithWhereUniqueWithoutOrderInput[];
    updateMany?:
      | ReturnRequestUpdateManyWithWhereWithoutOrderInput
      | ReturnRequestUpdateManyWithWhereWithoutOrderInput[];
    deleteMany?: ReturnRequestScalarWhereInput | ReturnRequestScalarWhereInput[];
  };

  export type RefundUncheckedUpdateManyWithoutOrderNestedInput = {
    create?:
      | XOR<RefundCreateWithoutOrderInput, RefundUncheckedCreateWithoutOrderInput>
      | RefundCreateWithoutOrderInput[]
      | RefundUncheckedCreateWithoutOrderInput[];
    connectOrCreate?: RefundCreateOrConnectWithoutOrderInput | RefundCreateOrConnectWithoutOrderInput[];
    upsert?: RefundUpsertWithWhereUniqueWithoutOrderInput | RefundUpsertWithWhereUniqueWithoutOrderInput[];
    createMany?: RefundCreateManyOrderInputEnvelope;
    set?: RefundWhereUniqueInput | RefundWhereUniqueInput[];
    disconnect?: RefundWhereUniqueInput | RefundWhereUniqueInput[];
    delete?: RefundWhereUniqueInput | RefundWhereUniqueInput[];
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[];
    update?: RefundUpdateWithWhereUniqueWithoutOrderInput | RefundUpdateWithWhereUniqueWithoutOrderInput[];
    updateMany?: RefundUpdateManyWithWhereWithoutOrderInput | RefundUpdateManyWithWhereWithoutOrderInput[];
    deleteMany?: RefundScalarWhereInput | RefundScalarWhereInput[];
  };

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>;
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput;
    connect?: OrderWhereUniqueInput;
  };

  export type ProductCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<ProductCreateWithoutOrderItemInput, ProductUncheckedCreateWithoutOrderItemInput>;
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemInput;
    connect?: ProductWhereUniqueInput;
  };

  export type ProductVariantCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<ProductVariantCreateWithoutOrderItemInput, ProductVariantUncheckedCreateWithoutOrderItemInput>;
    connectOrCreate?: ProductVariantCreateOrConnectWithoutOrderItemInput;
    connect?: ProductVariantWhereUniqueInput;
  };

  export type ReturnRequestCreateNestedManyWithoutOrderItemInput = {
    create?:
      | XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput>
      | ReturnRequestCreateWithoutOrderItemInput[]
      | ReturnRequestUncheckedCreateWithoutOrderItemInput[];
    connectOrCreate?:
      | ReturnRequestCreateOrConnectWithoutOrderItemInput
      | ReturnRequestCreateOrConnectWithoutOrderItemInput[];
    createMany?: ReturnRequestCreateManyOrderItemInputEnvelope;
    connect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
  };

  export type ReturnRequestUncheckedCreateNestedManyWithoutOrderItemInput = {
    create?:
      | XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput>
      | ReturnRequestCreateWithoutOrderItemInput[]
      | ReturnRequestUncheckedCreateWithoutOrderItemInput[];
    connectOrCreate?:
      | ReturnRequestCreateOrConnectWithoutOrderItemInput
      | ReturnRequestCreateOrConnectWithoutOrderItemInput[];
    createMany?: ReturnRequestCreateManyOrderItemInputEnvelope;
    connect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
  };

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>;
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput;
    upsert?: OrderUpsertWithoutItemsInput;
    connect?: OrderWhereUniqueInput;
    update?: XOR<
      XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>,
      OrderUncheckedUpdateWithoutItemsInput
    >;
  };

  export type ProductUpdateOneWithoutOrderItemNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemInput, ProductUncheckedCreateWithoutOrderItemInput>;
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemInput;
    upsert?: ProductUpsertWithoutOrderItemInput;
    disconnect?: ProductWhereInput | boolean;
    delete?: ProductWhereInput | boolean;
    connect?: ProductWhereUniqueInput;
    update?: XOR<
      XOR<ProductUpdateToOneWithWhereWithoutOrderItemInput, ProductUpdateWithoutOrderItemInput>,
      ProductUncheckedUpdateWithoutOrderItemInput
    >;
  };

  export type ProductVariantUpdateOneWithoutOrderItemNestedInput = {
    create?: XOR<ProductVariantCreateWithoutOrderItemInput, ProductVariantUncheckedCreateWithoutOrderItemInput>;
    connectOrCreate?: ProductVariantCreateOrConnectWithoutOrderItemInput;
    upsert?: ProductVariantUpsertWithoutOrderItemInput;
    disconnect?: ProductVariantWhereInput | boolean;
    delete?: ProductVariantWhereInput | boolean;
    connect?: ProductVariantWhereUniqueInput;
    update?: XOR<
      XOR<ProductVariantUpdateToOneWithWhereWithoutOrderItemInput, ProductVariantUpdateWithoutOrderItemInput>,
      ProductVariantUncheckedUpdateWithoutOrderItemInput
    >;
  };

  export type ReturnRequestUpdateManyWithoutOrderItemNestedInput = {
    create?:
      | XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput>
      | ReturnRequestCreateWithoutOrderItemInput[]
      | ReturnRequestUncheckedCreateWithoutOrderItemInput[];
    connectOrCreate?:
      | ReturnRequestCreateOrConnectWithoutOrderItemInput
      | ReturnRequestCreateOrConnectWithoutOrderItemInput[];
    upsert?:
      | ReturnRequestUpsertWithWhereUniqueWithoutOrderItemInput
      | ReturnRequestUpsertWithWhereUniqueWithoutOrderItemInput[];
    createMany?: ReturnRequestCreateManyOrderItemInputEnvelope;
    set?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
    disconnect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
    delete?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
    connect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
    update?:
      | ReturnRequestUpdateWithWhereUniqueWithoutOrderItemInput
      | ReturnRequestUpdateWithWhereUniqueWithoutOrderItemInput[];
    updateMany?:
      | ReturnRequestUpdateManyWithWhereWithoutOrderItemInput
      | ReturnRequestUpdateManyWithWhereWithoutOrderItemInput[];
    deleteMany?: ReturnRequestScalarWhereInput | ReturnRequestScalarWhereInput[];
  };

  export type ReturnRequestUncheckedUpdateManyWithoutOrderItemNestedInput = {
    create?:
      | XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput>
      | ReturnRequestCreateWithoutOrderItemInput[]
      | ReturnRequestUncheckedCreateWithoutOrderItemInput[];
    connectOrCreate?:
      | ReturnRequestCreateOrConnectWithoutOrderItemInput
      | ReturnRequestCreateOrConnectWithoutOrderItemInput[];
    upsert?:
      | ReturnRequestUpsertWithWhereUniqueWithoutOrderItemInput
      | ReturnRequestUpsertWithWhereUniqueWithoutOrderItemInput[];
    createMany?: ReturnRequestCreateManyOrderItemInputEnvelope;
    set?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
    disconnect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
    delete?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
    connect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[];
    update?:
      | ReturnRequestUpdateWithWhereUniqueWithoutOrderItemInput
      | ReturnRequestUpdateWithWhereUniqueWithoutOrderItemInput[];
    updateMany?:
      | ReturnRequestUpdateManyWithWhereWithoutOrderItemInput
      | ReturnRequestUpdateManyWithWhereWithoutOrderItemInput[];
    deleteMany?: ReturnRequestScalarWhereInput | ReturnRequestScalarWhereInput[];
  };

  export type OrderCreateNestedManyWithoutCouponInput = {
    create?:
      | XOR<OrderCreateWithoutCouponInput, OrderUncheckedCreateWithoutCouponInput>
      | OrderCreateWithoutCouponInput[]
      | OrderUncheckedCreateWithoutCouponInput[];
    connectOrCreate?: OrderCreateOrConnectWithoutCouponInput | OrderCreateOrConnectWithoutCouponInput[];
    createMany?: OrderCreateManyCouponInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type OrderUncheckedCreateNestedManyWithoutCouponInput = {
    create?:
      | XOR<OrderCreateWithoutCouponInput, OrderUncheckedCreateWithoutCouponInput>
      | OrderCreateWithoutCouponInput[]
      | OrderUncheckedCreateWithoutCouponInput[];
    connectOrCreate?: OrderCreateOrConnectWithoutCouponInput | OrderCreateOrConnectWithoutCouponInput[];
    createMany?: OrderCreateManyCouponInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type EnumCouponTypeFieldUpdateOperationsInput = {
    set?: $Enums.CouponType;
  };

  export type OrderUpdateManyWithoutCouponNestedInput = {
    create?:
      | XOR<OrderCreateWithoutCouponInput, OrderUncheckedCreateWithoutCouponInput>
      | OrderCreateWithoutCouponInput[]
      | OrderUncheckedCreateWithoutCouponInput[];
    connectOrCreate?: OrderCreateOrConnectWithoutCouponInput | OrderCreateOrConnectWithoutCouponInput[];
    upsert?: OrderUpsertWithWhereUniqueWithoutCouponInput | OrderUpsertWithWhereUniqueWithoutCouponInput[];
    createMany?: OrderCreateManyCouponInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?: OrderUpdateWithWhereUniqueWithoutCouponInput | OrderUpdateWithWhereUniqueWithoutCouponInput[];
    updateMany?: OrderUpdateManyWithWhereWithoutCouponInput | OrderUpdateManyWithWhereWithoutCouponInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type OrderUncheckedUpdateManyWithoutCouponNestedInput = {
    create?:
      | XOR<OrderCreateWithoutCouponInput, OrderUncheckedCreateWithoutCouponInput>
      | OrderCreateWithoutCouponInput[]
      | OrderUncheckedCreateWithoutCouponInput[];
    connectOrCreate?: OrderCreateOrConnectWithoutCouponInput | OrderCreateOrConnectWithoutCouponInput[];
    upsert?: OrderUpsertWithWhereUniqueWithoutCouponInput | OrderUpsertWithWhereUniqueWithoutCouponInput[];
    createMany?: OrderCreateManyCouponInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?: OrderUpdateWithWhereUniqueWithoutCouponInput | OrderUpdateWithWhereUniqueWithoutCouponInput[];
    updateMany?: OrderUpdateManyWithWhereWithoutCouponInput | OrderUpdateManyWithWhereWithoutCouponInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput;
    connect?: UserWhereUniqueInput;
  };

  export type ProductCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>;
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput;
    connect?: ProductWhereUniqueInput;
  };

  export type UserUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput;
    upsert?: UserUpsertWithoutReviewsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>,
      UserUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type ProductUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>;
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput;
    upsert?: ProductUpsertWithoutReviewsInput;
    connect?: ProductWhereUniqueInput;
    update?: XOR<
      XOR<ProductUpdateToOneWithWhereWithoutReviewsInput, ProductUpdateWithoutReviewsInput>,
      ProductUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type UserCreateNestedOneWithoutWishlistInput = {
    create?: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>;
    connectOrCreate?: UserCreateOrConnectWithoutWishlistInput;
    connect?: UserWhereUniqueInput;
  };

  export type WishlistItemCreateNestedManyWithoutWishlistInput = {
    create?:
      | XOR<WishlistItemCreateWithoutWishlistInput, WishlistItemUncheckedCreateWithoutWishlistInput>
      | WishlistItemCreateWithoutWishlistInput[]
      | WishlistItemUncheckedCreateWithoutWishlistInput[];
    connectOrCreate?:
      | WishlistItemCreateOrConnectWithoutWishlistInput
      | WishlistItemCreateOrConnectWithoutWishlistInput[];
    createMany?: WishlistItemCreateManyWishlistInputEnvelope;
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
  };

  export type WishlistItemUncheckedCreateNestedManyWithoutWishlistInput = {
    create?:
      | XOR<WishlistItemCreateWithoutWishlistInput, WishlistItemUncheckedCreateWithoutWishlistInput>
      | WishlistItemCreateWithoutWishlistInput[]
      | WishlistItemUncheckedCreateWithoutWishlistInput[];
    connectOrCreate?:
      | WishlistItemCreateOrConnectWithoutWishlistInput
      | WishlistItemCreateOrConnectWithoutWishlistInput[];
    createMany?: WishlistItemCreateManyWishlistInputEnvelope;
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
  };

  export type UserUpdateOneRequiredWithoutWishlistNestedInput = {
    create?: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>;
    connectOrCreate?: UserCreateOrConnectWithoutWishlistInput;
    upsert?: UserUpsertWithoutWishlistInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutWishlistInput, UserUpdateWithoutWishlistInput>,
      UserUncheckedUpdateWithoutWishlistInput
    >;
  };

  export type WishlistItemUpdateManyWithoutWishlistNestedInput = {
    create?:
      | XOR<WishlistItemCreateWithoutWishlistInput, WishlistItemUncheckedCreateWithoutWishlistInput>
      | WishlistItemCreateWithoutWishlistInput[]
      | WishlistItemUncheckedCreateWithoutWishlistInput[];
    connectOrCreate?:
      | WishlistItemCreateOrConnectWithoutWishlistInput
      | WishlistItemCreateOrConnectWithoutWishlistInput[];
    upsert?:
      | WishlistItemUpsertWithWhereUniqueWithoutWishlistInput
      | WishlistItemUpsertWithWhereUniqueWithoutWishlistInput[];
    createMany?: WishlistItemCreateManyWishlistInputEnvelope;
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
    update?:
      | WishlistItemUpdateWithWhereUniqueWithoutWishlistInput
      | WishlistItemUpdateWithWhereUniqueWithoutWishlistInput[];
    updateMany?:
      | WishlistItemUpdateManyWithWhereWithoutWishlistInput
      | WishlistItemUpdateManyWithWhereWithoutWishlistInput[];
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[];
  };

  export type WishlistItemUncheckedUpdateManyWithoutWishlistNestedInput = {
    create?:
      | XOR<WishlistItemCreateWithoutWishlistInput, WishlistItemUncheckedCreateWithoutWishlistInput>
      | WishlistItemCreateWithoutWishlistInput[]
      | WishlistItemUncheckedCreateWithoutWishlistInput[];
    connectOrCreate?:
      | WishlistItemCreateOrConnectWithoutWishlistInput
      | WishlistItemCreateOrConnectWithoutWishlistInput[];
    upsert?:
      | WishlistItemUpsertWithWhereUniqueWithoutWishlistInput
      | WishlistItemUpsertWithWhereUniqueWithoutWishlistInput[];
    createMany?: WishlistItemCreateManyWishlistInputEnvelope;
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[];
    update?:
      | WishlistItemUpdateWithWhereUniqueWithoutWishlistInput
      | WishlistItemUpdateWithWhereUniqueWithoutWishlistInput[];
    updateMany?:
      | WishlistItemUpdateManyWithWhereWithoutWishlistInput
      | WishlistItemUpdateManyWithWhereWithoutWishlistInput[];
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[];
  };

  export type WishlistCreateNestedOneWithoutItemsInput = {
    create?: XOR<WishlistCreateWithoutItemsInput, WishlistUncheckedCreateWithoutItemsInput>;
    connectOrCreate?: WishlistCreateOrConnectWithoutItemsInput;
    connect?: WishlistWhereUniqueInput;
  };

  export type ProductCreateNestedOneWithoutWishlistItemInput = {
    create?: XOR<ProductCreateWithoutWishlistItemInput, ProductUncheckedCreateWithoutWishlistItemInput>;
    connectOrCreate?: ProductCreateOrConnectWithoutWishlistItemInput;
    connect?: ProductWhereUniqueInput;
  };

  export type WishlistUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<WishlistCreateWithoutItemsInput, WishlistUncheckedCreateWithoutItemsInput>;
    connectOrCreate?: WishlistCreateOrConnectWithoutItemsInput;
    upsert?: WishlistUpsertWithoutItemsInput;
    connect?: WishlistWhereUniqueInput;
    update?: XOR<
      XOR<WishlistUpdateToOneWithWhereWithoutItemsInput, WishlistUpdateWithoutItemsInput>,
      WishlistUncheckedUpdateWithoutItemsInput
    >;
  };

  export type ProductUpdateOneRequiredWithoutWishlistItemNestedInput = {
    create?: XOR<ProductCreateWithoutWishlistItemInput, ProductUncheckedCreateWithoutWishlistItemInput>;
    connectOrCreate?: ProductCreateOrConnectWithoutWishlistItemInput;
    upsert?: ProductUpsertWithoutWishlistItemInput;
    connect?: ProductWhereUniqueInput;
    update?: XOR<
      XOR<ProductUpdateToOneWithWhereWithoutWishlistItemInput, ProductUpdateWithoutWishlistItemInput>,
      ProductUncheckedUpdateWithoutWishlistItemInput
    >;
  };

  export type UserCreateNestedOneWithoutAddressesInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput;
    connect?: UserWhereUniqueInput;
  };

  export type OrderCreateNestedManyWithoutShippingAddressInput = {
    create?:
      | XOR<OrderCreateWithoutShippingAddressInput, OrderUncheckedCreateWithoutShippingAddressInput>
      | OrderCreateWithoutShippingAddressInput[]
      | OrderUncheckedCreateWithoutShippingAddressInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutShippingAddressInput
      | OrderCreateOrConnectWithoutShippingAddressInput[];
    createMany?: OrderCreateManyShippingAddressInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type OrderCreateNestedManyWithoutBillingAddressInput = {
    create?:
      | XOR<OrderCreateWithoutBillingAddressInput, OrderUncheckedCreateWithoutBillingAddressInput>
      | OrderCreateWithoutBillingAddressInput[]
      | OrderUncheckedCreateWithoutBillingAddressInput[];
    connectOrCreate?: OrderCreateOrConnectWithoutBillingAddressInput | OrderCreateOrConnectWithoutBillingAddressInput[];
    createMany?: OrderCreateManyBillingAddressInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type OrderUncheckedCreateNestedManyWithoutShippingAddressInput = {
    create?:
      | XOR<OrderCreateWithoutShippingAddressInput, OrderUncheckedCreateWithoutShippingAddressInput>
      | OrderCreateWithoutShippingAddressInput[]
      | OrderUncheckedCreateWithoutShippingAddressInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutShippingAddressInput
      | OrderCreateOrConnectWithoutShippingAddressInput[];
    createMany?: OrderCreateManyShippingAddressInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type OrderUncheckedCreateNestedManyWithoutBillingAddressInput = {
    create?:
      | XOR<OrderCreateWithoutBillingAddressInput, OrderUncheckedCreateWithoutBillingAddressInput>
      | OrderCreateWithoutBillingAddressInput[]
      | OrderUncheckedCreateWithoutBillingAddressInput[];
    connectOrCreate?: OrderCreateOrConnectWithoutBillingAddressInput | OrderCreateOrConnectWithoutBillingAddressInput[];
    createMany?: OrderCreateManyBillingAddressInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type UserUpdateOneWithoutAddressesNestedInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput;
    upsert?: UserUpsertWithoutAddressesInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutAddressesInput, UserUpdateWithoutAddressesInput>,
      UserUncheckedUpdateWithoutAddressesInput
    >;
  };

  export type OrderUpdateManyWithoutShippingAddressNestedInput = {
    create?:
      | XOR<OrderCreateWithoutShippingAddressInput, OrderUncheckedCreateWithoutShippingAddressInput>
      | OrderCreateWithoutShippingAddressInput[]
      | OrderUncheckedCreateWithoutShippingAddressInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutShippingAddressInput
      | OrderCreateOrConnectWithoutShippingAddressInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutShippingAddressInput
      | OrderUpsertWithWhereUniqueWithoutShippingAddressInput[];
    createMany?: OrderCreateManyShippingAddressInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutShippingAddressInput
      | OrderUpdateWithWhereUniqueWithoutShippingAddressInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutShippingAddressInput
      | OrderUpdateManyWithWhereWithoutShippingAddressInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type OrderUpdateManyWithoutBillingAddressNestedInput = {
    create?:
      | XOR<OrderCreateWithoutBillingAddressInput, OrderUncheckedCreateWithoutBillingAddressInput>
      | OrderCreateWithoutBillingAddressInput[]
      | OrderUncheckedCreateWithoutBillingAddressInput[];
    connectOrCreate?: OrderCreateOrConnectWithoutBillingAddressInput | OrderCreateOrConnectWithoutBillingAddressInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutBillingAddressInput
      | OrderUpsertWithWhereUniqueWithoutBillingAddressInput[];
    createMany?: OrderCreateManyBillingAddressInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutBillingAddressInput
      | OrderUpdateWithWhereUniqueWithoutBillingAddressInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutBillingAddressInput
      | OrderUpdateManyWithWhereWithoutBillingAddressInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type OrderUncheckedUpdateManyWithoutShippingAddressNestedInput = {
    create?:
      | XOR<OrderCreateWithoutShippingAddressInput, OrderUncheckedCreateWithoutShippingAddressInput>
      | OrderCreateWithoutShippingAddressInput[]
      | OrderUncheckedCreateWithoutShippingAddressInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutShippingAddressInput
      | OrderCreateOrConnectWithoutShippingAddressInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutShippingAddressInput
      | OrderUpsertWithWhereUniqueWithoutShippingAddressInput[];
    createMany?: OrderCreateManyShippingAddressInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutShippingAddressInput
      | OrderUpdateWithWhereUniqueWithoutShippingAddressInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutShippingAddressInput
      | OrderUpdateManyWithWhereWithoutShippingAddressInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type OrderUncheckedUpdateManyWithoutBillingAddressNestedInput = {
    create?:
      | XOR<OrderCreateWithoutBillingAddressInput, OrderUncheckedCreateWithoutBillingAddressInput>
      | OrderCreateWithoutBillingAddressInput[]
      | OrderUncheckedCreateWithoutBillingAddressInput[];
    connectOrCreate?: OrderCreateOrConnectWithoutBillingAddressInput | OrderCreateOrConnectWithoutBillingAddressInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutBillingAddressInput
      | OrderUpsertWithWhereUniqueWithoutBillingAddressInput[];
    createMany?: OrderCreateManyBillingAddressInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutBillingAddressInput
      | OrderUpdateWithWhereUniqueWithoutBillingAddressInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutBillingAddressInput
      | OrderUpdateManyWithWhereWithoutBillingAddressInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutAuditLogInput = {
    create?: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneWithoutAuditLogNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogInput;
    upsert?: UserUpsertWithoutAuditLogInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutAuditLogInput, UserUpdateWithoutAuditLogInput>,
      UserUncheckedUpdateWithoutAuditLogInput
    >;
  };

  export type OrderCreateNestedOneWithoutReturnRequestInput = {
    create?: XOR<OrderCreateWithoutReturnRequestInput, OrderUncheckedCreateWithoutReturnRequestInput>;
    connectOrCreate?: OrderCreateOrConnectWithoutReturnRequestInput;
    connect?: OrderWhereUniqueInput;
  };

  export type OrderItemCreateNestedOneWithoutReturnRequestInput = {
    create?: XOR<OrderItemCreateWithoutReturnRequestInput, OrderItemUncheckedCreateWithoutReturnRequestInput>;
    connectOrCreate?: OrderItemCreateOrConnectWithoutReturnRequestInput;
    connect?: OrderItemWhereUniqueInput;
  };

  export type RefundCreateNestedOneWithoutReturnRequestInput = {
    create?: XOR<RefundCreateWithoutReturnRequestInput, RefundUncheckedCreateWithoutReturnRequestInput>;
    connectOrCreate?: RefundCreateOrConnectWithoutReturnRequestInput;
    connect?: RefundWhereUniqueInput;
  };

  export type RefundUncheckedCreateNestedOneWithoutReturnRequestInput = {
    create?: XOR<RefundCreateWithoutReturnRequestInput, RefundUncheckedCreateWithoutReturnRequestInput>;
    connectOrCreate?: RefundCreateOrConnectWithoutReturnRequestInput;
    connect?: RefundWhereUniqueInput;
  };

  export type EnumReturnStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReturnStatus;
  };

  export type OrderUpdateOneRequiredWithoutReturnRequestNestedInput = {
    create?: XOR<OrderCreateWithoutReturnRequestInput, OrderUncheckedCreateWithoutReturnRequestInput>;
    connectOrCreate?: OrderCreateOrConnectWithoutReturnRequestInput;
    upsert?: OrderUpsertWithoutReturnRequestInput;
    connect?: OrderWhereUniqueInput;
    update?: XOR<
      XOR<OrderUpdateToOneWithWhereWithoutReturnRequestInput, OrderUpdateWithoutReturnRequestInput>,
      OrderUncheckedUpdateWithoutReturnRequestInput
    >;
  };

  export type OrderItemUpdateOneRequiredWithoutReturnRequestNestedInput = {
    create?: XOR<OrderItemCreateWithoutReturnRequestInput, OrderItemUncheckedCreateWithoutReturnRequestInput>;
    connectOrCreate?: OrderItemCreateOrConnectWithoutReturnRequestInput;
    upsert?: OrderItemUpsertWithoutReturnRequestInput;
    connect?: OrderItemWhereUniqueInput;
    update?: XOR<
      XOR<OrderItemUpdateToOneWithWhereWithoutReturnRequestInput, OrderItemUpdateWithoutReturnRequestInput>,
      OrderItemUncheckedUpdateWithoutReturnRequestInput
    >;
  };

  export type RefundUpdateOneWithoutReturnRequestNestedInput = {
    create?: XOR<RefundCreateWithoutReturnRequestInput, RefundUncheckedCreateWithoutReturnRequestInput>;
    connectOrCreate?: RefundCreateOrConnectWithoutReturnRequestInput;
    upsert?: RefundUpsertWithoutReturnRequestInput;
    disconnect?: RefundWhereInput | boolean;
    delete?: RefundWhereInput | boolean;
    connect?: RefundWhereUniqueInput;
    update?: XOR<
      XOR<RefundUpdateToOneWithWhereWithoutReturnRequestInput, RefundUpdateWithoutReturnRequestInput>,
      RefundUncheckedUpdateWithoutReturnRequestInput
    >;
  };

  export type RefundUncheckedUpdateOneWithoutReturnRequestNestedInput = {
    create?: XOR<RefundCreateWithoutReturnRequestInput, RefundUncheckedCreateWithoutReturnRequestInput>;
    connectOrCreate?: RefundCreateOrConnectWithoutReturnRequestInput;
    upsert?: RefundUpsertWithoutReturnRequestInput;
    disconnect?: RefundWhereInput | boolean;
    delete?: RefundWhereInput | boolean;
    connect?: RefundWhereUniqueInput;
    update?: XOR<
      XOR<RefundUpdateToOneWithWhereWithoutReturnRequestInput, RefundUpdateWithoutReturnRequestInput>,
      RefundUncheckedUpdateWithoutReturnRequestInput
    >;
  };

  export type OrderCreateNestedOneWithoutRefundInput = {
    create?: XOR<OrderCreateWithoutRefundInput, OrderUncheckedCreateWithoutRefundInput>;
    connectOrCreate?: OrderCreateOrConnectWithoutRefundInput;
    connect?: OrderWhereUniqueInput;
  };

  export type ReturnRequestCreateNestedOneWithoutRefundInput = {
    create?: XOR<ReturnRequestCreateWithoutRefundInput, ReturnRequestUncheckedCreateWithoutRefundInput>;
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutRefundInput;
    connect?: ReturnRequestWhereUniqueInput;
  };

  export type EnumRefundStatusFieldUpdateOperationsInput = {
    set?: $Enums.RefundStatus;
  };

  export type OrderUpdateOneRequiredWithoutRefundNestedInput = {
    create?: XOR<OrderCreateWithoutRefundInput, OrderUncheckedCreateWithoutRefundInput>;
    connectOrCreate?: OrderCreateOrConnectWithoutRefundInput;
    upsert?: OrderUpsertWithoutRefundInput;
    connect?: OrderWhereUniqueInput;
    update?: XOR<
      XOR<OrderUpdateToOneWithWhereWithoutRefundInput, OrderUpdateWithoutRefundInput>,
      OrderUncheckedUpdateWithoutRefundInput
    >;
  };

  export type ReturnRequestUpdateOneWithoutRefundNestedInput = {
    create?: XOR<ReturnRequestCreateWithoutRefundInput, ReturnRequestUncheckedCreateWithoutRefundInput>;
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutRefundInput;
    upsert?: ReturnRequestUpsertWithoutRefundInput;
    disconnect?: ReturnRequestWhereInput | boolean;
    delete?: ReturnRequestWhereInput | boolean;
    connect?: ReturnRequestWhereUniqueInput;
    update?: XOR<
      XOR<ReturnRequestUpdateToOneWithWhereWithoutRefundInput, ReturnRequestUpdateWithoutRefundInput>,
      ReturnRequestUncheckedUpdateWithoutRefundInput
    >;
  };

  export type OrderCreateNestedOneWithoutPaymentMetaInput = {
    create?: XOR<OrderCreateWithoutPaymentMetaInput, OrderUncheckedCreateWithoutPaymentMetaInput>;
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentMetaInput;
    connect?: OrderWhereUniqueInput;
  };

  export type OrderUpdateOneRequiredWithoutPaymentMetaNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentMetaInput, OrderUncheckedCreateWithoutPaymentMetaInput>;
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentMetaInput;
    upsert?: OrderUpsertWithoutPaymentMetaInput;
    connect?: OrderWhereUniqueInput;
    update?: XOR<
      XOR<OrderUpdateToOneWithWhereWithoutPaymentMetaInput, OrderUpdateWithoutPaymentMetaInput>,
      OrderUncheckedUpdateWithoutPaymentMetaInput
    >;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type NestedEnumProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus;
  };

  export type NestedEnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumProductStatusFilter<$PrismaModel>;
    _max?: NestedEnumProductStatusFilter<$PrismaModel>;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, "path">
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, "path">>;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string;
  };

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null;
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null;
  };

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null;
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedDecimalNullableFilter<$PrismaModel>;
    _sum?: NestedDecimalNullableFilter<$PrismaModel>;
    _min?: NestedDecimalNullableFilter<$PrismaModel>;
    _max?: NestedDecimalNullableFilter<$PrismaModel>;
  };

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus;
  };

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>;
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>;
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>;
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>;
  };

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>;
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>;
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>;
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>;
  };

  export type NestedEnumCouponTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponType | EnumCouponTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumCouponTypeFilter<$PrismaModel> | $Enums.CouponType;
  };

  export type NestedEnumCouponTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponType | EnumCouponTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumCouponTypeWithAggregatesFilter<$PrismaModel> | $Enums.CouponType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumCouponTypeFilter<$PrismaModel>;
    _max?: NestedEnumCouponTypeFilter<$PrismaModel>;
  };

  export type NestedEnumReturnStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnStatus | EnumReturnStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumReturnStatusFilter<$PrismaModel> | $Enums.ReturnStatus;
  };

  export type NestedEnumReturnStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnStatus | EnumReturnStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumReturnStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReturnStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumReturnStatusFilter<$PrismaModel>;
    _max?: NestedEnumReturnStatusFilter<$PrismaModel>;
  };

  export type NestedEnumRefundStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumRefundStatusFilter<$PrismaModel> | $Enums.RefundStatus;
  };

  export type NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel> | $Enums.RefundStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRefundStatusFilter<$PrismaModel>;
    _max?: NestedEnumRefundStatusFilter<$PrismaModel>;
  };

  export type UserRoleCreateWithoutUserInput = {
    role: RoleCreateNestedOneWithoutUserRolesInput;
  };

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: number;
    roleId: number;
  };

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput;
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>;
  };

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AddressCreateWithoutUserInput = {
    fullName: string;
    line1: string;
    line2?: string | null;
    city: string;
    province?: string | null;
    postalCode?: string | null;
    country: string;
    phone?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: boolean;
    isDefaultBilling?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ordersShipping?: OrderCreateNestedManyWithoutShippingAddressInput;
    ordersBilling?: OrderCreateNestedManyWithoutBillingAddressInput;
  };

  export type AddressUncheckedCreateWithoutUserInput = {
    id?: number;
    fullName: string;
    line1: string;
    line2?: string | null;
    city: string;
    province?: string | null;
    postalCode?: string | null;
    country: string;
    phone?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: boolean;
    isDefaultBilling?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ordersShipping?: OrderUncheckedCreateNestedManyWithoutShippingAddressInput;
    ordersBilling?: OrderUncheckedCreateNestedManyWithoutBillingAddressInput;
  };

  export type AddressCreateOrConnectWithoutUserInput = {
    where: AddressWhereUniqueInput;
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>;
  };

  export type AddressCreateManyUserInputEnvelope = {
    data: AddressCreateManyUserInput | AddressCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type WishlistCreateWithoutUserInput = {
    createdAt?: Date | string;
    updatedAt?: Date | string;
    items?: WishlistItemCreateNestedManyWithoutWishlistInput;
  };

  export type WishlistUncheckedCreateWithoutUserInput = {
    id?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    items?: WishlistItemUncheckedCreateNestedManyWithoutWishlistInput;
  };

  export type WishlistCreateOrConnectWithoutUserInput = {
    where: WishlistWhereUniqueInput;
    create: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput>;
  };

  export type ReviewCreateWithoutUserInput = {
    rating: number;
    title?: string | null;
    body?: string | null;
    approved?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    product: ProductCreateNestedOneWithoutReviewsInput;
  };

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: number;
    productId: number;
    rating: number;
    title?: string | null;
    body?: string | null;
    approved?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput;
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>;
  };

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type OrderCreateWithoutUserInput = {
    orderNumber: string;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paymentMeta?: PaymentMetaCreateNestedOneWithoutOrderInput;
    items?: OrderItemCreateNestedManyWithoutOrderInput;
    shippingAddress?: AddressCreateNestedOneWithoutOrdersShippingInput;
    billingAddress?: AddressCreateNestedOneWithoutOrdersBillingInput;
    coupon?: CouponCreateNestedOneWithoutOrderInput;
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderInput;
    Refund?: RefundCreateNestedManyWithoutOrderInput;
  };

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: number;
    orderNumber: string;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    shippingAddressId?: number | null;
    billingAddressId?: number | null;
    couponId?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paymentMeta?: PaymentMetaUncheckedCreateNestedOneWithoutOrderInput;
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput;
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderInput;
    Refund?: RefundUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput;
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>;
  };

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AuditLogCreateWithoutActorInput = {
    action: string;
    entity: string;
    entityId?: string | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    ip?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogUncheckedCreateWithoutActorInput = {
    id?: number;
    action: string;
    entity: string;
    entityId?: string | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    ip?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogCreateOrConnectWithoutActorInput = {
    where: AuditLogWhereUniqueInput;
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>;
  };

  export type AuditLogCreateManyActorInputEnvelope = {
    data: AuditLogCreateManyActorInput | AuditLogCreateManyActorInput[];
    skipDuplicates?: boolean;
  };

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput;
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>;
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>;
  };

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput;
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>;
  };

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput;
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>;
  };

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[];
    OR?: UserRoleScalarWhereInput[];
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[];
    id?: IntFilter<"UserRole"> | number;
    userId?: IntFilter<"UserRole"> | number;
    roleId?: IntFilter<"UserRole"> | number;
  };

  export type AddressUpsertWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput;
    update: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>;
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>;
  };

  export type AddressUpdateWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput;
    data: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>;
  };

  export type AddressUpdateManyWithWhereWithoutUserInput = {
    where: AddressScalarWhereInput;
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutUserInput>;
  };

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[];
    OR?: AddressScalarWhereInput[];
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[];
    id?: IntFilter<"Address"> | number;
    userId?: IntNullableFilter<"Address"> | number | null;
    fullName?: StringFilter<"Address"> | string;
    line1?: StringFilter<"Address"> | string;
    line2?: StringNullableFilter<"Address"> | string | null;
    city?: StringFilter<"Address"> | string;
    province?: StringNullableFilter<"Address"> | string | null;
    postalCode?: StringNullableFilter<"Address"> | string | null;
    country?: StringFilter<"Address"> | string;
    phone?: StringNullableFilter<"Address"> | string | null;
    metadata?: JsonNullableFilter<"Address">;
    isDefaultShipping?: BoolFilter<"Address"> | boolean;
    isDefaultBilling?: BoolFilter<"Address"> | boolean;
    createdAt?: DateTimeFilter<"Address"> | Date | string;
    updatedAt?: DateTimeFilter<"Address"> | Date | string;
  };

  export type WishlistUpsertWithoutUserInput = {
    update: XOR<WishlistUpdateWithoutUserInput, WishlistUncheckedUpdateWithoutUserInput>;
    create: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput>;
    where?: WishlistWhereInput;
  };

  export type WishlistUpdateToOneWithWhereWithoutUserInput = {
    where?: WishlistWhereInput;
    data: XOR<WishlistUpdateWithoutUserInput, WishlistUncheckedUpdateWithoutUserInput>;
  };

  export type WishlistUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: WishlistItemUpdateManyWithoutWishlistNestedInput;
  };

  export type WishlistUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: WishlistItemUncheckedUpdateManyWithoutWishlistNestedInput;
  };

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput;
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>;
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>;
  };

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput;
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>;
  };

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput;
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>;
  };

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
    OR?: ReviewScalarWhereInput[];
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
    id?: IntFilter<"Review"> | number;
    userId?: IntNullableFilter<"Review"> | number | null;
    productId?: IntFilter<"Review"> | number;
    rating?: IntFilter<"Review"> | number;
    title?: StringNullableFilter<"Review"> | string | null;
    body?: StringNullableFilter<"Review"> | string | null;
    approved?: BoolFilter<"Review"> | boolean;
    createdAt?: DateTimeFilter<"Review"> | Date | string;
    updatedAt?: DateTimeFilter<"Review"> | Date | string;
  };

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput;
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>;
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>;
  };

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput;
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>;
  };

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput;
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>;
  };

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[];
    OR?: OrderScalarWhereInput[];
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[];
    id?: IntFilter<"Order"> | number;
    orderNumber?: StringFilter<"Order"> | string;
    userId?: IntNullableFilter<"Order"> | number | null;
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus;
    subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string;
    total?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFilter<"Order"> | $Enums.PaymentMethod;
    shippingAddressId?: IntNullableFilter<"Order"> | number | null;
    billingAddressId?: IntNullableFilter<"Order"> | number | null;
    couponId?: IntNullableFilter<"Order"> | number | null;
    createdAt?: DateTimeFilter<"Order"> | Date | string;
    updatedAt?: DateTimeFilter<"Order"> | Date | string;
  };

  export type AuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput;
    update: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>;
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>;
  };

  export type AuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput;
    data: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>;
  };

  export type AuditLogUpdateManyWithWhereWithoutActorInput = {
    where: AuditLogScalarWhereInput;
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutActorInput>;
  };

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    OR?: AuditLogScalarWhereInput[];
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    id?: IntFilter<"AuditLog"> | number;
    actorId?: IntNullableFilter<"AuditLog"> | number | null;
    action?: StringFilter<"AuditLog"> | string;
    entity?: StringFilter<"AuditLog"> | string;
    entityId?: StringNullableFilter<"AuditLog"> | string | null;
    changes?: JsonNullableFilter<"AuditLog">;
    ip?: StringNullableFilter<"AuditLog"> | string | null;
    userAgent?: StringNullableFilter<"AuditLog"> | string | null;
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string;
  };

  export type UserRoleCreateWithoutRoleInput = {
    user: UserCreateNestedOneWithoutUserRolesInput;
  };

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    id?: number;
    userId: number;
  };

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput;
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>;
  };

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[];
    skipDuplicates?: boolean;
  };

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput;
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>;
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>;
  };

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput;
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>;
  };

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput;
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>;
  };

  export type UserCreateWithoutUserRolesInput = {
    email: string;
    username?: string | null;
    password?: string | null;
    displayName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    addresses?: AddressCreateNestedManyWithoutUserInput;
    wishlist?: WishlistCreateNestedOneWithoutUserInput;
    reviews?: ReviewCreateNestedManyWithoutUserInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutActorInput;
  };

  export type UserUncheckedCreateWithoutUserRolesInput = {
    id?: number;
    email: string;
    username?: string | null;
    password?: string | null;
    displayName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput;
    wishlist?: WishlistUncheckedCreateNestedOneWithoutUserInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
  };

  export type UserCreateOrConnectWithoutUserRolesInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>;
  };

  export type RoleCreateWithoutUserRolesInput = {
    name: string;
  };

  export type RoleUncheckedCreateWithoutUserRolesInput = {
    id?: number;
    name: string;
  };

  export type RoleCreateOrConnectWithoutUserRolesInput = {
    where: RoleWhereUniqueInput;
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>;
  };

  export type UserUpsertWithoutUserRolesInput = {
    update: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>;
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>;
  };

  export type UserUpdateWithoutUserRolesInput = {
    email?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    addresses?: AddressUpdateManyWithoutUserNestedInput;
    wishlist?: WishlistUpdateOneWithoutUserNestedInput;
    reviews?: ReviewUpdateManyWithoutUserNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutActorNestedInput;
  };

  export type UserUncheckedUpdateWithoutUserRolesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput;
    wishlist?: WishlistUncheckedUpdateOneWithoutUserNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
  };

  export type RoleUpsertWithoutUserRolesInput = {
    update: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>;
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>;
    where?: RoleWhereInput;
  };

  export type RoleUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RoleWhereInput;
    data: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>;
  };

  export type RoleUpdateWithoutUserRolesInput = {
    name?: StringFieldUpdateOperationsInput | string;
  };

  export type RoleUncheckedUpdateWithoutUserRolesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    name?: StringFieldUpdateOperationsInput | string;
  };

  export type ProductImageCreateWithoutProductInput = {
    url: string;
    alt?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProductImageUncheckedCreateWithoutProductInput = {
    id?: number;
    url: string;
    alt?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProductImageCreateOrConnectWithoutProductInput = {
    where: ProductImageWhereUniqueInput;
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>;
  };

  export type ProductImageCreateManyProductInputEnvelope = {
    data: ProductImageCreateManyProductInput | ProductImageCreateManyProductInput[];
    skipDuplicates?: boolean;
  };

  export type ProductVariantCreateWithoutProductInput = {
    name: string;
    skuPrefix?: string | null;
    price: Decimal | DecimalJsLike | number | string;
    compareAtPrice?: Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inventory?: InventoryCreateNestedManyWithoutVariantInput;
    OrderItem?: OrderItemCreateNestedManyWithoutVariantInput;
  };

  export type ProductVariantUncheckedCreateWithoutProductInput = {
    id?: number;
    name: string;
    skuPrefix?: string | null;
    price: Decimal | DecimalJsLike | number | string;
    compareAtPrice?: Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inventory?: InventoryUncheckedCreateNestedManyWithoutVariantInput;
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutVariantInput;
  };

  export type ProductVariantCreateOrConnectWithoutProductInput = {
    where: ProductVariantWhereUniqueInput;
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>;
  };

  export type ProductVariantCreateManyProductInputEnvelope = {
    data: ProductVariantCreateManyProductInput | ProductVariantCreateManyProductInput[];
    skipDuplicates?: boolean;
  };

  export type ReviewCreateWithoutProductInput = {
    rating: number;
    title?: string | null;
    body?: string | null;
    approved?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user?: UserCreateNestedOneWithoutReviewsInput;
  };

  export type ReviewUncheckedCreateWithoutProductInput = {
    id?: number;
    userId?: number | null;
    rating: number;
    title?: string | null;
    body?: string | null;
    approved?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ReviewCreateOrConnectWithoutProductInput = {
    where: ReviewWhereUniqueInput;
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>;
  };

  export type ReviewCreateManyProductInputEnvelope = {
    data: ReviewCreateManyProductInput | ReviewCreateManyProductInput[];
    skipDuplicates?: boolean;
  };

  export type OrderItemCreateWithoutProductInput = {
    sku?: string | null;
    name: string;
    price: Decimal | DecimalJsLike | number | string;
    quantity: number;
    total: Decimal | DecimalJsLike | number | string;
    returned?: boolean;
    createdAt?: Date | string;
    order: OrderCreateNestedOneWithoutItemsInput;
    variant?: ProductVariantCreateNestedOneWithoutOrderItemInput;
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderItemInput;
  };

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: number;
    orderId: number;
    variantId?: number | null;
    sku?: string | null;
    name: string;
    price: Decimal | DecimalJsLike | number | string;
    quantity: number;
    total: Decimal | DecimalJsLike | number | string;
    returned?: boolean;
    createdAt?: Date | string;
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderItemInput;
  };

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput;
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>;
  };

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[];
    skipDuplicates?: boolean;
  };

  export type WishlistItemCreateWithoutProductInput = {
    variantId?: number | null;
    createdAt?: Date | string;
    wishlist: WishlistCreateNestedOneWithoutItemsInput;
  };

  export type WishlistItemUncheckedCreateWithoutProductInput = {
    id?: number;
    wishlistId: number;
    variantId?: number | null;
    createdAt?: Date | string;
  };

  export type WishlistItemCreateOrConnectWithoutProductInput = {
    where: WishlistItemWhereUniqueInput;
    create: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput>;
  };

  export type WishlistItemCreateManyProductInputEnvelope = {
    data: WishlistItemCreateManyProductInput | WishlistItemCreateManyProductInput[];
    skipDuplicates?: boolean;
  };

  export type ProductImageUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput;
    update: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>;
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>;
  };

  export type ProductImageUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput;
    data: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>;
  };

  export type ProductImageUpdateManyWithWhereWithoutProductInput = {
    where: ProductImageScalarWhereInput;
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyWithoutProductInput>;
  };

  export type ProductImageScalarWhereInput = {
    AND?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[];
    OR?: ProductImageScalarWhereInput[];
    NOT?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[];
    id?: IntFilter<"ProductImage"> | number;
    url?: StringFilter<"ProductImage"> | string;
    alt?: StringNullableFilter<"ProductImage"> | string | null;
    isPrimary?: BoolFilter<"ProductImage"> | boolean;
    productId?: IntFilter<"ProductImage"> | number;
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string;
    updatedAt?: DateTimeFilter<"ProductImage"> | Date | string;
  };

  export type ProductVariantUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput;
    update: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>;
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>;
  };

  export type ProductVariantUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput;
    data: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>;
  };

  export type ProductVariantUpdateManyWithWhereWithoutProductInput = {
    where: ProductVariantScalarWhereInput;
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyWithoutProductInput>;
  };

  export type ProductVariantScalarWhereInput = {
    AND?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[];
    OR?: ProductVariantScalarWhereInput[];
    NOT?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[];
    id?: IntFilter<"ProductVariant"> | number;
    productId?: IntFilter<"ProductVariant"> | number;
    name?: StringFilter<"ProductVariant"> | string;
    skuPrefix?: StringNullableFilter<"ProductVariant"> | string | null;
    price?: DecimalFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string;
    compareAtPrice?: DecimalNullableFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null;
    attributes?: JsonNullableFilter<"ProductVariant">;
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string;
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string;
  };

  export type ReviewUpsertWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput;
    update: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>;
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>;
  };

  export type ReviewUpdateWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput;
    data: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>;
  };

  export type ReviewUpdateManyWithWhereWithoutProductInput = {
    where: ReviewScalarWhereInput;
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutProductInput>;
  };

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput;
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>;
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>;
  };

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput;
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>;
  };

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput;
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>;
  };

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
    OR?: OrderItemScalarWhereInput[];
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
    id?: IntFilter<"OrderItem"> | number;
    orderId?: IntFilter<"OrderItem"> | number;
    productId?: IntNullableFilter<"OrderItem"> | number | null;
    variantId?: IntNullableFilter<"OrderItem"> | number | null;
    sku?: StringNullableFilter<"OrderItem"> | string | null;
    name?: StringFilter<"OrderItem"> | string;
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string;
    quantity?: IntFilter<"OrderItem"> | number;
    total?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string;
    returned?: BoolFilter<"OrderItem"> | boolean;
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string;
  };

  export type WishlistItemUpsertWithWhereUniqueWithoutProductInput = {
    where: WishlistItemWhereUniqueInput;
    update: XOR<WishlistItemUpdateWithoutProductInput, WishlistItemUncheckedUpdateWithoutProductInput>;
    create: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput>;
  };

  export type WishlistItemUpdateWithWhereUniqueWithoutProductInput = {
    where: WishlistItemWhereUniqueInput;
    data: XOR<WishlistItemUpdateWithoutProductInput, WishlistItemUncheckedUpdateWithoutProductInput>;
  };

  export type WishlistItemUpdateManyWithWhereWithoutProductInput = {
    where: WishlistItemScalarWhereInput;
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyWithoutProductInput>;
  };

  export type WishlistItemScalarWhereInput = {
    AND?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[];
    OR?: WishlistItemScalarWhereInput[];
    NOT?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[];
    id?: IntFilter<"WishlistItem"> | number;
    wishlistId?: IntFilter<"WishlistItem"> | number;
    productId?: IntFilter<"WishlistItem"> | number;
    variantId?: IntNullableFilter<"WishlistItem"> | number | null;
    createdAt?: DateTimeFilter<"WishlistItem"> | Date | string;
  };

  export type ProductCreateWithoutImagesInput = {
    title: string;
    slug: string;
    shortDescription?: string | null;
    description?: string | null;
    status?: $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    variants?: ProductVariantCreateNestedManyWithoutProductInput;
    reviews?: ReviewCreateNestedManyWithoutProductInput;
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput;
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput;
  };

  export type ProductUncheckedCreateWithoutImagesInput = {
    id?: number;
    title: string;
    slug: string;
    shortDescription?: string | null;
    description?: string | null;
    status?: $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput;
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput;
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput;
  };

  export type ProductCreateOrConnectWithoutImagesInput = {
    where: ProductWhereUniqueInput;
    create: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>;
  };

  export type ProductUpsertWithoutImagesInput = {
    update: XOR<ProductUpdateWithoutImagesInput, ProductUncheckedUpdateWithoutImagesInput>;
    create: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>;
    where?: ProductWhereInput;
  };

  export type ProductUpdateToOneWithWhereWithoutImagesInput = {
    where?: ProductWhereInput;
    data: XOR<ProductUpdateWithoutImagesInput, ProductUncheckedUpdateWithoutImagesInput>;
  };

  export type ProductUpdateWithoutImagesInput = {
    title?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    variants?: ProductVariantUpdateManyWithoutProductNestedInput;
    reviews?: ReviewUpdateManyWithoutProductNestedInput;
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput;
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput;
  };

  export type ProductUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput;
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput;
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput;
  };

  export type ProductCreateWithoutVariantsInput = {
    title: string;
    slug: string;
    shortDescription?: string | null;
    description?: string | null;
    status?: $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    images?: ProductImageCreateNestedManyWithoutProductInput;
    reviews?: ReviewCreateNestedManyWithoutProductInput;
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput;
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput;
  };

  export type ProductUncheckedCreateWithoutVariantsInput = {
    id?: number;
    title: string;
    slug: string;
    shortDescription?: string | null;
    description?: string | null;
    status?: $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput;
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput;
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput;
  };

  export type ProductCreateOrConnectWithoutVariantsInput = {
    where: ProductWhereUniqueInput;
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>;
  };

  export type InventoryCreateWithoutVariantInput = {
    sku: string;
    quantity?: number;
    reserved?: number;
    location?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type InventoryUncheckedCreateWithoutVariantInput = {
    id?: number;
    sku: string;
    quantity?: number;
    reserved?: number;
    location?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type InventoryCreateOrConnectWithoutVariantInput = {
    where: InventoryWhereUniqueInput;
    create: XOR<InventoryCreateWithoutVariantInput, InventoryUncheckedCreateWithoutVariantInput>;
  };

  export type InventoryCreateManyVariantInputEnvelope = {
    data: InventoryCreateManyVariantInput | InventoryCreateManyVariantInput[];
    skipDuplicates?: boolean;
  };

  export type OrderItemCreateWithoutVariantInput = {
    sku?: string | null;
    name: string;
    price: Decimal | DecimalJsLike | number | string;
    quantity: number;
    total: Decimal | DecimalJsLike | number | string;
    returned?: boolean;
    createdAt?: Date | string;
    order: OrderCreateNestedOneWithoutItemsInput;
    product?: ProductCreateNestedOneWithoutOrderItemInput;
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderItemInput;
  };

  export type OrderItemUncheckedCreateWithoutVariantInput = {
    id?: number;
    orderId: number;
    productId?: number | null;
    sku?: string | null;
    name: string;
    price: Decimal | DecimalJsLike | number | string;
    quantity: number;
    total: Decimal | DecimalJsLike | number | string;
    returned?: boolean;
    createdAt?: Date | string;
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderItemInput;
  };

  export type OrderItemCreateOrConnectWithoutVariantInput = {
    where: OrderItemWhereUniqueInput;
    create: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput>;
  };

  export type OrderItemCreateManyVariantInputEnvelope = {
    data: OrderItemCreateManyVariantInput | OrderItemCreateManyVariantInput[];
    skipDuplicates?: boolean;
  };

  export type ProductUpsertWithoutVariantsInput = {
    update: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>;
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>;
    where?: ProductWhereInput;
  };

  export type ProductUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ProductWhereInput;
    data: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>;
  };

  export type ProductUpdateWithoutVariantsInput = {
    title?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    images?: ProductImageUpdateManyWithoutProductNestedInput;
    reviews?: ReviewUpdateManyWithoutProductNestedInput;
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput;
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput;
  };

  export type ProductUncheckedUpdateWithoutVariantsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput;
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput;
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput;
  };

  export type InventoryUpsertWithWhereUniqueWithoutVariantInput = {
    where: InventoryWhereUniqueInput;
    update: XOR<InventoryUpdateWithoutVariantInput, InventoryUncheckedUpdateWithoutVariantInput>;
    create: XOR<InventoryCreateWithoutVariantInput, InventoryUncheckedCreateWithoutVariantInput>;
  };

  export type InventoryUpdateWithWhereUniqueWithoutVariantInput = {
    where: InventoryWhereUniqueInput;
    data: XOR<InventoryUpdateWithoutVariantInput, InventoryUncheckedUpdateWithoutVariantInput>;
  };

  export type InventoryUpdateManyWithWhereWithoutVariantInput = {
    where: InventoryScalarWhereInput;
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutVariantInput>;
  };

  export type InventoryScalarWhereInput = {
    AND?: InventoryScalarWhereInput | InventoryScalarWhereInput[];
    OR?: InventoryScalarWhereInput[];
    NOT?: InventoryScalarWhereInput | InventoryScalarWhereInput[];
    id?: IntFilter<"Inventory"> | number;
    sku?: StringFilter<"Inventory"> | string;
    variantId?: IntFilter<"Inventory"> | number;
    quantity?: IntFilter<"Inventory"> | number;
    reserved?: IntFilter<"Inventory"> | number;
    location?: StringNullableFilter<"Inventory"> | string | null;
    metadata?: JsonNullableFilter<"Inventory">;
    createdAt?: DateTimeFilter<"Inventory"> | Date | string;
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string;
  };

  export type OrderItemUpsertWithWhereUniqueWithoutVariantInput = {
    where: OrderItemWhereUniqueInput;
    update: XOR<OrderItemUpdateWithoutVariantInput, OrderItemUncheckedUpdateWithoutVariantInput>;
    create: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput>;
  };

  export type OrderItemUpdateWithWhereUniqueWithoutVariantInput = {
    where: OrderItemWhereUniqueInput;
    data: XOR<OrderItemUpdateWithoutVariantInput, OrderItemUncheckedUpdateWithoutVariantInput>;
  };

  export type OrderItemUpdateManyWithWhereWithoutVariantInput = {
    where: OrderItemScalarWhereInput;
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutVariantInput>;
  };

  export type ProductVariantCreateWithoutInventoryInput = {
    name: string;
    skuPrefix?: string | null;
    price: Decimal | DecimalJsLike | number | string;
    compareAtPrice?: Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    product: ProductCreateNestedOneWithoutVariantsInput;
    OrderItem?: OrderItemCreateNestedManyWithoutVariantInput;
  };

  export type ProductVariantUncheckedCreateWithoutInventoryInput = {
    id?: number;
    productId: number;
    name: string;
    skuPrefix?: string | null;
    price: Decimal | DecimalJsLike | number | string;
    compareAtPrice?: Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutVariantInput;
  };

  export type ProductVariantCreateOrConnectWithoutInventoryInput = {
    where: ProductVariantWhereUniqueInput;
    create: XOR<ProductVariantCreateWithoutInventoryInput, ProductVariantUncheckedCreateWithoutInventoryInput>;
  };

  export type ProductVariantUpsertWithoutInventoryInput = {
    update: XOR<ProductVariantUpdateWithoutInventoryInput, ProductVariantUncheckedUpdateWithoutInventoryInput>;
    create: XOR<ProductVariantCreateWithoutInventoryInput, ProductVariantUncheckedCreateWithoutInventoryInput>;
    where?: ProductVariantWhereInput;
  };

  export type ProductVariantUpdateToOneWithWhereWithoutInventoryInput = {
    where?: ProductVariantWhereInput;
    data: XOR<ProductVariantUpdateWithoutInventoryInput, ProductVariantUncheckedUpdateWithoutInventoryInput>;
  };

  export type ProductVariantUpdateWithoutInventoryInput = {
    name?: StringFieldUpdateOperationsInput | string;
    skuPrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    compareAtPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput;
    OrderItem?: OrderItemUpdateManyWithoutVariantNestedInput;
  };

  export type ProductVariantUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number;
    productId?: IntFieldUpdateOperationsInput | number;
    name?: StringFieldUpdateOperationsInput | string;
    skuPrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    compareAtPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    OrderItem?: OrderItemUncheckedUpdateManyWithoutVariantNestedInput;
  };

  export type UserCreateWithoutOrdersInput = {
    email: string;
    username?: string | null;
    password?: string | null;
    displayName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    userRoles?: UserRoleCreateNestedManyWithoutUserInput;
    addresses?: AddressCreateNestedManyWithoutUserInput;
    wishlist?: WishlistCreateNestedOneWithoutUserInput;
    reviews?: ReviewCreateNestedManyWithoutUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutActorInput;
  };

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: number;
    email: string;
    username?: string | null;
    password?: string | null;
    displayName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput;
    wishlist?: WishlistUncheckedCreateNestedOneWithoutUserInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
  };

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>;
  };

  export type PaymentMetaCreateWithoutOrderInput = {
    provider: string;
    transactionId?: string | null;
    status: string;
    amount: Decimal | DecimalJsLike | number | string;
    raw?: NullableJsonNullValueInput | InputJsonValue;
    capturedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentMetaUncheckedCreateWithoutOrderInput = {
    id?: number;
    provider: string;
    transactionId?: string | null;
    status: string;
    amount: Decimal | DecimalJsLike | number | string;
    raw?: NullableJsonNullValueInput | InputJsonValue;
    capturedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentMetaCreateOrConnectWithoutOrderInput = {
    where: PaymentMetaWhereUniqueInput;
    create: XOR<PaymentMetaCreateWithoutOrderInput, PaymentMetaUncheckedCreateWithoutOrderInput>;
  };

  export type OrderItemCreateWithoutOrderInput = {
    sku?: string | null;
    name: string;
    price: Decimal | DecimalJsLike | number | string;
    quantity: number;
    total: Decimal | DecimalJsLike | number | string;
    returned?: boolean;
    createdAt?: Date | string;
    product?: ProductCreateNestedOneWithoutOrderItemInput;
    variant?: ProductVariantCreateNestedOneWithoutOrderItemInput;
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderItemInput;
  };

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number;
    productId?: number | null;
    variantId?: number | null;
    sku?: string | null;
    name: string;
    price: Decimal | DecimalJsLike | number | string;
    quantity: number;
    total: Decimal | DecimalJsLike | number | string;
    returned?: boolean;
    createdAt?: Date | string;
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderItemInput;
  };

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput;
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>;
  };

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[];
    skipDuplicates?: boolean;
  };

  export type AddressCreateWithoutOrdersShippingInput = {
    fullName: string;
    line1: string;
    line2?: string | null;
    city: string;
    province?: string | null;
    postalCode?: string | null;
    country: string;
    phone?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: boolean;
    isDefaultBilling?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user?: UserCreateNestedOneWithoutAddressesInput;
    ordersBilling?: OrderCreateNestedManyWithoutBillingAddressInput;
  };

  export type AddressUncheckedCreateWithoutOrdersShippingInput = {
    id?: number;
    userId?: number | null;
    fullName: string;
    line1: string;
    line2?: string | null;
    city: string;
    province?: string | null;
    postalCode?: string | null;
    country: string;
    phone?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: boolean;
    isDefaultBilling?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ordersBilling?: OrderUncheckedCreateNestedManyWithoutBillingAddressInput;
  };

  export type AddressCreateOrConnectWithoutOrdersShippingInput = {
    where: AddressWhereUniqueInput;
    create: XOR<AddressCreateWithoutOrdersShippingInput, AddressUncheckedCreateWithoutOrdersShippingInput>;
  };

  export type AddressCreateWithoutOrdersBillingInput = {
    fullName: string;
    line1: string;
    line2?: string | null;
    city: string;
    province?: string | null;
    postalCode?: string | null;
    country: string;
    phone?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: boolean;
    isDefaultBilling?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user?: UserCreateNestedOneWithoutAddressesInput;
    ordersShipping?: OrderCreateNestedManyWithoutShippingAddressInput;
  };

  export type AddressUncheckedCreateWithoutOrdersBillingInput = {
    id?: number;
    userId?: number | null;
    fullName: string;
    line1: string;
    line2?: string | null;
    city: string;
    province?: string | null;
    postalCode?: string | null;
    country: string;
    phone?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: boolean;
    isDefaultBilling?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ordersShipping?: OrderUncheckedCreateNestedManyWithoutShippingAddressInput;
  };

  export type AddressCreateOrConnectWithoutOrdersBillingInput = {
    where: AddressWhereUniqueInput;
    create: XOR<AddressCreateWithoutOrdersBillingInput, AddressUncheckedCreateWithoutOrdersBillingInput>;
  };

  export type CouponCreateWithoutOrderInput = {
    code: string;
    type: $Enums.CouponType;
    amount?: Decimal | DecimalJsLike | number | string | null;
    percent?: number | null;
    description?: string | null;
    startsAt?: Date | string | null;
    expiresAt?: Date | string | null;
    usageLimit?: number | null;
    usagePerUser?: number | null;
    timesUsed?: number;
    active?: boolean;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CouponUncheckedCreateWithoutOrderInput = {
    id?: number;
    code: string;
    type: $Enums.CouponType;
    amount?: Decimal | DecimalJsLike | number | string | null;
    percent?: number | null;
    description?: string | null;
    startsAt?: Date | string | null;
    expiresAt?: Date | string | null;
    usageLimit?: number | null;
    usagePerUser?: number | null;
    timesUsed?: number;
    active?: boolean;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CouponCreateOrConnectWithoutOrderInput = {
    where: CouponWhereUniqueInput;
    create: XOR<CouponCreateWithoutOrderInput, CouponUncheckedCreateWithoutOrderInput>;
  };

  export type ReturnRequestCreateWithoutOrderInput = {
    reason: string;
    status?: $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: Date | string;
    processedAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    orderItem: OrderItemCreateNestedOneWithoutReturnRequestInput;
    refund?: RefundCreateNestedOneWithoutReturnRequestInput;
  };

  export type ReturnRequestUncheckedCreateWithoutOrderInput = {
    id?: number;
    orderItemId: number;
    reason: string;
    status?: $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: Date | string;
    processedAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    refund?: RefundUncheckedCreateNestedOneWithoutReturnRequestInput;
  };

  export type ReturnRequestCreateOrConnectWithoutOrderInput = {
    where: ReturnRequestWhereUniqueInput;
    create: XOR<ReturnRequestCreateWithoutOrderInput, ReturnRequestUncheckedCreateWithoutOrderInput>;
  };

  export type ReturnRequestCreateManyOrderInputEnvelope = {
    data: ReturnRequestCreateManyOrderInput | ReturnRequestCreateManyOrderInput[];
    skipDuplicates?: boolean;
  };

  export type RefundCreateWithoutOrderInput = {
    amount: Decimal | DecimalJsLike | number | string;
    method: string;
    status?: $Enums.RefundStatus;
    providerRef?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    processedAt?: Date | string | null;
    returnRequest?: ReturnRequestCreateNestedOneWithoutRefundInput;
  };

  export type RefundUncheckedCreateWithoutOrderInput = {
    id?: number;
    returnRequestId?: number | null;
    amount: Decimal | DecimalJsLike | number | string;
    method: string;
    status?: $Enums.RefundStatus;
    providerRef?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    processedAt?: Date | string | null;
  };

  export type RefundCreateOrConnectWithoutOrderInput = {
    where: RefundWhereUniqueInput;
    create: XOR<RefundCreateWithoutOrderInput, RefundUncheckedCreateWithoutOrderInput>;
  };

  export type RefundCreateManyOrderInputEnvelope = {
    data: RefundCreateManyOrderInput | RefundCreateManyOrderInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>;
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>;
  };

  export type UserUpdateWithoutOrdersInput = {
    email?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput;
    addresses?: AddressUpdateManyWithoutUserNestedInput;
    wishlist?: WishlistUpdateOneWithoutUserNestedInput;
    reviews?: ReviewUpdateManyWithoutUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutActorNestedInput;
  };

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput;
    wishlist?: WishlistUncheckedUpdateOneWithoutUserNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
  };

  export type PaymentMetaUpsertWithoutOrderInput = {
    update: XOR<PaymentMetaUpdateWithoutOrderInput, PaymentMetaUncheckedUpdateWithoutOrderInput>;
    create: XOR<PaymentMetaCreateWithoutOrderInput, PaymentMetaUncheckedCreateWithoutOrderInput>;
    where?: PaymentMetaWhereInput;
  };

  export type PaymentMetaUpdateToOneWithWhereWithoutOrderInput = {
    where?: PaymentMetaWhereInput;
    data: XOR<PaymentMetaUpdateWithoutOrderInput, PaymentMetaUncheckedUpdateWithoutOrderInput>;
  };

  export type PaymentMetaUpdateWithoutOrderInput = {
    provider?: StringFieldUpdateOperationsInput | string;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    raw?: NullableJsonNullValueInput | InputJsonValue;
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentMetaUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number;
    provider?: StringFieldUpdateOperationsInput | string;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    raw?: NullableJsonNullValueInput | InputJsonValue;
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput;
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>;
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>;
  };

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput;
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>;
  };

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput;
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>;
  };

  export type AddressUpsertWithoutOrdersShippingInput = {
    update: XOR<AddressUpdateWithoutOrdersShippingInput, AddressUncheckedUpdateWithoutOrdersShippingInput>;
    create: XOR<AddressCreateWithoutOrdersShippingInput, AddressUncheckedCreateWithoutOrdersShippingInput>;
    where?: AddressWhereInput;
  };

  export type AddressUpdateToOneWithWhereWithoutOrdersShippingInput = {
    where?: AddressWhereInput;
    data: XOR<AddressUpdateWithoutOrdersShippingInput, AddressUncheckedUpdateWithoutOrdersShippingInput>;
  };

  export type AddressUpdateWithoutOrdersShippingInput = {
    fullName?: StringFieldUpdateOperationsInput | string;
    line1?: StringFieldUpdateOperationsInput | string;
    line2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    province?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: BoolFieldUpdateOperationsInput | boolean;
    isDefaultBilling?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutAddressesNestedInput;
    ordersBilling?: OrderUpdateManyWithoutBillingAddressNestedInput;
  };

  export type AddressUncheckedUpdateWithoutOrdersShippingInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    fullName?: StringFieldUpdateOperationsInput | string;
    line1?: StringFieldUpdateOperationsInput | string;
    line2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    province?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: BoolFieldUpdateOperationsInput | boolean;
    isDefaultBilling?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ordersBilling?: OrderUncheckedUpdateManyWithoutBillingAddressNestedInput;
  };

  export type AddressUpsertWithoutOrdersBillingInput = {
    update: XOR<AddressUpdateWithoutOrdersBillingInput, AddressUncheckedUpdateWithoutOrdersBillingInput>;
    create: XOR<AddressCreateWithoutOrdersBillingInput, AddressUncheckedCreateWithoutOrdersBillingInput>;
    where?: AddressWhereInput;
  };

  export type AddressUpdateToOneWithWhereWithoutOrdersBillingInput = {
    where?: AddressWhereInput;
    data: XOR<AddressUpdateWithoutOrdersBillingInput, AddressUncheckedUpdateWithoutOrdersBillingInput>;
  };

  export type AddressUpdateWithoutOrdersBillingInput = {
    fullName?: StringFieldUpdateOperationsInput | string;
    line1?: StringFieldUpdateOperationsInput | string;
    line2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    province?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: BoolFieldUpdateOperationsInput | boolean;
    isDefaultBilling?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutAddressesNestedInput;
    ordersShipping?: OrderUpdateManyWithoutShippingAddressNestedInput;
  };

  export type AddressUncheckedUpdateWithoutOrdersBillingInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    fullName?: StringFieldUpdateOperationsInput | string;
    line1?: StringFieldUpdateOperationsInput | string;
    line2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    province?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: BoolFieldUpdateOperationsInput | boolean;
    isDefaultBilling?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ordersShipping?: OrderUncheckedUpdateManyWithoutShippingAddressNestedInput;
  };

  export type CouponUpsertWithoutOrderInput = {
    update: XOR<CouponUpdateWithoutOrderInput, CouponUncheckedUpdateWithoutOrderInput>;
    create: XOR<CouponCreateWithoutOrderInput, CouponUncheckedCreateWithoutOrderInput>;
    where?: CouponWhereInput;
  };

  export type CouponUpdateToOneWithWhereWithoutOrderInput = {
    where?: CouponWhereInput;
    data: XOR<CouponUpdateWithoutOrderInput, CouponUncheckedUpdateWithoutOrderInput>;
  };

  export type CouponUpdateWithoutOrderInput = {
    code?: StringFieldUpdateOperationsInput | string;
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType;
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    percent?: NullableIntFieldUpdateOperationsInput | number | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null;
    usagePerUser?: NullableIntFieldUpdateOperationsInput | number | null;
    timesUsed?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CouponUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number;
    code?: StringFieldUpdateOperationsInput | string;
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType;
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    percent?: NullableIntFieldUpdateOperationsInput | number | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null;
    usagePerUser?: NullableIntFieldUpdateOperationsInput | number | null;
    timesUsed?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReturnRequestUpsertWithWhereUniqueWithoutOrderInput = {
    where: ReturnRequestWhereUniqueInput;
    update: XOR<ReturnRequestUpdateWithoutOrderInput, ReturnRequestUncheckedUpdateWithoutOrderInput>;
    create: XOR<ReturnRequestCreateWithoutOrderInput, ReturnRequestUncheckedCreateWithoutOrderInput>;
  };

  export type ReturnRequestUpdateWithWhereUniqueWithoutOrderInput = {
    where: ReturnRequestWhereUniqueInput;
    data: XOR<ReturnRequestUpdateWithoutOrderInput, ReturnRequestUncheckedUpdateWithoutOrderInput>;
  };

  export type ReturnRequestUpdateManyWithWhereWithoutOrderInput = {
    where: ReturnRequestScalarWhereInput;
    data: XOR<ReturnRequestUpdateManyMutationInput, ReturnRequestUncheckedUpdateManyWithoutOrderInput>;
  };

  export type ReturnRequestScalarWhereInput = {
    AND?: ReturnRequestScalarWhereInput | ReturnRequestScalarWhereInput[];
    OR?: ReturnRequestScalarWhereInput[];
    NOT?: ReturnRequestScalarWhereInput | ReturnRequestScalarWhereInput[];
    id?: IntFilter<"ReturnRequest"> | number;
    orderId?: IntFilter<"ReturnRequest"> | number;
    orderItemId?: IntFilter<"ReturnRequest"> | number;
    reason?: StringFilter<"ReturnRequest"> | string;
    status?: EnumReturnStatusFilter<"ReturnRequest"> | $Enums.ReturnStatus;
    evidence?: JsonNullableFilter<"ReturnRequest">;
    requestedAt?: DateTimeFilter<"ReturnRequest"> | Date | string;
    processedAt?: DateTimeNullableFilter<"ReturnRequest"> | Date | string | null;
    metadata?: JsonNullableFilter<"ReturnRequest">;
  };

  export type RefundUpsertWithWhereUniqueWithoutOrderInput = {
    where: RefundWhereUniqueInput;
    update: XOR<RefundUpdateWithoutOrderInput, RefundUncheckedUpdateWithoutOrderInput>;
    create: XOR<RefundCreateWithoutOrderInput, RefundUncheckedCreateWithoutOrderInput>;
  };

  export type RefundUpdateWithWhereUniqueWithoutOrderInput = {
    where: RefundWhereUniqueInput;
    data: XOR<RefundUpdateWithoutOrderInput, RefundUncheckedUpdateWithoutOrderInput>;
  };

  export type RefundUpdateManyWithWhereWithoutOrderInput = {
    where: RefundScalarWhereInput;
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyWithoutOrderInput>;
  };

  export type RefundScalarWhereInput = {
    AND?: RefundScalarWhereInput | RefundScalarWhereInput[];
    OR?: RefundScalarWhereInput[];
    NOT?: RefundScalarWhereInput | RefundScalarWhereInput[];
    id?: IntFilter<"Refund"> | number;
    orderId?: IntFilter<"Refund"> | number;
    returnRequestId?: IntNullableFilter<"Refund"> | number | null;
    amount?: DecimalFilter<"Refund"> | Decimal | DecimalJsLike | number | string;
    method?: StringFilter<"Refund"> | string;
    status?: EnumRefundStatusFilter<"Refund"> | $Enums.RefundStatus;
    providerRef?: StringNullableFilter<"Refund"> | string | null;
    metadata?: JsonNullableFilter<"Refund">;
    createdAt?: DateTimeFilter<"Refund"> | Date | string;
    processedAt?: DateTimeNullableFilter<"Refund"> | Date | string | null;
  };

  export type OrderCreateWithoutItemsInput = {
    orderNumber: string;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user?: UserCreateNestedOneWithoutOrdersInput;
    paymentMeta?: PaymentMetaCreateNestedOneWithoutOrderInput;
    shippingAddress?: AddressCreateNestedOneWithoutOrdersShippingInput;
    billingAddress?: AddressCreateNestedOneWithoutOrdersBillingInput;
    coupon?: CouponCreateNestedOneWithoutOrderInput;
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderInput;
    Refund?: RefundCreateNestedManyWithoutOrderInput;
  };

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: number;
    orderNumber: string;
    userId?: number | null;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    shippingAddressId?: number | null;
    billingAddressId?: number | null;
    couponId?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paymentMeta?: PaymentMetaUncheckedCreateNestedOneWithoutOrderInput;
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderInput;
    Refund?: RefundUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput;
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>;
  };

  export type ProductCreateWithoutOrderItemInput = {
    title: string;
    slug: string;
    shortDescription?: string | null;
    description?: string | null;
    status?: $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    images?: ProductImageCreateNestedManyWithoutProductInput;
    variants?: ProductVariantCreateNestedManyWithoutProductInput;
    reviews?: ReviewCreateNestedManyWithoutProductInput;
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput;
  };

  export type ProductUncheckedCreateWithoutOrderItemInput = {
    id?: number;
    title: string;
    slug: string;
    shortDescription?: string | null;
    description?: string | null;
    status?: $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput;
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput;
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput;
  };

  export type ProductCreateOrConnectWithoutOrderItemInput = {
    where: ProductWhereUniqueInput;
    create: XOR<ProductCreateWithoutOrderItemInput, ProductUncheckedCreateWithoutOrderItemInput>;
  };

  export type ProductVariantCreateWithoutOrderItemInput = {
    name: string;
    skuPrefix?: string | null;
    price: Decimal | DecimalJsLike | number | string;
    compareAtPrice?: Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    product: ProductCreateNestedOneWithoutVariantsInput;
    inventory?: InventoryCreateNestedManyWithoutVariantInput;
  };

  export type ProductVariantUncheckedCreateWithoutOrderItemInput = {
    id?: number;
    productId: number;
    name: string;
    skuPrefix?: string | null;
    price: Decimal | DecimalJsLike | number | string;
    compareAtPrice?: Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inventory?: InventoryUncheckedCreateNestedManyWithoutVariantInput;
  };

  export type ProductVariantCreateOrConnectWithoutOrderItemInput = {
    where: ProductVariantWhereUniqueInput;
    create: XOR<ProductVariantCreateWithoutOrderItemInput, ProductVariantUncheckedCreateWithoutOrderItemInput>;
  };

  export type ReturnRequestCreateWithoutOrderItemInput = {
    reason: string;
    status?: $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: Date | string;
    processedAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    order: OrderCreateNestedOneWithoutReturnRequestInput;
    refund?: RefundCreateNestedOneWithoutReturnRequestInput;
  };

  export type ReturnRequestUncheckedCreateWithoutOrderItemInput = {
    id?: number;
    orderId: number;
    reason: string;
    status?: $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: Date | string;
    processedAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    refund?: RefundUncheckedCreateNestedOneWithoutReturnRequestInput;
  };

  export type ReturnRequestCreateOrConnectWithoutOrderItemInput = {
    where: ReturnRequestWhereUniqueInput;
    create: XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput>;
  };

  export type ReturnRequestCreateManyOrderItemInputEnvelope = {
    data: ReturnRequestCreateManyOrderItemInput | ReturnRequestCreateManyOrderItemInput[];
    skipDuplicates?: boolean;
  };

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>;
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>;
    where?: OrderWhereInput;
  };

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput;
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>;
  };

  export type OrderUpdateWithoutItemsInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutOrdersNestedInput;
    paymentMeta?: PaymentMetaUpdateOneWithoutOrderNestedInput;
    shippingAddress?: AddressUpdateOneWithoutOrdersShippingNestedInput;
    billingAddress?: AddressUpdateOneWithoutOrdersBillingNestedInput;
    coupon?: CouponUpdateOneWithoutOrderNestedInput;
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderNestedInput;
    Refund?: RefundUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    shippingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    billingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    couponId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentMeta?: PaymentMetaUncheckedUpdateOneWithoutOrderNestedInput;
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderNestedInput;
    Refund?: RefundUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type ProductUpsertWithoutOrderItemInput = {
    update: XOR<ProductUpdateWithoutOrderItemInput, ProductUncheckedUpdateWithoutOrderItemInput>;
    create: XOR<ProductCreateWithoutOrderItemInput, ProductUncheckedCreateWithoutOrderItemInput>;
    where?: ProductWhereInput;
  };

  export type ProductUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: ProductWhereInput;
    data: XOR<ProductUpdateWithoutOrderItemInput, ProductUncheckedUpdateWithoutOrderItemInput>;
  };

  export type ProductUpdateWithoutOrderItemInput = {
    title?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    images?: ProductImageUpdateManyWithoutProductNestedInput;
    variants?: ProductVariantUpdateManyWithoutProductNestedInput;
    reviews?: ReviewUpdateManyWithoutProductNestedInput;
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput;
  };

  export type ProductUncheckedUpdateWithoutOrderItemInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput;
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput;
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput;
  };

  export type ProductVariantUpsertWithoutOrderItemInput = {
    update: XOR<ProductVariantUpdateWithoutOrderItemInput, ProductVariantUncheckedUpdateWithoutOrderItemInput>;
    create: XOR<ProductVariantCreateWithoutOrderItemInput, ProductVariantUncheckedCreateWithoutOrderItemInput>;
    where?: ProductVariantWhereInput;
  };

  export type ProductVariantUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: ProductVariantWhereInput;
    data: XOR<ProductVariantUpdateWithoutOrderItemInput, ProductVariantUncheckedUpdateWithoutOrderItemInput>;
  };

  export type ProductVariantUpdateWithoutOrderItemInput = {
    name?: StringFieldUpdateOperationsInput | string;
    skuPrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    compareAtPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput;
    inventory?: InventoryUpdateManyWithoutVariantNestedInput;
  };

  export type ProductVariantUncheckedUpdateWithoutOrderItemInput = {
    id?: IntFieldUpdateOperationsInput | number;
    productId?: IntFieldUpdateOperationsInput | number;
    name?: StringFieldUpdateOperationsInput | string;
    skuPrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    compareAtPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inventory?: InventoryUncheckedUpdateManyWithoutVariantNestedInput;
  };

  export type ReturnRequestUpsertWithWhereUniqueWithoutOrderItemInput = {
    where: ReturnRequestWhereUniqueInput;
    update: XOR<ReturnRequestUpdateWithoutOrderItemInput, ReturnRequestUncheckedUpdateWithoutOrderItemInput>;
    create: XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput>;
  };

  export type ReturnRequestUpdateWithWhereUniqueWithoutOrderItemInput = {
    where: ReturnRequestWhereUniqueInput;
    data: XOR<ReturnRequestUpdateWithoutOrderItemInput, ReturnRequestUncheckedUpdateWithoutOrderItemInput>;
  };

  export type ReturnRequestUpdateManyWithWhereWithoutOrderItemInput = {
    where: ReturnRequestScalarWhereInput;
    data: XOR<ReturnRequestUpdateManyMutationInput, ReturnRequestUncheckedUpdateManyWithoutOrderItemInput>;
  };

  export type OrderCreateWithoutCouponInput = {
    orderNumber: string;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user?: UserCreateNestedOneWithoutOrdersInput;
    paymentMeta?: PaymentMetaCreateNestedOneWithoutOrderInput;
    items?: OrderItemCreateNestedManyWithoutOrderInput;
    shippingAddress?: AddressCreateNestedOneWithoutOrdersShippingInput;
    billingAddress?: AddressCreateNestedOneWithoutOrdersBillingInput;
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderInput;
    Refund?: RefundCreateNestedManyWithoutOrderInput;
  };

  export type OrderUncheckedCreateWithoutCouponInput = {
    id?: number;
    orderNumber: string;
    userId?: number | null;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    shippingAddressId?: number | null;
    billingAddressId?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paymentMeta?: PaymentMetaUncheckedCreateNestedOneWithoutOrderInput;
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput;
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderInput;
    Refund?: RefundUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutCouponInput = {
    where: OrderWhereUniqueInput;
    create: XOR<OrderCreateWithoutCouponInput, OrderUncheckedCreateWithoutCouponInput>;
  };

  export type OrderCreateManyCouponInputEnvelope = {
    data: OrderCreateManyCouponInput | OrderCreateManyCouponInput[];
    skipDuplicates?: boolean;
  };

  export type OrderUpsertWithWhereUniqueWithoutCouponInput = {
    where: OrderWhereUniqueInput;
    update: XOR<OrderUpdateWithoutCouponInput, OrderUncheckedUpdateWithoutCouponInput>;
    create: XOR<OrderCreateWithoutCouponInput, OrderUncheckedCreateWithoutCouponInput>;
  };

  export type OrderUpdateWithWhereUniqueWithoutCouponInput = {
    where: OrderWhereUniqueInput;
    data: XOR<OrderUpdateWithoutCouponInput, OrderUncheckedUpdateWithoutCouponInput>;
  };

  export type OrderUpdateManyWithWhereWithoutCouponInput = {
    where: OrderScalarWhereInput;
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCouponInput>;
  };

  export type UserCreateWithoutReviewsInput = {
    email: string;
    username?: string | null;
    password?: string | null;
    displayName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    userRoles?: UserRoleCreateNestedManyWithoutUserInput;
    addresses?: AddressCreateNestedManyWithoutUserInput;
    wishlist?: WishlistCreateNestedOneWithoutUserInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutActorInput;
  };

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: number;
    email: string;
    username?: string | null;
    password?: string | null;
    displayName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput;
    wishlist?: WishlistUncheckedCreateNestedOneWithoutUserInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
  };

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>;
  };

  export type ProductCreateWithoutReviewsInput = {
    title: string;
    slug: string;
    shortDescription?: string | null;
    description?: string | null;
    status?: $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    images?: ProductImageCreateNestedManyWithoutProductInput;
    variants?: ProductVariantCreateNestedManyWithoutProductInput;
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput;
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput;
  };

  export type ProductUncheckedCreateWithoutReviewsInput = {
    id?: number;
    title: string;
    slug: string;
    shortDescription?: string | null;
    description?: string | null;
    status?: $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput;
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput;
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput;
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput;
  };

  export type ProductCreateOrConnectWithoutReviewsInput = {
    where: ProductWhereUniqueInput;
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>;
  };

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>;
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>;
  };

  export type UserUpdateWithoutReviewsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput;
    addresses?: AddressUpdateManyWithoutUserNestedInput;
    wishlist?: WishlistUpdateOneWithoutUserNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutActorNestedInput;
  };

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput;
    wishlist?: WishlistUncheckedUpdateOneWithoutUserNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
  };

  export type ProductUpsertWithoutReviewsInput = {
    update: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>;
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>;
    where?: ProductWhereInput;
  };

  export type ProductUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ProductWhereInput;
    data: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>;
  };

  export type ProductUpdateWithoutReviewsInput = {
    title?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    images?: ProductImageUpdateManyWithoutProductNestedInput;
    variants?: ProductVariantUpdateManyWithoutProductNestedInput;
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput;
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput;
  };

  export type ProductUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput;
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput;
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput;
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput;
  };

  export type UserCreateWithoutWishlistInput = {
    email: string;
    username?: string | null;
    password?: string | null;
    displayName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    userRoles?: UserRoleCreateNestedManyWithoutUserInput;
    addresses?: AddressCreateNestedManyWithoutUserInput;
    reviews?: ReviewCreateNestedManyWithoutUserInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutActorInput;
  };

  export type UserUncheckedCreateWithoutWishlistInput = {
    id?: number;
    email: string;
    username?: string | null;
    password?: string | null;
    displayName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
  };

  export type UserCreateOrConnectWithoutWishlistInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>;
  };

  export type WishlistItemCreateWithoutWishlistInput = {
    variantId?: number | null;
    createdAt?: Date | string;
    product: ProductCreateNestedOneWithoutWishlistItemInput;
  };

  export type WishlistItemUncheckedCreateWithoutWishlistInput = {
    id?: number;
    productId: number;
    variantId?: number | null;
    createdAt?: Date | string;
  };

  export type WishlistItemCreateOrConnectWithoutWishlistInput = {
    where: WishlistItemWhereUniqueInput;
    create: XOR<WishlistItemCreateWithoutWishlistInput, WishlistItemUncheckedCreateWithoutWishlistInput>;
  };

  export type WishlistItemCreateManyWishlistInputEnvelope = {
    data: WishlistItemCreateManyWishlistInput | WishlistItemCreateManyWishlistInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutWishlistInput = {
    update: XOR<UserUpdateWithoutWishlistInput, UserUncheckedUpdateWithoutWishlistInput>;
    create: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutWishlistInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutWishlistInput, UserUncheckedUpdateWithoutWishlistInput>;
  };

  export type UserUpdateWithoutWishlistInput = {
    email?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput;
    addresses?: AddressUpdateManyWithoutUserNestedInput;
    reviews?: ReviewUpdateManyWithoutUserNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutActorNestedInput;
  };

  export type UserUncheckedUpdateWithoutWishlistInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
  };

  export type WishlistItemUpsertWithWhereUniqueWithoutWishlistInput = {
    where: WishlistItemWhereUniqueInput;
    update: XOR<WishlistItemUpdateWithoutWishlistInput, WishlistItemUncheckedUpdateWithoutWishlistInput>;
    create: XOR<WishlistItemCreateWithoutWishlistInput, WishlistItemUncheckedCreateWithoutWishlistInput>;
  };

  export type WishlistItemUpdateWithWhereUniqueWithoutWishlistInput = {
    where: WishlistItemWhereUniqueInput;
    data: XOR<WishlistItemUpdateWithoutWishlistInput, WishlistItemUncheckedUpdateWithoutWishlistInput>;
  };

  export type WishlistItemUpdateManyWithWhereWithoutWishlistInput = {
    where: WishlistItemScalarWhereInput;
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyWithoutWishlistInput>;
  };

  export type WishlistCreateWithoutItemsInput = {
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutWishlistInput;
  };

  export type WishlistUncheckedCreateWithoutItemsInput = {
    id?: number;
    userId: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type WishlistCreateOrConnectWithoutItemsInput = {
    where: WishlistWhereUniqueInput;
    create: XOR<WishlistCreateWithoutItemsInput, WishlistUncheckedCreateWithoutItemsInput>;
  };

  export type ProductCreateWithoutWishlistItemInput = {
    title: string;
    slug: string;
    shortDescription?: string | null;
    description?: string | null;
    status?: $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    images?: ProductImageCreateNestedManyWithoutProductInput;
    variants?: ProductVariantCreateNestedManyWithoutProductInput;
    reviews?: ReviewCreateNestedManyWithoutProductInput;
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput;
  };

  export type ProductUncheckedCreateWithoutWishlistItemInput = {
    id?: number;
    title: string;
    slug: string;
    shortDescription?: string | null;
    description?: string | null;
    status?: $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput;
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput;
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput;
  };

  export type ProductCreateOrConnectWithoutWishlistItemInput = {
    where: ProductWhereUniqueInput;
    create: XOR<ProductCreateWithoutWishlistItemInput, ProductUncheckedCreateWithoutWishlistItemInput>;
  };

  export type WishlistUpsertWithoutItemsInput = {
    update: XOR<WishlistUpdateWithoutItemsInput, WishlistUncheckedUpdateWithoutItemsInput>;
    create: XOR<WishlistCreateWithoutItemsInput, WishlistUncheckedCreateWithoutItemsInput>;
    where?: WishlistWhereInput;
  };

  export type WishlistUpdateToOneWithWhereWithoutItemsInput = {
    where?: WishlistWhereInput;
    data: XOR<WishlistUpdateWithoutItemsInput, WishlistUncheckedUpdateWithoutItemsInput>;
  };

  export type WishlistUpdateWithoutItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutWishlistNestedInput;
  };

  export type WishlistUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductUpsertWithoutWishlistItemInput = {
    update: XOR<ProductUpdateWithoutWishlistItemInput, ProductUncheckedUpdateWithoutWishlistItemInput>;
    create: XOR<ProductCreateWithoutWishlistItemInput, ProductUncheckedCreateWithoutWishlistItemInput>;
    where?: ProductWhereInput;
  };

  export type ProductUpdateToOneWithWhereWithoutWishlistItemInput = {
    where?: ProductWhereInput;
    data: XOR<ProductUpdateWithoutWishlistItemInput, ProductUncheckedUpdateWithoutWishlistItemInput>;
  };

  export type ProductUpdateWithoutWishlistItemInput = {
    title?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    images?: ProductImageUpdateManyWithoutProductNestedInput;
    variants?: ProductVariantUpdateManyWithoutProductNestedInput;
    reviews?: ReviewUpdateManyWithoutProductNestedInput;
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput;
  };

  export type ProductUncheckedUpdateWithoutWishlistItemInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput;
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput;
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput;
  };

  export type UserCreateWithoutAddressesInput = {
    email: string;
    username?: string | null;
    password?: string | null;
    displayName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    userRoles?: UserRoleCreateNestedManyWithoutUserInput;
    wishlist?: WishlistCreateNestedOneWithoutUserInput;
    reviews?: ReviewCreateNestedManyWithoutUserInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutActorInput;
  };

  export type UserUncheckedCreateWithoutAddressesInput = {
    id?: number;
    email: string;
    username?: string | null;
    password?: string | null;
    displayName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    wishlist?: WishlistUncheckedCreateNestedOneWithoutUserInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
  };

  export type UserCreateOrConnectWithoutAddressesInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>;
  };

  export type OrderCreateWithoutShippingAddressInput = {
    orderNumber: string;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user?: UserCreateNestedOneWithoutOrdersInput;
    paymentMeta?: PaymentMetaCreateNestedOneWithoutOrderInput;
    items?: OrderItemCreateNestedManyWithoutOrderInput;
    billingAddress?: AddressCreateNestedOneWithoutOrdersBillingInput;
    coupon?: CouponCreateNestedOneWithoutOrderInput;
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderInput;
    Refund?: RefundCreateNestedManyWithoutOrderInput;
  };

  export type OrderUncheckedCreateWithoutShippingAddressInput = {
    id?: number;
    orderNumber: string;
    userId?: number | null;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    billingAddressId?: number | null;
    couponId?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paymentMeta?: PaymentMetaUncheckedCreateNestedOneWithoutOrderInput;
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput;
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderInput;
    Refund?: RefundUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutShippingAddressInput = {
    where: OrderWhereUniqueInput;
    create: XOR<OrderCreateWithoutShippingAddressInput, OrderUncheckedCreateWithoutShippingAddressInput>;
  };

  export type OrderCreateManyShippingAddressInputEnvelope = {
    data: OrderCreateManyShippingAddressInput | OrderCreateManyShippingAddressInput[];
    skipDuplicates?: boolean;
  };

  export type OrderCreateWithoutBillingAddressInput = {
    orderNumber: string;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user?: UserCreateNestedOneWithoutOrdersInput;
    paymentMeta?: PaymentMetaCreateNestedOneWithoutOrderInput;
    items?: OrderItemCreateNestedManyWithoutOrderInput;
    shippingAddress?: AddressCreateNestedOneWithoutOrdersShippingInput;
    coupon?: CouponCreateNestedOneWithoutOrderInput;
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderInput;
    Refund?: RefundCreateNestedManyWithoutOrderInput;
  };

  export type OrderUncheckedCreateWithoutBillingAddressInput = {
    id?: number;
    orderNumber: string;
    userId?: number | null;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    shippingAddressId?: number | null;
    couponId?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paymentMeta?: PaymentMetaUncheckedCreateNestedOneWithoutOrderInput;
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput;
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderInput;
    Refund?: RefundUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutBillingAddressInput = {
    where: OrderWhereUniqueInput;
    create: XOR<OrderCreateWithoutBillingAddressInput, OrderUncheckedCreateWithoutBillingAddressInput>;
  };

  export type OrderCreateManyBillingAddressInputEnvelope = {
    data: OrderCreateManyBillingAddressInput | OrderCreateManyBillingAddressInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutAddressesInput = {
    update: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>;
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAddressesInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>;
  };

  export type UserUpdateWithoutAddressesInput = {
    email?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput;
    wishlist?: WishlistUpdateOneWithoutUserNestedInput;
    reviews?: ReviewUpdateManyWithoutUserNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutActorNestedInput;
  };

  export type UserUncheckedUpdateWithoutAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    wishlist?: WishlistUncheckedUpdateOneWithoutUserNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
  };

  export type OrderUpsertWithWhereUniqueWithoutShippingAddressInput = {
    where: OrderWhereUniqueInput;
    update: XOR<OrderUpdateWithoutShippingAddressInput, OrderUncheckedUpdateWithoutShippingAddressInput>;
    create: XOR<OrderCreateWithoutShippingAddressInput, OrderUncheckedCreateWithoutShippingAddressInput>;
  };

  export type OrderUpdateWithWhereUniqueWithoutShippingAddressInput = {
    where: OrderWhereUniqueInput;
    data: XOR<OrderUpdateWithoutShippingAddressInput, OrderUncheckedUpdateWithoutShippingAddressInput>;
  };

  export type OrderUpdateManyWithWhereWithoutShippingAddressInput = {
    where: OrderScalarWhereInput;
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutShippingAddressInput>;
  };

  export type OrderUpsertWithWhereUniqueWithoutBillingAddressInput = {
    where: OrderWhereUniqueInput;
    update: XOR<OrderUpdateWithoutBillingAddressInput, OrderUncheckedUpdateWithoutBillingAddressInput>;
    create: XOR<OrderCreateWithoutBillingAddressInput, OrderUncheckedCreateWithoutBillingAddressInput>;
  };

  export type OrderUpdateWithWhereUniqueWithoutBillingAddressInput = {
    where: OrderWhereUniqueInput;
    data: XOR<OrderUpdateWithoutBillingAddressInput, OrderUncheckedUpdateWithoutBillingAddressInput>;
  };

  export type OrderUpdateManyWithWhereWithoutBillingAddressInput = {
    where: OrderScalarWhereInput;
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutBillingAddressInput>;
  };

  export type UserCreateWithoutAuditLogInput = {
    email: string;
    username?: string | null;
    password?: string | null;
    displayName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    userRoles?: UserRoleCreateNestedManyWithoutUserInput;
    addresses?: AddressCreateNestedManyWithoutUserInput;
    wishlist?: WishlistCreateNestedOneWithoutUserInput;
    reviews?: ReviewCreateNestedManyWithoutUserInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAuditLogInput = {
    id?: number;
    email: string;
    username?: string | null;
    password?: string | null;
    displayName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput;
    wishlist?: WishlistUncheckedCreateNestedOneWithoutUserInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAuditLogInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>;
  };

  export type UserUpsertWithoutAuditLogInput = {
    update: XOR<UserUpdateWithoutAuditLogInput, UserUncheckedUpdateWithoutAuditLogInput>;
    create: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAuditLogInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutAuditLogInput, UserUncheckedUpdateWithoutAuditLogInput>;
  };

  export type UserUpdateWithoutAuditLogInput = {
    email?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput;
    addresses?: AddressUpdateManyWithoutUserNestedInput;
    wishlist?: WishlistUpdateOneWithoutUserNestedInput;
    reviews?: ReviewUpdateManyWithoutUserNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAuditLogInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput;
    wishlist?: WishlistUncheckedUpdateOneWithoutUserNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrderCreateWithoutReturnRequestInput = {
    orderNumber: string;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user?: UserCreateNestedOneWithoutOrdersInput;
    paymentMeta?: PaymentMetaCreateNestedOneWithoutOrderInput;
    items?: OrderItemCreateNestedManyWithoutOrderInput;
    shippingAddress?: AddressCreateNestedOneWithoutOrdersShippingInput;
    billingAddress?: AddressCreateNestedOneWithoutOrdersBillingInput;
    coupon?: CouponCreateNestedOneWithoutOrderInput;
    Refund?: RefundCreateNestedManyWithoutOrderInput;
  };

  export type OrderUncheckedCreateWithoutReturnRequestInput = {
    id?: number;
    orderNumber: string;
    userId?: number | null;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    shippingAddressId?: number | null;
    billingAddressId?: number | null;
    couponId?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paymentMeta?: PaymentMetaUncheckedCreateNestedOneWithoutOrderInput;
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput;
    Refund?: RefundUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutReturnRequestInput = {
    where: OrderWhereUniqueInput;
    create: XOR<OrderCreateWithoutReturnRequestInput, OrderUncheckedCreateWithoutReturnRequestInput>;
  };

  export type OrderItemCreateWithoutReturnRequestInput = {
    sku?: string | null;
    name: string;
    price: Decimal | DecimalJsLike | number | string;
    quantity: number;
    total: Decimal | DecimalJsLike | number | string;
    returned?: boolean;
    createdAt?: Date | string;
    order: OrderCreateNestedOneWithoutItemsInput;
    product?: ProductCreateNestedOneWithoutOrderItemInput;
    variant?: ProductVariantCreateNestedOneWithoutOrderItemInput;
  };

  export type OrderItemUncheckedCreateWithoutReturnRequestInput = {
    id?: number;
    orderId: number;
    productId?: number | null;
    variantId?: number | null;
    sku?: string | null;
    name: string;
    price: Decimal | DecimalJsLike | number | string;
    quantity: number;
    total: Decimal | DecimalJsLike | number | string;
    returned?: boolean;
    createdAt?: Date | string;
  };

  export type OrderItemCreateOrConnectWithoutReturnRequestInput = {
    where: OrderItemWhereUniqueInput;
    create: XOR<OrderItemCreateWithoutReturnRequestInput, OrderItemUncheckedCreateWithoutReturnRequestInput>;
  };

  export type RefundCreateWithoutReturnRequestInput = {
    amount: Decimal | DecimalJsLike | number | string;
    method: string;
    status?: $Enums.RefundStatus;
    providerRef?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    processedAt?: Date | string | null;
    order: OrderCreateNestedOneWithoutRefundInput;
  };

  export type RefundUncheckedCreateWithoutReturnRequestInput = {
    id?: number;
    orderId: number;
    amount: Decimal | DecimalJsLike | number | string;
    method: string;
    status?: $Enums.RefundStatus;
    providerRef?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    processedAt?: Date | string | null;
  };

  export type RefundCreateOrConnectWithoutReturnRequestInput = {
    where: RefundWhereUniqueInput;
    create: XOR<RefundCreateWithoutReturnRequestInput, RefundUncheckedCreateWithoutReturnRequestInput>;
  };

  export type OrderUpsertWithoutReturnRequestInput = {
    update: XOR<OrderUpdateWithoutReturnRequestInput, OrderUncheckedUpdateWithoutReturnRequestInput>;
    create: XOR<OrderCreateWithoutReturnRequestInput, OrderUncheckedCreateWithoutReturnRequestInput>;
    where?: OrderWhereInput;
  };

  export type OrderUpdateToOneWithWhereWithoutReturnRequestInput = {
    where?: OrderWhereInput;
    data: XOR<OrderUpdateWithoutReturnRequestInput, OrderUncheckedUpdateWithoutReturnRequestInput>;
  };

  export type OrderUpdateWithoutReturnRequestInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutOrdersNestedInput;
    paymentMeta?: PaymentMetaUpdateOneWithoutOrderNestedInput;
    items?: OrderItemUpdateManyWithoutOrderNestedInput;
    shippingAddress?: AddressUpdateOneWithoutOrdersShippingNestedInput;
    billingAddress?: AddressUpdateOneWithoutOrdersBillingNestedInput;
    coupon?: CouponUpdateOneWithoutOrderNestedInput;
    Refund?: RefundUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateWithoutReturnRequestInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    shippingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    billingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    couponId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentMeta?: PaymentMetaUncheckedUpdateOneWithoutOrderNestedInput;
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput;
    Refund?: RefundUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderItemUpsertWithoutReturnRequestInput = {
    update: XOR<OrderItemUpdateWithoutReturnRequestInput, OrderItemUncheckedUpdateWithoutReturnRequestInput>;
    create: XOR<OrderItemCreateWithoutReturnRequestInput, OrderItemUncheckedCreateWithoutReturnRequestInput>;
    where?: OrderItemWhereInput;
  };

  export type OrderItemUpdateToOneWithWhereWithoutReturnRequestInput = {
    where?: OrderItemWhereInput;
    data: XOR<OrderItemUpdateWithoutReturnRequestInput, OrderItemUncheckedUpdateWithoutReturnRequestInput>;
  };

  export type OrderItemUpdateWithoutReturnRequestInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    returned?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput;
    product?: ProductUpdateOneWithoutOrderItemNestedInput;
    variant?: ProductVariantUpdateOneWithoutOrderItemNestedInput;
  };

  export type OrderItemUncheckedUpdateWithoutReturnRequestInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    productId?: NullableIntFieldUpdateOperationsInput | number | null;
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    sku?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    returned?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RefundUpsertWithoutReturnRequestInput = {
    update: XOR<RefundUpdateWithoutReturnRequestInput, RefundUncheckedUpdateWithoutReturnRequestInput>;
    create: XOR<RefundCreateWithoutReturnRequestInput, RefundUncheckedCreateWithoutReturnRequestInput>;
    where?: RefundWhereInput;
  };

  export type RefundUpdateToOneWithWhereWithoutReturnRequestInput = {
    where?: RefundWhereInput;
    data: XOR<RefundUpdateWithoutReturnRequestInput, RefundUncheckedUpdateWithoutReturnRequestInput>;
  };

  export type RefundUpdateWithoutReturnRequestInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    method?: StringFieldUpdateOperationsInput | string;
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus;
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    order?: OrderUpdateOneRequiredWithoutRefundNestedInput;
  };

  export type RefundUncheckedUpdateWithoutReturnRequestInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    method?: StringFieldUpdateOperationsInput | string;
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus;
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type OrderCreateWithoutRefundInput = {
    orderNumber: string;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user?: UserCreateNestedOneWithoutOrdersInput;
    paymentMeta?: PaymentMetaCreateNestedOneWithoutOrderInput;
    items?: OrderItemCreateNestedManyWithoutOrderInput;
    shippingAddress?: AddressCreateNestedOneWithoutOrdersShippingInput;
    billingAddress?: AddressCreateNestedOneWithoutOrdersBillingInput;
    coupon?: CouponCreateNestedOneWithoutOrderInput;
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderInput;
  };

  export type OrderUncheckedCreateWithoutRefundInput = {
    id?: number;
    orderNumber: string;
    userId?: number | null;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    shippingAddressId?: number | null;
    billingAddressId?: number | null;
    couponId?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paymentMeta?: PaymentMetaUncheckedCreateNestedOneWithoutOrderInput;
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput;
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutRefundInput = {
    where: OrderWhereUniqueInput;
    create: XOR<OrderCreateWithoutRefundInput, OrderUncheckedCreateWithoutRefundInput>;
  };

  export type ReturnRequestCreateWithoutRefundInput = {
    reason: string;
    status?: $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: Date | string;
    processedAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    order: OrderCreateNestedOneWithoutReturnRequestInput;
    orderItem: OrderItemCreateNestedOneWithoutReturnRequestInput;
  };

  export type ReturnRequestUncheckedCreateWithoutRefundInput = {
    id?: number;
    orderId: number;
    orderItemId: number;
    reason: string;
    status?: $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: Date | string;
    processedAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type ReturnRequestCreateOrConnectWithoutRefundInput = {
    where: ReturnRequestWhereUniqueInput;
    create: XOR<ReturnRequestCreateWithoutRefundInput, ReturnRequestUncheckedCreateWithoutRefundInput>;
  };

  export type OrderUpsertWithoutRefundInput = {
    update: XOR<OrderUpdateWithoutRefundInput, OrderUncheckedUpdateWithoutRefundInput>;
    create: XOR<OrderCreateWithoutRefundInput, OrderUncheckedCreateWithoutRefundInput>;
    where?: OrderWhereInput;
  };

  export type OrderUpdateToOneWithWhereWithoutRefundInput = {
    where?: OrderWhereInput;
    data: XOR<OrderUpdateWithoutRefundInput, OrderUncheckedUpdateWithoutRefundInput>;
  };

  export type OrderUpdateWithoutRefundInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutOrdersNestedInput;
    paymentMeta?: PaymentMetaUpdateOneWithoutOrderNestedInput;
    items?: OrderItemUpdateManyWithoutOrderNestedInput;
    shippingAddress?: AddressUpdateOneWithoutOrdersShippingNestedInput;
    billingAddress?: AddressUpdateOneWithoutOrdersBillingNestedInput;
    coupon?: CouponUpdateOneWithoutOrderNestedInput;
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateWithoutRefundInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    shippingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    billingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    couponId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentMeta?: PaymentMetaUncheckedUpdateOneWithoutOrderNestedInput;
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput;
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type ReturnRequestUpsertWithoutRefundInput = {
    update: XOR<ReturnRequestUpdateWithoutRefundInput, ReturnRequestUncheckedUpdateWithoutRefundInput>;
    create: XOR<ReturnRequestCreateWithoutRefundInput, ReturnRequestUncheckedCreateWithoutRefundInput>;
    where?: ReturnRequestWhereInput;
  };

  export type ReturnRequestUpdateToOneWithWhereWithoutRefundInput = {
    where?: ReturnRequestWhereInput;
    data: XOR<ReturnRequestUpdateWithoutRefundInput, ReturnRequestUncheckedUpdateWithoutRefundInput>;
  };

  export type ReturnRequestUpdateWithoutRefundInput = {
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    order?: OrderUpdateOneRequiredWithoutReturnRequestNestedInput;
    orderItem?: OrderItemUpdateOneRequiredWithoutReturnRequestNestedInput;
  };

  export type ReturnRequestUncheckedUpdateWithoutRefundInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    orderItemId?: IntFieldUpdateOperationsInput | number;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type OrderCreateWithoutPaymentMetaInput = {
    orderNumber: string;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user?: UserCreateNestedOneWithoutOrdersInput;
    items?: OrderItemCreateNestedManyWithoutOrderInput;
    shippingAddress?: AddressCreateNestedOneWithoutOrdersShippingInput;
    billingAddress?: AddressCreateNestedOneWithoutOrdersBillingInput;
    coupon?: CouponCreateNestedOneWithoutOrderInput;
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderInput;
    Refund?: RefundCreateNestedManyWithoutOrderInput;
  };

  export type OrderUncheckedCreateWithoutPaymentMetaInput = {
    id?: number;
    orderNumber: string;
    userId?: number | null;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    shippingAddressId?: number | null;
    billingAddressId?: number | null;
    couponId?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput;
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderInput;
    Refund?: RefundUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutPaymentMetaInput = {
    where: OrderWhereUniqueInput;
    create: XOR<OrderCreateWithoutPaymentMetaInput, OrderUncheckedCreateWithoutPaymentMetaInput>;
  };

  export type OrderUpsertWithoutPaymentMetaInput = {
    update: XOR<OrderUpdateWithoutPaymentMetaInput, OrderUncheckedUpdateWithoutPaymentMetaInput>;
    create: XOR<OrderCreateWithoutPaymentMetaInput, OrderUncheckedCreateWithoutPaymentMetaInput>;
    where?: OrderWhereInput;
  };

  export type OrderUpdateToOneWithWhereWithoutPaymentMetaInput = {
    where?: OrderWhereInput;
    data: XOR<OrderUpdateWithoutPaymentMetaInput, OrderUncheckedUpdateWithoutPaymentMetaInput>;
  };

  export type OrderUpdateWithoutPaymentMetaInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutOrdersNestedInput;
    items?: OrderItemUpdateManyWithoutOrderNestedInput;
    shippingAddress?: AddressUpdateOneWithoutOrdersShippingNestedInput;
    billingAddress?: AddressUpdateOneWithoutOrdersBillingNestedInput;
    coupon?: CouponUpdateOneWithoutOrderNestedInput;
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderNestedInput;
    Refund?: RefundUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateWithoutPaymentMetaInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    shippingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    billingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    couponId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput;
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderNestedInput;
    Refund?: RefundUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type UserRoleCreateManyUserInput = {
    id?: number;
    roleId: number;
  };

  export type AddressCreateManyUserInput = {
    id?: number;
    fullName: string;
    line1: string;
    line2?: string | null;
    city: string;
    province?: string | null;
    postalCode?: string | null;
    country: string;
    phone?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: boolean;
    isDefaultBilling?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ReviewCreateManyUserInput = {
    id?: number;
    productId: number;
    rating: number;
    title?: string | null;
    body?: string | null;
    approved?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrderCreateManyUserInput = {
    id?: number;
    orderNumber: string;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    shippingAddressId?: number | null;
    billingAddressId?: number | null;
    couponId?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AuditLogCreateManyActorInput = {
    id?: number;
    action: string;
    entity: string;
    entityId?: string | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    ip?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type UserRoleUpdateWithoutUserInput = {
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput;
  };

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number;
    roleId?: IntFieldUpdateOperationsInput | number;
  };

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number;
    roleId?: IntFieldUpdateOperationsInput | number;
  };

  export type AddressUpdateWithoutUserInput = {
    fullName?: StringFieldUpdateOperationsInput | string;
    line1?: StringFieldUpdateOperationsInput | string;
    line2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    province?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: BoolFieldUpdateOperationsInput | boolean;
    isDefaultBilling?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ordersShipping?: OrderUpdateManyWithoutShippingAddressNestedInput;
    ordersBilling?: OrderUpdateManyWithoutBillingAddressNestedInput;
  };

  export type AddressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number;
    fullName?: StringFieldUpdateOperationsInput | string;
    line1?: StringFieldUpdateOperationsInput | string;
    line2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    province?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: BoolFieldUpdateOperationsInput | boolean;
    isDefaultBilling?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ordersShipping?: OrderUncheckedUpdateManyWithoutShippingAddressNestedInput;
    ordersBilling?: OrderUncheckedUpdateManyWithoutBillingAddressNestedInput;
  };

  export type AddressUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number;
    fullName?: StringFieldUpdateOperationsInput | string;
    line1?: StringFieldUpdateOperationsInput | string;
    line2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    province?: NullableStringFieldUpdateOperationsInput | string | null;
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isDefaultShipping?: BoolFieldUpdateOperationsInput | boolean;
    isDefaultBilling?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewUpdateWithoutUserInput = {
    rating?: IntFieldUpdateOperationsInput | number;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: NullableStringFieldUpdateOperationsInput | string | null;
    approved?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput;
  };

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number;
    productId?: IntFieldUpdateOperationsInput | number;
    rating?: IntFieldUpdateOperationsInput | number;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: NullableStringFieldUpdateOperationsInput | string | null;
    approved?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number;
    productId?: IntFieldUpdateOperationsInput | number;
    rating?: IntFieldUpdateOperationsInput | number;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: NullableStringFieldUpdateOperationsInput | string | null;
    approved?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderUpdateWithoutUserInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentMeta?: PaymentMetaUpdateOneWithoutOrderNestedInput;
    items?: OrderItemUpdateManyWithoutOrderNestedInput;
    shippingAddress?: AddressUpdateOneWithoutOrdersShippingNestedInput;
    billingAddress?: AddressUpdateOneWithoutOrdersBillingNestedInput;
    coupon?: CouponUpdateOneWithoutOrderNestedInput;
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderNestedInput;
    Refund?: RefundUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    shippingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    billingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    couponId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentMeta?: PaymentMetaUncheckedUpdateOneWithoutOrderNestedInput;
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput;
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderNestedInput;
    Refund?: RefundUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    shippingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    billingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    couponId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUpdateWithoutActorInput = {
    action?: StringFieldUpdateOperationsInput | string;
    entity?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    ip?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number;
    action?: StringFieldUpdateOperationsInput | string;
    entity?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    ip?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number;
    action?: StringFieldUpdateOperationsInput | string;
    entity?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    ip?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserRoleCreateManyRoleInput = {
    id?: number;
    userId: number;
  };

  export type UserRoleUpdateWithoutRoleInput = {
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput;
  };

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: IntFieldUpdateOperationsInput | number;
  };

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: IntFieldUpdateOperationsInput | number;
  };

  export type ProductImageCreateManyProductInput = {
    id?: number;
    url: string;
    alt?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProductVariantCreateManyProductInput = {
    id?: number;
    name: string;
    skuPrefix?: string | null;
    price: Decimal | DecimalJsLike | number | string;
    compareAtPrice?: Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ReviewCreateManyProductInput = {
    id?: number;
    userId?: number | null;
    rating: number;
    title?: string | null;
    body?: string | null;
    approved?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrderItemCreateManyProductInput = {
    id?: number;
    orderId: number;
    variantId?: number | null;
    sku?: string | null;
    name: string;
    price: Decimal | DecimalJsLike | number | string;
    quantity: number;
    total: Decimal | DecimalJsLike | number | string;
    returned?: boolean;
    createdAt?: Date | string;
  };

  export type WishlistItemCreateManyProductInput = {
    id?: number;
    wishlistId: number;
    variantId?: number | null;
    createdAt?: Date | string;
  };

  export type ProductImageUpdateWithoutProductInput = {
    url?: StringFieldUpdateOperationsInput | string;
    alt?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductImageUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number;
    url?: StringFieldUpdateOperationsInput | string;
    alt?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductImageUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number;
    url?: StringFieldUpdateOperationsInput | string;
    alt?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductVariantUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string;
    skuPrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    compareAtPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inventory?: InventoryUpdateManyWithoutVariantNestedInput;
    OrderItem?: OrderItemUpdateManyWithoutVariantNestedInput;
  };

  export type ProductVariantUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number;
    name?: StringFieldUpdateOperationsInput | string;
    skuPrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    compareAtPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inventory?: InventoryUncheckedUpdateManyWithoutVariantNestedInput;
    OrderItem?: OrderItemUncheckedUpdateManyWithoutVariantNestedInput;
  };

  export type ProductVariantUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number;
    name?: StringFieldUpdateOperationsInput | string;
    skuPrefix?: NullableStringFieldUpdateOperationsInput | string | null;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    compareAtPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null;
    attributes?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewUpdateWithoutProductInput = {
    rating?: IntFieldUpdateOperationsInput | number;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: NullableStringFieldUpdateOperationsInput | string | null;
    approved?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutReviewsNestedInput;
  };

  export type ReviewUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    rating?: IntFieldUpdateOperationsInput | number;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: NullableStringFieldUpdateOperationsInput | string | null;
    approved?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    rating?: IntFieldUpdateOperationsInput | number;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: NullableStringFieldUpdateOperationsInput | string | null;
    approved?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderItemUpdateWithoutProductInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    returned?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput;
    variant?: ProductVariantUpdateOneWithoutOrderItemNestedInput;
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderItemNestedInput;
  };

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    sku?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    returned?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderItemNestedInput;
  };

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    sku?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    returned?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WishlistItemUpdateWithoutProductInput = {
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    wishlist?: WishlistUpdateOneRequiredWithoutItemsNestedInput;
  };

  export type WishlistItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number;
    wishlistId?: IntFieldUpdateOperationsInput | number;
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WishlistItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number;
    wishlistId?: IntFieldUpdateOperationsInput | number;
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InventoryCreateManyVariantInput = {
    id?: number;
    sku: string;
    quantity?: number;
    reserved?: number;
    location?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrderItemCreateManyVariantInput = {
    id?: number;
    orderId: number;
    productId?: number | null;
    sku?: string | null;
    name: string;
    price: Decimal | DecimalJsLike | number | string;
    quantity: number;
    total: Decimal | DecimalJsLike | number | string;
    returned?: boolean;
    createdAt?: Date | string;
  };

  export type InventoryUpdateWithoutVariantInput = {
    sku?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    reserved?: IntFieldUpdateOperationsInput | number;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InventoryUncheckedUpdateWithoutVariantInput = {
    id?: IntFieldUpdateOperationsInput | number;
    sku?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    reserved?: IntFieldUpdateOperationsInput | number;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InventoryUncheckedUpdateManyWithoutVariantInput = {
    id?: IntFieldUpdateOperationsInput | number;
    sku?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    reserved?: IntFieldUpdateOperationsInput | number;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderItemUpdateWithoutVariantInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    returned?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput;
    product?: ProductUpdateOneWithoutOrderItemNestedInput;
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderItemNestedInput;
  };

  export type OrderItemUncheckedUpdateWithoutVariantInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    productId?: NullableIntFieldUpdateOperationsInput | number | null;
    sku?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    returned?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderItemNestedInput;
  };

  export type OrderItemUncheckedUpdateManyWithoutVariantInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    productId?: NullableIntFieldUpdateOperationsInput | number | null;
    sku?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    returned?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderItemCreateManyOrderInput = {
    id?: number;
    productId?: number | null;
    variantId?: number | null;
    sku?: string | null;
    name: string;
    price: Decimal | DecimalJsLike | number | string;
    quantity: number;
    total: Decimal | DecimalJsLike | number | string;
    returned?: boolean;
    createdAt?: Date | string;
  };

  export type ReturnRequestCreateManyOrderInput = {
    id?: number;
    orderItemId: number;
    reason: string;
    status?: $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: Date | string;
    processedAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type RefundCreateManyOrderInput = {
    id?: number;
    returnRequestId?: number | null;
    amount: Decimal | DecimalJsLike | number | string;
    method: string;
    status?: $Enums.RefundStatus;
    providerRef?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    processedAt?: Date | string | null;
  };

  export type OrderItemUpdateWithoutOrderInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    returned?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    product?: ProductUpdateOneWithoutOrderItemNestedInput;
    variant?: ProductVariantUpdateOneWithoutOrderItemNestedInput;
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderItemNestedInput;
  };

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number;
    productId?: NullableIntFieldUpdateOperationsInput | number | null;
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    sku?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    returned?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderItemNestedInput;
  };

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number;
    productId?: NullableIntFieldUpdateOperationsInput | number | null;
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    sku?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    returned?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReturnRequestUpdateWithoutOrderInput = {
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    orderItem?: OrderItemUpdateOneRequiredWithoutReturnRequestNestedInput;
    refund?: RefundUpdateOneWithoutReturnRequestNestedInput;
  };

  export type ReturnRequestUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderItemId?: IntFieldUpdateOperationsInput | number;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    refund?: RefundUncheckedUpdateOneWithoutReturnRequestNestedInput;
  };

  export type ReturnRequestUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderItemId?: IntFieldUpdateOperationsInput | number;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type RefundUpdateWithoutOrderInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    method?: StringFieldUpdateOperationsInput | string;
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus;
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    returnRequest?: ReturnRequestUpdateOneWithoutRefundNestedInput;
  };

  export type RefundUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number;
    returnRequestId?: NullableIntFieldUpdateOperationsInput | number | null;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    method?: StringFieldUpdateOperationsInput | string;
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus;
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type RefundUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number;
    returnRequestId?: NullableIntFieldUpdateOperationsInput | number | null;
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    method?: StringFieldUpdateOperationsInput | string;
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus;
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ReturnRequestCreateManyOrderItemInput = {
    id?: number;
    orderId: number;
    reason: string;
    status?: $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: Date | string;
    processedAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type ReturnRequestUpdateWithoutOrderItemInput = {
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    order?: OrderUpdateOneRequiredWithoutReturnRequestNestedInput;
    refund?: RefundUpdateOneWithoutReturnRequestNestedInput;
  };

  export type ReturnRequestUncheckedUpdateWithoutOrderItemInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    refund?: RefundUncheckedUpdateOneWithoutReturnRequestNestedInput;
  };

  export type ReturnRequestUncheckedUpdateManyWithoutOrderItemInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderId?: IntFieldUpdateOperationsInput | number;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus;
    evidence?: NullableJsonNullValueInput | InputJsonValue;
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type OrderCreateManyCouponInput = {
    id?: number;
    orderNumber: string;
    userId?: number | null;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    shippingAddressId?: number | null;
    billingAddressId?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrderUpdateWithoutCouponInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutOrdersNestedInput;
    paymentMeta?: PaymentMetaUpdateOneWithoutOrderNestedInput;
    items?: OrderItemUpdateManyWithoutOrderNestedInput;
    shippingAddress?: AddressUpdateOneWithoutOrdersShippingNestedInput;
    billingAddress?: AddressUpdateOneWithoutOrdersBillingNestedInput;
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderNestedInput;
    Refund?: RefundUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateWithoutCouponInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    shippingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    billingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentMeta?: PaymentMetaUncheckedUpdateOneWithoutOrderNestedInput;
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput;
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderNestedInput;
    Refund?: RefundUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateManyWithoutCouponInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    shippingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    billingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WishlistItemCreateManyWishlistInput = {
    id?: number;
    productId: number;
    variantId?: number | null;
    createdAt?: Date | string;
  };

  export type WishlistItemUpdateWithoutWishlistInput = {
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    product?: ProductUpdateOneRequiredWithoutWishlistItemNestedInput;
  };

  export type WishlistItemUncheckedUpdateWithoutWishlistInput = {
    id?: IntFieldUpdateOperationsInput | number;
    productId?: IntFieldUpdateOperationsInput | number;
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WishlistItemUncheckedUpdateManyWithoutWishlistInput = {
    id?: IntFieldUpdateOperationsInput | number;
    productId?: IntFieldUpdateOperationsInput | number;
    variantId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderCreateManyShippingAddressInput = {
    id?: number;
    orderNumber: string;
    userId?: number | null;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    billingAddressId?: number | null;
    couponId?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrderCreateManyBillingAddressInput = {
    id?: number;
    orderNumber: string;
    userId?: number | null;
    status?: $Enums.OrderStatus;
    subtotal: Decimal | DecimalJsLike | number | string;
    shipping?: Decimal | DecimalJsLike | number | string;
    tax?: Decimal | DecimalJsLike | number | string;
    total: Decimal | DecimalJsLike | number | string;
    paymentMethod: $Enums.PaymentMethod;
    shippingAddressId?: number | null;
    couponId?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrderUpdateWithoutShippingAddressInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutOrdersNestedInput;
    paymentMeta?: PaymentMetaUpdateOneWithoutOrderNestedInput;
    items?: OrderItemUpdateManyWithoutOrderNestedInput;
    billingAddress?: AddressUpdateOneWithoutOrdersBillingNestedInput;
    coupon?: CouponUpdateOneWithoutOrderNestedInput;
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderNestedInput;
    Refund?: RefundUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateWithoutShippingAddressInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    billingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    couponId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentMeta?: PaymentMetaUncheckedUpdateOneWithoutOrderNestedInput;
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput;
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderNestedInput;
    Refund?: RefundUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateManyWithoutShippingAddressInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    billingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    couponId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderUpdateWithoutBillingAddressInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutOrdersNestedInput;
    paymentMeta?: PaymentMetaUpdateOneWithoutOrderNestedInput;
    items?: OrderItemUpdateManyWithoutOrderNestedInput;
    shippingAddress?: AddressUpdateOneWithoutOrdersShippingNestedInput;
    coupon?: CouponUpdateOneWithoutOrderNestedInput;
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderNestedInput;
    Refund?: RefundUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateWithoutBillingAddressInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    shippingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    couponId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentMeta?: PaymentMetaUncheckedUpdateOneWithoutOrderNestedInput;
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput;
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderNestedInput;
    Refund?: RefundUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateManyWithoutBillingAddressInput = {
    id?: IntFieldUpdateOperationsInput | number;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    userId?: NullableIntFieldUpdateOperationsInput | number | null;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod;
    shippingAddressId?: NullableIntFieldUpdateOperationsInput | number | null;
    couponId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
